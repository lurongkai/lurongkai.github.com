
 <!DOCTYPE HTML>
<html lang="default">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  
    <title>lurongkai&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Lu Rongkai">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="lurongkai&#39;s blog">
<meta property="og:url" content="https://lurongkai.github.io/index.html">
<meta property="og:site_name" content="lurongkai&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lurongkai&#39;s blog">

    
    <link rel="alternative" href="/atom.xml" title="lurongkai&#39;s blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="lurongkai&#39;s blog">lurongkai&#39;s blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search">
						<input type="hidden" name="q" value="site:lurongkai.github.io">
					</form>
					
					</li>
				</ul>
			</ul></nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/26/handle-error-gracefully-in-golang/" title="如何优雅的在Golang中进行错误处理" itemprop="url">如何优雅的在Golang中进行错误处理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2019-07-26T04:06:14.000Z" itemprop="datePublished"> Published 2019-07-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>如何优雅的在<code>Golang</code>中进行错误处理？</p>
<p>答案是：没有……（本文完）</p>
<hr>
<p>开个玩笑，<code>Golang</code>中的错误处理方式一直是社区热烈讨论的话题，有力挺者，有抱怨者，但不论如何，自 2009 年<code>Golang</code>正式发布以来，关于错误处理就一直是现在这种状况。</p>
<p>随着<code>Golang</code>愈加的火爆，原本是<code>Java</code>、<code>Node</code>、<code>C#</code>等语言擅长的应用级开发领域也逐渐出现<code>Golang</code>的身影。<code>Golang</code>自身其实更加擅长做基础设施级开发，例如<code>docker</code>，例如<code>k8s</code>，再如<code>etcd</code>，它友好的内存管理和简单到粗暴的语法（25 个关键字），特别适合过去<code>C</code>和<code>C++</code>这些语言所擅长的部分场景。我们有理由相信，<code>Golang</code>下一个大的引爆点将也许会在<code>IoT</code>上，因为它天然的适合。</p>
<p>当一门语言火起来，就会出现各式各样的应用，于是<code>MVC</code>框架有了，音视频处理库有了，各种数据库驱动有了，甚至服务框架也出现了，游戏、<code>Machine Learning</code>都不在话下，还要啥自行车？组合一下做应用级开发妥妥的没毛病。</p>
<p>但是，成也这 25 个关键字，败也这 25 个关键字，究其根本原因，都是因为它背后<strong>简单</strong>的哲学。</p>
<p>做应用级开发可不是那么简单的，这涉及到很多的细节处理，例如本文将要讨论的错误处理。如果只是写一个库，那么这个话题相对比较简单，因为与<code>API</code>打交道的都是开发者，你只管开心的往外扔<code>error</code>就好了，总会有倒霉的程序员在使用你的代码时<strong>DEBUG</strong>到白头，最后，以最严谨的方式，小心使用你的库；可是有人出现的地方就会有幺蛾子，一个常见的误区就是将<strong>业务错误</strong>、<strong>运行时错误</strong>、<strong>程序错误</strong>一股脑的当成相同的<code>error</code>来处理。</p>
        
        
        <p class="article-more-link">
          
            <a href="/2019/07/26/handle-error-gracefully-in-golang/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Golang/">Golang</a><a href="/tags/error-handling/">error-handling</a><a href="/tags/microservice/">microservice</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/07/26/handle-error-gracefully-in-golang/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/02/15/shinetech-2018-security-training-summary/" title="shinetech 2018 security training summary" itemprop="url">shinetech 2018 security training summary</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2019-02-15T05:10:40.000Z" itemprop="datePublished"> Published 2019-02-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><strong>「关注软件开发中的安全」</strong></p>
<blockquote>
<p>18年10月底的时候，我在Shinetech Software内部做了一场在线的培训，主要关注的是在软件开发过程中，对于安全方面的工程实践，并不算是很深入的探讨，更多的是一些极不易察觉但又很常见的疏忽，这篇博客整理出来。</p>
</blockquote>
        
        
        <p class="article-more-link">
          
            <a href="/2019/02/15/shinetech-2018-security-training-summary/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/training/">training</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/security/">security</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/02/15/shinetech-2018-security-training-summary/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/02/retional-team-with-communication/" title="理性沟通的团队" itemprop="url">理性沟通的团队</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2017-03-02T13:33:00.000Z" itemprop="datePublished"> Published 2017-03-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>（部分整理自Shinetech 2016-10-19内部分享）</p>
<blockquote>
<p>《敏捷软件开发宣言》<br>我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：</p>
<p>个体和互动 高于 流程和工具<br>工作的软件 高于 详尽的文档<br>客户合作 高于 合同谈判<br>响应变化 高于 遵循计划</p>
<p>也就是说，尽管右项有其价值，我们更重视左项的价值。</p>
</blockquote>
<p>小而精的团队，往往更具有战斗力。我们提倡敏捷，也愿意相信它的价值，然而敏捷的实践却不仅仅是清晨站会、打打估算扑克那么简单。在我看来，其中最容易被忽视的一句便是：<code>尽管右项有其价值，我们更重视左项的价值</code>。如果一个开发者不写文档的理由是“我敏捷”，这就大错特错了，我所理解的敏捷，是关于『沟通』和『协作』的方式。<br>
        
        
        </p><p class="article-more-link">
          
            <a href="/2017/03/02/retional-team-with-communication/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/productivity/">productivity</a><a href="/tags/collaboration/">collaboration</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/03/02/retional-team-with-communication/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/24/functional-programming-skills/" title="函数式编程中的常用技巧" itemprop="url">函数式编程中的常用技巧</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2015-11-24T08:53:34.000Z" itemprop="datePublished"> Published 2015-11-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在Closure、Haskell、Python、Ruby这些语言越来越流行的今天，我们撇开其在数学纯度性上的不同，单从它们都拥有<code>一类函数</code>特性来讲，讨论函数式编程也显得很有意义。</p>
<p>一类函数为函数式编程打下了基础，虽然这并不能表示可以完整发挥函数式编程的优势，但是如果能掌握一些基础的函数式编程技巧，那么仍将对并行编程、声明性编程以及测试等方面提供新的思路。</p>
<p>很多开发者都有听过函数式编程，但更多是抱怨它太难，太碾压智商。的确，函数式编程中很多的概念理解起来都有一定的难度，最著名的莫过于<a href="https://en.wikipedia.org/wiki/Monad_(functional_programming" target="_blank" rel="noopener">单子</a>，但是通过一定的学习和实践会发现，函数式编程能让你站在一个更高的角度思考问题，并在某种层面上提升效率甚至是性能。我们都知道飞机比汽车难开，但是开飞机却明显比开汽车快，高学习成本的东西解决的大部分是高回报的需求，这不敢说是定论，但从实践来看这句话基本也正确。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener">wikipedia</a>上对于函数式编程的解释是这样的：</p>
<blockquote>
<p>In computer science, functional programming is a programming paradigm—a style of building the structure and elements of computer programs—that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data. </p>
</blockquote>
<p>翻译过来是这样的：</p>
<blockquote>
<p>在计算机科学中，函数式编程是一种编程范式，一种构建计算机结构和元素的风格，它将计算看作是对数学函数的求值，并避免改变状态以及可变数据。</p>
</blockquote>
<p>关键的其实就两点：不可变数据以及函数求值（表达式求值）。由这两点引申出了一些重要的方面。</p>
<h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p>FP中并没有变量的概念，东西一旦创建后就不能再变化，所以在FP中经常使用“值”这一术语而非“变量”。</p>
<p>不变性对程序并行化有着深远的影响，因为一切不可变意味着可以就地并行，不涉及竞态，也就没有了锁的概念。</p>
<p>不变性还对测试有了新的启发，函数的输入和输出不改变任何状态，于是我们可以随时使用REPL工具来测试函数，测试通过即可使用，不用担心行为的异常，不变性保证了该函数在任何地方都能以同样的方式工作。事实上，在函数式编程实践中，“编写函数、使用REPL工具测试，使用”三步曲有着强大的生产力。</p>
<p>不变性还对重构有了新的意义，因为它使得对函数的执行有了数学意义，于是乎重构本身成了对函数的化简。FP使代码的分析变的容易，从而使重构的过程也变的轻松了许多。</p>
<h3 id="声明性风格"><a href="#声明性风格" class="headerlink" title="声明性风格"></a>声明性风格</h3><p>FP程序代码是一个描述期望结果的表达式，所以可以很轻松、安全的将这些表达式组合起来，在隐藏执行细节的同时隐藏复杂性。可组合性是FP程序的基本能力之一，所以要求每个组合子都有良好的语义，这和声明式风格不谋而合。</p>
<p>我们经常写<code>SQL</code>，它就是一种声明性的语言，声明性只提出<code>what to do</code>而不解决<code>how to do</code>的问题，例如下面：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> create_date &gt; <span class="string">'2015-11-21'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> create_date <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
<p>省去了具体的数据库查询细节，我们只需要告诉数据库要orders表里创建日期大于11月21号的数据，并只要id和amout两个字段，然后按创建日期降序。这是一种典型的声明性风格。</p>
<blockquote>
<p>是的，我同意靠嘴是解决不了任何问题的，what to do提出来后总得有地方或有人实现具体的细节，也就是说总是需要有how to do的部分来支持。但是换个思路，假如你每天都在写foreach语句来遍历某个集合数据，难道你没有想过你此时正在重复的how to do吗？就不能将某种通用的“思想”提取出来复用吗？假如你可以提取，那么你会发现，这个提取出来的词语（或函数名）已经是一种what to do层面的思想了。</p>
</blockquote>
<p>再比如，对于一个整型数据集合，我们要通过C#遍历并拿到所有的偶数，典型的命令式编程会这么做：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> sourceList) &#123;</span><br><span class="line">    <span class="keyword">if</span>(item % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        result.Add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>这对很多人来说都很轻松，因为就是在按照计算机的思维一步一步的指挥。那么声明性的风格呢？</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">return</span> sourceList.Where(item =&gt; item %<span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// or LINQ style</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">from</span> item <span class="keyword">in</span> sourceList <span class="keyword">where</span> item % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">select</span> item;</span><br></pre></td></tr></table></figure>
<p>甚至更进一步，假设我们有声明性原语，可以做到更好：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="comment">// if we already defined an atom function like below:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">NumberIsEven</span>(<span class="params"><span class="keyword">int</span> number</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then we can re-use it directly.</span></span><br><span class="line"><span class="keyword">return</span> sourceList.Where(NumberIsEven);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说句题外话，我有个数据库背景很深的C#工程师同事，第一次见到LINQ时一脸不屑的说：C#的LINQ就是抄SQL的。其实我并没有告诉它C#的LINQ借鉴的是FP的高阶函数以及monad，只是和SQL长的比较像而已。当然我并不排除这可能是为了避免新的学习成本所以选用了和SQL相近的关键字，但是LINQ的启蒙却真的不是SQL。</p>
</blockquote>
<blockquote>
<p>我更没有说GC、闭包、高阶函数等先进的东西并不是.NET抄Java或者谁抄谁，大家都是从50多年前的LISP以及LISP系的Scheme来抄。我似乎听到了apple指着ms说：你抄我的图形界面技术…</p>
</blockquote>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>在FP中，每个表达式都有对应的类型，这确保了表达式组合的正确性。表达式的类型可以是某种基元类型，可以是复合类型，当然，也可以是支持泛型类型的，例如F#、ML、Haskell。类型也为编译时检查提供了基础，同时，也让屌炸天的类型推断有了根据。</p>
<p>F#的类型推断要比C#强太多了，一方面是受益于ML及OCamel的影响，一方面是在CLR层面上泛型的良好设计。很多人并不知道F#的历史可以追溯到.NET第一个版本的发布（2002年），而当时F#作为一个研究项目，对泛型的需求很大，遗憾的是.NET第一版并没有从CLR层面支持泛型。所以，F#团队参与设计了.NET的泛型设计并加入到.NET 2.0开始的后续版本，这也同时让所有.NET语言获益。</p>
<p>那么我们以不同的视角审视一下泛型。何为泛型？泛型是一种代码重用的技术，它使用类型占位符来将真正的类型延迟到运行时再决定，类似一种类型模板，当需要的时候会插入真实的类型。我们换一个角度，将泛型理解为一种包装而非模板，它打包了某种具体的类型，使用类似F#的签名表达会是这样：<code>&#39;T -&gt; M&lt;&#39;T&gt;</code>，转变这种思维很重要，尤其是在编写F#的计算表达式（即Monad）时，经常会使用<strong>包装类</strong>这个术语。在C#中也可以看到类似的方面，例如<code>int?</code>其实是指<code>Nullable&lt;T&gt;</code>对<code>int</code>类型的包装。</p>
<h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p>由于整个程序就是一个大的表达式，计算机在不断的求值这个表达式的同时也就意味着我们的程序正在运行。那么很有挑战的一方面就是，程序该如何组织？</p>
<p>FP中没有语句的概念，就连常用的绑定值操作也是一个表达式而非语句。那么这一切如何实现呢？假设我们有下面这段C#代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="number">9</span>;</span><br></pre></td></tr></table></figure>
<p>我们有两个赋值语句（并且有先后依赖），如何用表达式的方式来重写？</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="comment">// we build this helper function for next use.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Eval</span>(<span class="params"><span class="keyword">int</span> binding, Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; continues</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> contineues(binding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then, below sample is totally one expression.</span></span><br><span class="line">Eval(<span class="number">11</span>, a =&gt; </span><br><span class="line">    <span class="comment">//now a is binding to 11</span></span><br><span class="line">    Eval(a + <span class="number">9</span>, b =&gt; b</span><br><span class="line">        <span class="comment">// now, b is binding to a + 9, </span></span><br><span class="line">        <span class="comment">// which is evaluate to 11 + 9</span></span><br><span class="line">    ));</span><br></pre></td></tr></table></figure>
<p>这里使用了函数闭包，我们会在接下来的柯里化部分继续谈到。通过使用continues（延续）技术以及闭包，我们成功的将赋值语句变了函数式的表达式，这也是F#中<code>let</code>的基本工作方式。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p><code>一类函数</code>特性使得高阶函数成为可能。何为高阶函数？高阶函数(higher-order function)就是指能函数自身能够接受函数，并可以返回函数的一种函数。我们来看下面两个例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C#</span></span><br><span class="line"><span class="keyword">var</span> filteredData = Products.Where(p =&gt; p.Price &gt; <span class="number">10.0</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello world."</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>C#中的<code>Where</code>接受了一个匿名函数（Lambda表达式），所以它是一个高阶函数，javascript的<code>SetInterval</code>函数接受一个匿名的回调函数，因而也是高阶的。</p>
<p>我们用一个更加有表现力的例子来说明高阶函数可以提供的强大能力：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> addBy value = <span class="keyword">fun</span> n -&gt; n + value</span><br><span class="line"><span class="keyword">let</span> add10 = addBy <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> add20 = addBy <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result11 = add10 <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> result21 = add20 <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>addBy</code>函数接受一个值value，并返回一个匿名函数，该匿名函数对参数n和闭包值value相加后返回结果。也就是说，<code>addBy</code>函数通过传入的参数，返回了一个经过定制的函数。</p>
<p>高阶函数使函数定制变的容易，它可以隐藏具体的执行细节，将可定制的部分（或行为）抽象出来并传给某个高阶函数使用。</p>
<blockquote>
<p>是的，这听起来很像是OO设计模式中的模板方法，在FP中并没有模板方法的概念，使用高阶函数就可以达到目的了。</p>
</blockquote>
<p>在下节的柯里化部分将会看到，这种定制函数的能力内建在很多FP语言中，Haskell、F#中都有提供。</p>
<p>在FP中最常用的就是<code>map</code>、<code>filter</code>、<code>fold</code>了，我们通过检查在F#中它们的签名就可以推测它们的用途：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map:    (&apos;a -&gt; &apos;b) -&gt; &apos;a list -&gt; &apos;b list</span><br><span class="line">filter: (&apos;a -&gt; bool) -&gt; &apos;a list -&gt; &apos;a list</span><br><span class="line">fold:   (&apos;a -&gt; &apos;b -&gt; &apos;a) -&gt; &apos;a -&gt; &apos;b list -&gt; &apos;a</span><br></pre></td></tr></table></figure>
<p><code>map</code>通过对列表中的每个元素执行参数函数，得到相应的结果，是一种映射。C#对应的操作为<code>Select</code>。<br><code>filter</code>通过对列表中的每个元素执行参数函数，将结果为<code>true</code>的元素返回，是一种过滤。C#对应的操作为<code>Where</code>。<br><code>fold</code>相对复杂一些，我们可以理解为一种带累加器的化简函数。C#对应的操作为<code>Aggregate</code>。</p>
<p>之前我们提到过，泛型本身可以看做是某种类型的包装，所以如果我们面对一个<code>&#39;T list</code>，那么我们可以说这是一个<code>&#39;T</code>类型的<strong>包装</strong>，注意此处并没有说它是个范型列表。于是乎，我们对<code>map</code>有了一种更加高层次的理解，我们可以尝试一种新的签名：<code>(&#39;a -&gt; &#39;b) -&gt; M&lt;&#39;a&gt; -&gt; M&lt;&#39;b&gt;</code>，这就是说，<code>map</code>将拆开包装，对包装内类型进行转换产生某种新的类型，然后再以同样的包装将其重新打包。</p>
<p><code>map</code>也叫普通投影，请记住这个签名，我们在最后的延续一节将提出一个新的术语叫<strong>平展投影</strong>，到时候还会来对比<code>map</code>。</p>
<p>如果我们对两个甚至是三个包装类型的值进行投影呢？我们会猜想它的签名可能是这样：</p>
<ul>
<li>lift2: <code>(&#39;a -&gt; &#39;b -&gt; &#39;c) -&gt; M&lt;&#39;a&gt; -&gt; M&lt;&#39;b&gt; -&gt; M&lt;&#39;c&gt;</code></li>
<li>lift3: <code>(&#39;a -&gt; &#39;b -&gt; &#39;c -&gt; &#39;d) -&gt; M&lt;&#39;a&gt; -&gt; M&lt;&#39;b&gt; -&gt; M&lt;&#39;c&gt; -&gt; M&lt;&#39;d&gt;</code></li>
</ul>
<p>其实这便是FP中为人们广泛熟知的“提升”，它甚至可以称作是一种函数式设计模式。提升允许将一个对值进行处理的函数转换为一个在不同设置中完成相同任务的函数。</p>
<h2 id="柯里化和部分函数应用"><a href="#柯里化和部分函数应用" class="headerlink" title="柯里化和部分函数应用"></a>柯里化和部分函数应用</h2><blockquote>
<p>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p>
</blockquote>
<p>这段定义有些拗口，我们借助前面的一个例子，并通过javascript来解释一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addBy</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n + value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add10 = addBy(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> result11 = add10(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>javascript版本完全是F#版本的复刻，如果我们想换个方式来使用它呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result11 = addBy(<span class="number">10</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这明显是不可以的（并不是说不能调用，而是说结果并非所期望的），因为<code>addBy</code>函数只接收一个参数。但是柯里化要求我们函数只能接受一个参数，该如何处理呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result11 = addBy(<span class="number">10</span>)(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//             ~~~~~~~~~    return an anonymous fn(anonymousFn, e.g)</span></span><br></pre></td></tr></table></figure>
<p>如此就可以了，<code>addBy(10)</code>将被正常调用没有问题，返回的匿名函数又立即被调用<code>anonymousFn(1)</code>，结果正是我们所期望的。</p>
<p>假如javascript在调用函数时可以像Ruby和F#那样省略括号呢？我们会得到<code>addBy 10 1</code>，这和真实的多参数函数调用就更像了。在<code>addBy</code>函数内部，返回匿名函数时带出了<code>value</code>的值，这是一个典型的闭包应用。在<code>addBy</code>调用后，<code>value</code>值将在外部作用域中不可见，而在返回的匿名函数内部，<code>value</code>值仍然是可以采集到的。</p>
<blockquote>
<p>闭包（Closure）是词法闭包（Lexical Closure）或函数闭包（function closures）的简称，可参见<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming" target="_blank" rel="noopener">wikipedia</a>)上的详细解释。</p>
</blockquote>
<p>如此看来，是不是所有的多参数函数都能被柯里化呢？我们假想一个这样的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAddFn</span>(<span class="params">n1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n3</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n4</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> n1 + n2 + n3 + n4;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = fakeAddFn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//           ~~~~~~~~~~~~           now is function(n2)</span></span><br><span class="line"><span class="comment">//                       ~~~        now is function(n3)</span></span><br><span class="line"><span class="comment">//                          ~~~     now is function(n4)</span></span><br><span class="line"><span class="comment">//                             ~~~  return n1 + n2 + n3 + n4</span></span><br></pre></td></tr></table></figure>
<p>但是这样又显得非常麻烦并且经常会出现智商不够用的情况，如果语言能够内建支持currying，那么情况将乐观许多，例如F#可以这样做：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fakeAddFn n1 n2 n3 n4 = n1 + n2 + n3 + n4</span><br></pre></td></tr></table></figure>
<p>编译器将自动进行柯里化，完全展开形式如下：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fakeAddFn n1 = <span class="keyword">fun</span> n2 -&gt; <span class="keyword">fun</span> n3 -&gt; <span class="keyword">fun</span> n4 -&gt; n1 + n2 + n3 + n4</span><br></pre></td></tr></table></figure>
<p>并且F#调用函数时可以省略括号，所以对<code>fakeAddFn</code>的调用看上去就像是对多参数函数的调用：<code>let result = fakeAddFn 1 2 3 4</code>。到这里你也许会问，currying到底有什么用呢？答案是：部分函数应用。</p>
<p>由于编译器自动进行currying，所以每一个函数本身是可以部分调用的，举个例子，F#中的<code>+</code>运算符其实是一个函数，定义如下：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (+) a b = a + b</span><br></pre></td></tr></table></figure>
<p>利用前面的知识我们知道它的完全形式是这样：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (+) a = <span class="keyword">fun</span> b -&gt; a + b</span><br></pre></td></tr></table></figure>
<p>所以我们自然可以编写一个表达式只给<code>+</code>运算符一个参数，这样返回的结果是另一个接受一个参数的函数，之后，再传入剩余一个参数。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add10partial = (+) <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> result = add10partial <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>同时，由于<code>add10partial</code>函数的签名是<code>int -&gt; int</code>，所以可以直接用于<code>List.map</code>函数，如下：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add10partial = (+) <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> result = someIntList |&gt; List.map add10partial</span><br><span class="line"></span><br><span class="line"><span class="comment">// upon expression equals below </span></span><br><span class="line"><span class="comment">// let result = List.map add10partial someIntList</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or, more magic, make List.map partially:</span></span><br><span class="line"><span class="keyword">let</span> mapper = (+) <span class="number">10</span> |&gt; List.map</span><br><span class="line"><span class="keyword">let</span> sameResult = someIntList |&gt; mapper</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>|&gt;</code>运算符本身也是一个函数，简单的定义就是<code>let (|&gt;) p f = f p</code>，这种类似管道的表达式为FP提供了更高级的表达。</p>
</blockquote>
<p>我们知道FP是以<code>Alonzo Church</code>的lambda演算为理论基础的，lambda演算的函数都是接受一个参数，后来<code>Haskell Curry</code>提出的currying概念为lambda演算补充了表示多参数函数的能力。</p>
<h2 id="递归及优化"><a href="#递归及优化" class="headerlink" title="递归及优化"></a>递归及优化</h2><p>由于FP没有可变状态的概念，所以当我们以OO的思维来思考时会觉得无从下手，在这个时候，递归就是强有力的武器。</p>
<blockquote>
<p>其实并不是说现代的FP语言没有可变状态，其实几乎所有的FP语言都做了一定程度的妥协，诸如F#构建在.NET平台之上，那么在与BCL提供的类库互操作时避免不了要涉及状态的改变，而且如果全部使用递归的方式来处理可变状态，在性能上也是一个严峻的考验。所以F#其实提供了可变操作，但是需要明确的使用<code>mutable</code>关键字来声明或者使用<code>引用单元格</code>。</p>
</blockquote>
<p>以一个典型的例子为开始，我们实现一个Factorial阶乘函数，如果以命令式的方式来实现是这样的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Factorial</span>(<span class="params"><span class="keyword">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">2</span>; index &lt;= n; index++) &#123;</span><br><span class="line">        result = result * index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是典型的how to do，我们开始尝试用递归并且尽可能的用表达式来解决问题：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Factorial</span>(<span class="params"><span class="keyword">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span></span><br><span class="line">        ? <span class="number">1</span></span><br><span class="line">        : n * Factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是可以正常工作的，但是如果n的值为10,000呢？会栈溢出。此时便出现了本节要解决的第二个问题：递归优化。</p>
<p>那么这段递归代码为什么会溢出？我们展开它的调用过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n               (n-1)       ...      3         2       1  // state</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">n*f(n-1) -&gt; (n-1)*f(n-2) -&gt; ... -&gt; 3*f(2) -&gt; 2*f(1) -&gt; 1  // stack in</span><br><span class="line">                                                       |  </span><br><span class="line">n*r      &lt;-  (n-1)*(r-1) &lt;- ... &lt;-   3*2  &lt;-   2*1  &lt;- 1  // stack out</span><br></pre></td></tr></table></figure>
<p>简单来说，因为当<code>n</code>大于1时，每次递归都卡在了<code>n * _</code>上，必须等后面的结果返回后，当前的函数调用栈才能返回，久而久之就会爆栈。那可以做点什么呢？如果我们在递归调用的时候不需要做任何工作（例如不去乘以n），那么就可以从当前的调用栈直接跳到下一次的调用栈上去。这称为尾递归优化。</p>
<p>我们考虑，当前调用时的n，如果以某种形式直接带到下一次的递归调用中，那么是不是就达到了目的？没错，这就是累加器技术，来尝试一下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">FactorialHelper</span>(<span class="params">acc, n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span></span><br><span class="line">        ? acc</span><br><span class="line">        : FactorialHelper(acc * n, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Factorial</span>(<span class="params"><span class="keyword">int</span> n</span>)</span> &#123; <span class="keyword">return</span> FactorialHelper(<span class="number">1</span>, n); &#125;</span><br></pre></td></tr></table></figure>
<p>C#毕竟没有F#那么方便的内嵌函数支持，所以我们声明了一个Helper函数用来达到目的，对应的F#实现如下：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> factorial n =</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> helper acc n' =</span><br><span class="line">        <span class="keyword">if</span> n' &lt;= <span class="number">1</span> <span class="keyword">then</span> acc</span><br><span class="line">        <span class="keyword">else</span> helper (acc * n') (n' - <span class="number">1</span>)</span><br><span class="line">    helper <span class="number">1</span> n</span><br></pre></td></tr></table></figure>
<p>下面的示意表达了我们想达到的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">init        f(1, n)             // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">n           f(n, n-1)           // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">n-1         f(n*(n-1), n-2)     // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">...         ...                 // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">3           f((k-2), 2)         // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">2           f((k-1), 1)         // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">1           k                   // return result</span><br></pre></td></tr></table></figure>
<p>可以看到，调用展开成尾递归的形式，从而避免了栈溢出。尾递归是一项基本的递归优化技术，其中关键的就是对累加器的使用。几乎所有的递归函数都可以优化成尾递归的形式，所以掌握这项技能对编写FP程序是有重要的意义的。</p>
<p>假如我们遇到的是一个非常庞大的列表需要处理，例如找到最大数或者列表求和，那么尾递归技术也将会让我们避免在深度的遍历时发生栈溢出的情形。</p>
<p>在前面我们说过<code>fold</code>是一种自带累加器的化简函数，那么列表求和以及最大数查找是不是可以直接用<code>fold</code>来实现呢？我们来尝试一下。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> sum l = l |&gt; List.fold (+) <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> times l = l |&gt; List.fold <span class="comment">(*) 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">let max l = </span></span><br><span class="line"><span class="comment">    let compare s e = if s &gt; e then s else e</span></span><br><span class="line"><span class="comment">    l |&gt; List.fold compare 0</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>fold</code>抽取了遍历并化简的核心步骤，仅将需要自定义的部分以参数的形式开放出来。这也是高阶函数组合的威力。</p>
<blockquote>
<p>还有一个和<code>fold</code>很类型的术语叫<code>reduce</code>，它和<code>fold</code>的唯一区别在于，<code>fold</code>的累加器需要一个初始值需要指定，而<code>reduce</code>的初始累加器使用列表的第一个元素的值。</p>
</blockquote>
<h2 id="记忆化"><a href="#记忆化" class="headerlink" title="记忆化"></a>记忆化</h2><p>我们知道大多数的FP函数是没有副作用的，这意味着以相同的参数调用同一函数将会返回相同的结果，那么如果有一个函数会被调用很多次，为什么不把对应参数的求值结果缓存起来，当参数匹配时直接返回缓存结果呢？这个过程就是记忆化，也是FP编程中常用的技巧。</p>
<p>我们以一个简单的加法函数为例：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add (a, b) = a + b</span><br></pre></td></tr></table></figure>
<p>注意这里我们使用了非currying化的参数，它是一个元组。接下来我们尝试使用记忆化来缓存结果：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> memoizedAdd = </span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> Dictionary&lt;_, _&gt;()</span><br><span class="line">    <span class="keyword">fun</span> p -&gt;</span><br><span class="line">        <span class="keyword">match</span> cache.TryGetValue(p) <span class="keyword">with</span></span><br><span class="line">        | <span class="keyword">true</span>, result -&gt; result</span><br><span class="line">        | _ -&gt;</span><br><span class="line">            <span class="keyword">let</span> result = add p</span><br><span class="line">            cache.Add(p, result)</span><br><span class="line">            result</span><br></pre></td></tr></table></figure>
<p>借助一个字典，将已经求值的结果缓存起来，下次以同样的参数调用时就可以直接从字典中检索出值，避免了重新计算。</p>
<p>我们甚至可以设计一个通用的记忆化函数，用于将任意函数记忆化：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> memorize f =</span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> Dictionary&lt;_, _&gt;()</span><br><span class="line">    <span class="keyword">fun</span> p -&gt;</span><br><span class="line">        <span class="keyword">match</span> cache.TryGetValue(p) <span class="keyword">with</span></span><br><span class="line">        | <span class="keyword">true</span>, result -&gt; result</span><br><span class="line">        | _ -&gt;</span><br><span class="line">            <span class="keyword">let</span> result = f p</span><br><span class="line">            cache.Add(p, result)</span><br><span class="line">            result</span><br></pre></td></tr></table></figure>
<p>那么前面的<code>memorizedAdd</code>函数可以写为<code>let memorizedAdd = memorize add</code>。这也是一个高阶函数应用的好例子。</p>
<h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><p>Haskell是一种纯函数语言，它不允许存在任何的副作用，并且在Haskell中，当表达式不必立即求值时是不会主动求值的，换句话说，是延迟计算的。而在大多数主流语言中，计算策略却是即时计算的（eager evaluation），这在某种极端情况下会不经意的浪费计算资源。有没有什么方法能够模拟类似Haskell中的延迟计算？</p>
<p>假如我们需要将表达式<code>n % 2 == 0 ? &quot;right&quot; : &quot;wrong&quot;</code>绑定到标识（即变量名）<code>isEven</code>上，例如<code>var isEven = n % 2 == 0 ? &quot;right&quot; : &quot;wrong&quot;;</code>，那么整个表达式是立即求值的，但是<code>isEven</code>可能在某种状况下不会被使用，有没有什么办法能在我们确定需要<code>isEven</code>时再计算表达式的值呢？</p>
<p>假如我们将<code>isEven</code>绑定到某种结构上，这个结构知道如何求值，并且是按需求值的，那么我们的目的就达到了。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">var</span> isEven = <span class="keyword">new</span> Lazy&lt;<span class="keyword">string</span>&gt; (() =&gt; n % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">"right"</span> : <span class="string">"wrong"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> isEven = <span class="keyword">lazy</span> (<span class="keyword">if</span> n % <span class="number">2</span> = <span class="number">0</span> <span class="keyword">then</span> <span class="string">"right"</span> <span class="keyword">else</span> <span class="string">"wrong"</span>)</span><br></pre></td></tr></table></figure>
<p>当使用<code>isEven</code>时，C#可以直接使用<code>isEven.Value</code>来即时求值并返回结果，而F#的使用方式也是一样的<code>isEven.Value</code>。</p>
<p>还有一种更加通用的方式来实现惰性求值，就是通过函数，函数表达了某种可以得到值的方式，但是需要调用才能得到，这和惰性求值的思想不谋而合。我们可以改写上面的例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">var</span> isEven = (Func&lt;<span class="keyword">string</span>&gt;)(() =&gt; n % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">"right"</span> : <span class="string">"wrong"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> isEven = <span class="keyword">fun</span> () -&gt; <span class="keyword">if</span> n % <span class="number">2</span> = <span class="number">0</span> <span class="keyword">then</span> <span class="string">"right"</span> <span class="keyword">else</span> <span class="string">"wrong"</span></span><br></pre></td></tr></table></figure>
<p>这样，在需要使用<code>isEven</code>的值时就是一个简单的函数调用，C#和F#都是<code>isEven()</code>。</p>
<h2 id="延续"><a href="#延续" class="headerlink" title="延续"></a>延续</h2><p>如果你之前使用过jQuery，那么在某种程度上已经接触过延续的概念了。<br>通过jQuery发起ajax调用其实就是一种延续：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('http://test.com/data.json', function(data) &#123;</span><br><span class="line">    <span class="comment">// processing.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>ajax调用成功后会调用匿名回调函数，而此函数表达了我们希望ajax调用成功后继续执行的行为，这就是延续。</p>
<p>现在，我们回顾一下，在概述-表达式求值一节，我们为了将两个C#赋值语句改写成表达式的方式，新增了一个<code>Eval</code>函数：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Eval</span>(<span class="params"><span class="keyword">int</span> binding, Action&lt;<span class="keyword">int</span>&gt; continues</span>)</span> &#123;</span><br><span class="line">    contineues(binding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它也是一种延续，指定了在<code>binding</code>求值后继续执行延续的行为，我们将它稍做修改：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">public</span> TOutput binding&lt;TEvalValue, TOutput&gt;(</span><br><span class="line">    TEvalValue evaluation, </span><br><span class="line">    Func&lt;TEvalValue, TOutput&gt; continues) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> continues(evaluation());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> binding v cont = cont v</span><br><span class="line"><span class="comment">// binding: 'a -&gt; cont:('a -&gt; 'b) -&gt; 'b</span></span><br></pre></td></tr></table></figure>
<p>于是我们可以模拟<code>let</code>的工作方式：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line">binding <span class="number">11</span> (<span class="keyword">fun</span> a -&gt; printfn <span class="string">"%d"</span> a)</span><br></pre></td></tr></table></figure>
<p>那么延续这种技术在实践中有什么用途呢？你可以说它就是个回调函数，这没有问题。深层次的理解在于，它延后了某种<strong>行为</strong>且该行为对上下文有依赖。</p>
<p>我们考虑这样一个场景，假设我们有一颗树需要遍历并求和，例如：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">NumberTree</span> </span>=</span><br><span class="line">    | Leaf <span class="keyword">of</span> int</span><br><span class="line">    | Node <span class="keyword">of</span> NumberTree * NumberTree</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> sumTree tree =</span><br><span class="line">    <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">    | Leaf(n)           -&gt; n</span><br><span class="line">    | Node(left, right) -&gt; sumTree(left) + sumTree(right)</span><br></pre></td></tr></table></figure>
<p>那么问题来了，我们显然可以发现当树的层级太深时<code>sumTree</code>函数会发生栈溢出，我们也自然而然的想到了使用尾递归来优化，但是当我们在尝试做优化时会发现，然并卵。这就是一个无法使用尾递归的场景。</p>
<p>核心的诉求在于，我们希望进行尾递归调用（<code>sumTree(left)</code>），但在尾递归调用完成之后，还有需要执行的代码（<code>sumTree(right)</code>）。延续为我们提供了一种手段，在函数调用结束后自动调用指定的行为（函数），于是当前正在编写的函数便仅包含一次递归调用了。我们仍然可以将它看作是一种累加器技术，区别在于，之前是累加值，而延续是累加行为。</p>
<p>我们尝试为<code>sumTree</code>递归函数加上延续功能：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> sumTree tree continues =</span><br><span class="line">    <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">    | Leaf(n) -&gt; continues n</span><br><span class="line">    | Node(left, right) -&gt;</span><br><span class="line">        sumTree left (<span class="keyword">fun</span> leftSum -&gt; </span><br><span class="line">            sumTree right (<span class="keyword">fun</span> rightSum -&gt; </span><br><span class="line">                continues(leftSum + rightSum)))</span><br></pre></td></tr></table></figure>
<p>此时，<code>sumTree</code>的签名从<code>NumberTree -&gt; int</code>变成了<code>NumberTree -&gt; (int -&gt; &#39;a) -&gt; &#39;a</code>。<code>Node(left, right)</code>分支现在变成了单个函数的调用，所以它是尾递归优化的，每次计算时都会将结束后需要继续执行的行为以函数的方式指定，直到整个递归完成。</p>
<p>使用时，可以以延续的方式来调用<code>sumTree</code>函数，也可以像往常一样从返回值获取结果：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="comment">// continues way:</span></span><br><span class="line">sumTree sampleTree (<span class="keyword">fun</span> result -&gt; printfn <span class="string">"result: %d"</span> result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// normal way:</span></span><br><span class="line"><span class="keyword">let</span> result = sumTree sampleTree (<span class="keyword">fun</span> r -&gt; r)</span><br></pre></td></tr></table></figure>
<p>我们甚至可以从延续的思想逐渐推导出类似<code>bind</code>的函数，我们将它与<code>map</code>的签名对比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bind</span><br><span class="line">(&apos;a -&gt; M&lt;&apos;b&gt;) -&gt; M&lt;&apos;a&gt; -&gt; M&lt;&apos;b&gt;</span><br><span class="line">// map</span><br><span class="line">(&apos;a -&gt; &apos;b)    -&gt; M&lt;&apos;a&gt; -&gt; M&lt;&apos;b&gt;</span><br></pre></td></tr></table></figure>
<p>在高阶函数一节我们说过，<code>map</code>叫普通投影，而新的<code>bind</code>叫做平展投影，它是一种外层匹配模式，在C#中对应的操作是<code>SelectMany</code>，在F#中就是<code>bind</code>，是一种通用函数。</p>
<p>在前面我们定义了一个<code>binding</code>函数，我们稍微调整一下参数顺序，并把它和<code>bind</code>对比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// binding:</span><br><span class="line">(&apos;a -&gt; &apos;b)    -&gt; &apos;a -&gt; &apos;b</span><br><span class="line">// map:</span><br><span class="line">(&apos;a -&gt; &apos;b)    -&gt; M&lt;&apos;a&gt; -&gt; M&lt;&apos;b&gt;</span><br><span class="line">// bind:</span><br><span class="line">(&apos;a -&gt; M&lt;&apos;b&gt;) -&gt; M&lt;&apos;a&gt; -&gt; M&lt;&apos;b&gt;</span><br></pre></td></tr></table></figure>
<p>也就是说，如果我们为<code>&#39;a</code>加上某种包装，然后在bind里再做一些转换，那么我们就可以推导出<code>bind</code>函数。</p>
<p>C#的LINQ里<code>SelectMany</code>对应的就是<code>from</code>语句，比如下面：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> a <span class="keyword">in</span> l1</span><br><span class="line">             <span class="keyword">from</span> b <span class="keyword">in</span> l2</span><br><span class="line">             <span class="keyword">from</span> c <span class="keyword">in</span> l3</span><br><span class="line">             <span class="keyword">select</span> &#123; a, b &#125;</span><br></pre></td></tr></table></figure>
<p>这将转换成一系统嵌套的<code>SelectMany</code>调用，而<code>select</code>将转换为某种类似于<code>Return&lt;T&gt;()</code>的操作。对于F#来说，类似的代码可以用计算表达式（或者更加具体的序列表达式）：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = seq &#123;</span><br><span class="line">    <span class="keyword">let!</span> a = l1</span><br><span class="line">    <span class="keyword">let!</span> b = l2</span><br><span class="line">    <span class="keyword">let!</span> c = l3</span><br><span class="line">    <span class="keyword">return</span> (a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，似乎差不多该结束了，我们不打算继续深究<code>bind</code>，因为再往下走就到了<code>monad</code>了。事实上，大家已经看到了<code>monad</code>，F#的序列表达式以及C#中LINQ的一部分操作，就是<code>monad</code>。</p>
<hr>
<p>希望本文讲述的一些浅显的函数式编程概念可以在实践中对你有所帮助。最重要的是通过对思维的训练，可以从更加抽象的角度思考问题，提取问题最核心的部分以复用，将可变部分提出，从而使问题可组合，并且获得更好的表达性。</p>
<p>有关<code>monad</code>，推荐大家看看<a href="https://en.wikipedia.org/wiki/Erik_Meijer_%28computer_scientist%29" target="_blank" rel="noopener">Erik Meijer</a>大大在Channel9上的课程<a href="https://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals" target="_blank" rel="noopener">Functional Programming Fundamentals</a>，它同时也是<a href="https://github.com/Reactive-Extensions" target="_blank" rel="noopener">Rx</a>库的作者之一，以及LINQ的作者。</p>
<p>（完）</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/productivity/">productivity</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C#</a><a href="/tags/F/">F#</a><a href="/tags/Functional-Programming/">Functional-Programming</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/24/functional-programming-skills/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/10/14/improve-work-efficiency-and-happiness-2/" title="提高工作效率与幸福度-工具篇" itemprop="url">提高工作效率与幸福度-工具篇</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2015-10-14T05:35:42.000Z" itemprop="datePublished"> Published 2015-10-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这篇文章略难产，事实上距离”基本篇”的发布已然过去了小半年了，生孩子生到这份儿上也真是够够的了。那时天还是辣么蓝，微风徐徐鸟语花香，我独自抚摸着猫在键盘上激情的写作……后来，把下篇给忘了。据说刨坑不填的都得拉去烧死，我想了想觉得挺疼的，所以抓紧补上吧。</p>
<p>先回顾一下基本篇阐述的基本事实：</p>
<ul>
<li>邮件 is bitch</li>
<li>电话有时让对方不爽</li>
<li>信息的组织与提取不是容易的事情</li>
</ul>
<p>对于这几个bitch上篇给出了简单的建议，不妨作为一种过渡手段，但是身为现代人类，有辣么多好用而且几乎都是免费的工具可以使用，why not?</p>
<blockquote>
<p>不过说到底，再牛逼的工具也不能解决人懒惰的问题，工具只能让你更好的做事，不能帮你做事，躺着就把钱赚了的事不多，要想清楚。</p>
</blockquote>
        
        
        <p class="article-more-link">
          
            <a href="/2015/10/14/improve-work-efficiency-and-happiness-2/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/productivity/">productivity</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/10/14/improve-work-efficiency-and-happiness-2/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/04/28/improve-work-efficiency-and-happiness-1/" title="提高工作效率与幸福度-基本篇" itemprop="url">提高工作效率与幸福度-基本篇</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2015-04-28T11:12:46.000Z" itemprop="datePublished"> Published 2015-04-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>现代企业有着复杂的协作，人与人间的信息交流、资源间的协调分配，各种碎片信息的整理，这还不包含人际关系处理等等狗血剧情，每天的工作被打散成七零八落，看似忙成狗，其实就是狗一般的活着，仰望天空，噢shit一天又特么过去了，好多事儿还没做完……</p>
<p>有没有办法通过改善自身来提高生产力？不妨看看这些行之有效的建议能否帮到你。要知道，这些建议来自于脑力协作最为密集的软件开发行业，对其实生产制造或者创造性工作也有着不错的借鉴意义。毕竟，自身的生产力提高了，才能从容的面对复杂的工作，从而让自己的竞争力更上一层台阶。</p>
<p>本文共分两部分：</p>
<ul>
<li>《提高工作效率与幸福度-基本篇》，讲述老百姓自己的故事</li>
<li>《提高工作效率与幸福度-工具篇》，讲述新人类的工作方式
        
        
        <p class="article-more-link">
          
            <a href="/2015/04/28/improve-work-efficiency-and-happiness-1/#more">Read More</a>
          
       </p>
    </li></ul></div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/productivity/">productivity</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/04/28/improve-work-efficiency-and-happiness-1/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/12/03/async-programming/" title="使用异步编程" itemprop="url">使用异步编程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2014-12-03T03:50:18.000Z" itemprop="datePublished"> Published 2014-12-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>现代的应用程序面临着诸多的挑战，如何构建具有可伸缩性和高性能的应用成为越来越多软件开发者思考的问题。随着应用规模的不断增大，业务复杂性的增长以及实时处理需求的增加，开发者不断尝试榨取硬件资源、优化。</p>
<p>在不断的探索中，出现了很多简化场景的工具，比如提供可伸缩计算资源的<a href="http://aws.amazon.com/cn/s3/" target="_blank" rel="noopener">Amazon S3</a>、<a href="http://azure.microsoft.com/" target="_blank" rel="noopener">Windows Azure</a>，针对大数据的数据挖掘工具<a href="http://research.google.com/archive/mapreduce.html" target="_blank" rel="noopener">MapReduce</a>，各种CDN服务，云存储服务等等。还有很多的工程实践例如<a href="http://agilemanifesto.org/" target="_blank" rel="noopener">敏捷</a>、<a href="http://www.domaindrivendesign.org/" target="_blank" rel="noopener">DDD</a>等提供了指导。可以看到，将每个关注层面以服务的方式提供，成为了越来越流行的一种模式，或许我们可以激进的认为，这就是<a href="http://en.wikipedia.org/wiki/Service-oriented_architecture/" target="_blank" rel="noopener">SOA</a>。</p>
<p>开发者需要将不同的资源粘合在一起来提供最终的应用，这就需要协调不同的资源。</p>
<p>我们可以设想一个大的场景，开发者正在开发的一个用例会从用户的浏览器接收到请求，该请求会先从一个开放主机服务(OHS)获取必要的资源res1，然后调用本机的服务s1对资源res1进行适应的转换产生资源res2，接着以res2为参数调用远程的数据仓库服务rs1获取业务数据bs1，最后以bs1为参数调用本机的计算服务calc并经过10s产生最终的数据。</p>
<p>简单的用ASP.NET MVC 5表示就是这样的（这些代码是我瞎掰的）：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// notes: ASP.NET vNext changed MVC 5 usage, </span></span><br><span class="line"><span class="comment">// ActionResult now became IActionResult</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">CrazyCase</span>(<span class="params">UserData userData</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ticket = CrazyApplication.Ticket;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> ohsFactory = <span class="keyword">new</span> OpenHostServiceFactory(ticket);</span><br><span class="line">    <span class="keyword">var</span> ohs = ohsFactory.CreateService();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> ohsAdapter = <span class="keyword">new</span> OhsAdapter(userData);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> rs1 = ohs.RetrieveResource(ohsAdapter);</span><br><span class="line">    <span class="keyword">var</span> rs2 = _localConvertingService.Unitize(rs1);</span><br><span class="line">    <span class="keyword">var</span> bs1 = _remoteRepository.LoadBusinessData(rs2);</span><br><span class="line">    <span class="keyword">var</span> result = _calculationService.DoCalculation(bs1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> View(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可能是中等复杂度的一个场景，但是相信开发者已经意识到了这其中所涉及的复杂度。我们看到每一步都是依赖于前者所产生的数据，在这样一种场景之下，传统的多线程技术将极度受限，并且最顶层的协调服务将始终占用一个线程来协调每一步。</p>
<p>线程是要增加开销的，尤其是上下文的转换，别扯什么线程池了，创建线程的开销是节省了，上下文切换的开销才是要命的。</p>
<blockquote>
<p>经济不景气，能省点儿资源就省点儿吧。</p>
</blockquote>
<hr>
<p>所以我们该怎么办？纵向扩展给服务器加多点内存？横向扩展上负载均衡？别闹了我们又不是民工，想问题不要太简单粗暴。解决的办法就是，异步，而且我们这篇也只讨论异步这一种技术。</p>
<h2 id="为什么使用异步"><a href="#为什么使用异步" class="headerlink" title="为什么使用异步"></a>为什么使用异步</h2><p>那么，异步的优势在哪里？这首先要和同步做一个对比。</p>
<p>还是开头那个场景，示例代码所展示的是使用同步阻塞的方式来一步一步的执行，如下示意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main) +++$----$------$--------$----------$+++</span><br><span class="line">         |   /|     /|       /|         /</span><br><span class="line">ohs )    $++$ |    / |      / |        /</span><br><span class="line">              |   /  |     /  |       /</span><br><span class="line">rs1 )         $++$   |    /   |      /</span><br><span class="line">                     |   /    |     /</span><br><span class="line">s1  )                $++$     |    /</span><br><span class="line">                              |   /</span><br><span class="line">calc)                         $++$</span><br><span class="line"></span><br><span class="line">notes:</span><br><span class="line">$ code point</span><br><span class="line">+ thread busy</span><br><span class="line">- thread blocked(means, wasted)</span><br></pre></td></tr></table></figure>
<p>可以明显的看到，当主线程发起各个service请求后，完全处于闲置占用的状态，所做的无非是协调任务间的依赖顺序。这里所说的占用，其实就是CPU的时间片。</p>
<p>我们为什么要等所有的子任务结束？因为任务间有先后顺序依赖。有没有更好的方式来规避等待所带来的损耗呢？考虑一个场景，正上着班呢，突然想起要在网上买个东西，那么打开京东你就顺利的下单了，事情并没有结束，你不会等快递的小哥给你送来东西以后再接着今天的工作吧？你会给快递留下你的联系方式，让他<strong>到了给你打电话</strong>(耗时的I/O任务)，然后你继续今天烧脑的编程任务(CPU密集型)。从人类的角度来看，这一定是最正常不过的，也就是要讨论的异步的方式。</p>
<blockquote>
<p>一定有人会提议单开一个线程做收快递的任务，我同意这是一种解决方案，但是如果用等效的人类角度的语言来说，就是你将大脑的资源分成了两半，一半在烧脑编程，一半在盯着手机发呆，脑利用率下降太明显。而用异步的方式，你不需要关注手机，因为手机响了你就自然得到了通知。<br>当然，你也可以任性的说，我就喜欢等快递来了再干活。if so，我们就不要做朋友了。</p>
</blockquote>
<p>所以我们可以有一个推论：异步所解决的，就是节省低速的IO所阻塞的CPU计算时间。</p>
<p>转换一下思路，我们使用异步非阻塞的方式来构建这段业务，并借助异步思想早已深入人心的<code>javascript</code>语言来解释，可以是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ohs = <span class="built_in">require</span>(<span class="string">'./anticorruption/OpenHostService'</span>);</span><br><span class="line"><span class="keyword">var</span> localConvertingService = <span class="built_in">require</span>(<span class="string">'./services/LocalConverting'</span>);</span><br><span class="line"><span class="keyword">var</span> remoteRepository = <span class="built_in">require</span>(<span class="string">'./repositories/BusinessData'</span>);</span><br><span class="line"><span class="keyword">var</span> calculationService = <span class="built_in">require</span>(<span class="string">'./services/Calculation'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userData = req.body;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// level1 nest</span></span><br><span class="line">    ohs.retrieveResource(userData, <span class="function"><span class="keyword">function</span>(<span class="params">err, rs1</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// level2 nest</span></span><br><span class="line">        localConvertingService.unitize(rs1, <span class="function"><span class="keyword">function</span>(<span class="params">err, rs2</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                <span class="comment">// error handling</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//level3 nest</span></span><br><span class="line">            remoteRepository.loadBusinessData(rs2, <span class="function"><span class="keyword">function</span>(<span class="params">err, bs1</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                    <span class="comment">// error handling</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//level4 nest</span></span><br><span class="line">                calculationService.doCalculation(bs1, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                        <span class="comment">// error handling</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    res.view(result);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看着一层又一层的花括号也是醉了，我们之后会讨论如何解嵌套。那么这段代码所反应的是怎样的事实呢？如下示意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main) +++$                           $+++</span><br><span class="line">          \                         /</span><br><span class="line">ohs )      $++$                    /</span><br><span class="line">               \                  /</span><br><span class="line">rs1 )           $++$             /</span><br><span class="line">                    \           /</span><br><span class="line">s1  )                $++$      /</span><br><span class="line">                         \    /</span><br><span class="line">calc)                     $++$</span><br><span class="line"></span><br><span class="line">notes:</span><br><span class="line">$ code point</span><br><span class="line">+ thread busy</span><br><span class="line">- thread blocked(means, wasted)</span><br></pre></td></tr></table></figure>
<p>由于异步解放了原始的工作线程，使CPU资源可以不被线程的阻塞而被浪费，从而可以有效的提高吞吐率。</p>
<h2 id="异步的使用场景"><a href="#异步的使用场景" class="headerlink" title="异步的使用场景"></a>异步的使用场景</h2><blockquote>
<p>技术和选择和使用场景有着很大的关系，每项技术不都是银弹，使用对的工具/技术解决对的问题是开发者的义务。</p>
</blockquote>
<p>开发者最多关注的是计算密集和I/O密集这两个维度，对于这两个维度往往有着不同的技术选型。</p>
<h3 id="计算密集型应用"><a href="#计算密集型应用" class="headerlink" title="计算密集型应用"></a>计算密集型应用</h3><p>何为计算密集型应用？下面两个人畜皆知的函数都是计算密集型的。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F#</span></span><br><span class="line"><span class="keyword">let</span> fibonacci n =</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> f a b n =</span><br><span class="line">        <span class="keyword">match</span> n <span class="keyword">with</span></span><br><span class="line">        | <span class="number">0</span> -&gt; a</span><br><span class="line">        | <span class="number">1</span> -&gt; b</span><br><span class="line">        | n -&gt; (f b (a + b) (n - <span class="number">1</span>))</span><br><span class="line">    f <span class="number">0</span> <span class="number">1</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> factorial n = </span><br><span class="line">    <span class="keyword">match</span> n <span class="keyword">with</span></span><br><span class="line">    | <span class="number">0</span> -&gt; <span class="number">1</span></span><br><span class="line">    | n -&gt; n * factorial (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>尤其是第二个阶乘函数，如果在调用的时候不小心手抖多加了几个0，基本上可以出去喝个咖啡谈谈理想聊聊人生玩一天再回来看看有没有算完了。</p>
<p>简而言之，计算密集型的任务是典型的重度依赖CPU/GPU，不涉及磁盘、网络、输入输出的任务。游戏中场景渲染是计算密集的，MapReduce中的<code>Reduce</code>部分是计算密集的，视频处理软件的实时渲染是计算密集的，等等。</p>
<p>在这样的场景之下，异步是没有太大的优势的，因为计算资源就那么多，不增不减，用多线程也好用异步流也好，CPU永远处于高负荷状态，这病不能治，解决方案只能是：</p>
<ul>
<li>横向的集群方案</li>
<li>纵向的升级主机CPU或采用更快的GPU</li>
<li>优化算法，使之空间/时间成本降低</li>
</ul>
<p>但是有一种场景是可以考虑使用异步的，考虑一个分布式的计算场，一个计算任务发起后，协调者需要等待所有的计算节点子结果集返回后者能做最后的结果化简。那么此时，虽然场景是计算密集的，但是由于涉及到任务的依赖协调，采用异步的方式，可以避免等待节点返回结果时的阻塞，也可以避免多线程方式的上下文切换开销，要知道在这样的场景下，上下文切换的开销是可以大的惊人的。</p>
<p>相似的场景还有，一个桌面应用，假设点击界面上一个按钮之后会进行大量的计算，如果采用同步阻塞的方式，那么当计算完成之前UI是完全阻塞的跟假死一样，但是如何使用异步的方式，则不会发生UI阻塞，计算在结束后会以异步的方式来更新界面。还记得WinForm编程中的<code>BeginInvoke</code>和<code>EndInvoke</code>吗？虽然它们的实现方式是以单独线程的方式来实现异步操作的，但是这仍然属于异步流控制的范畴。</p>
<blockquote>
<p>异步的实现方式有很多，可以使用已有的线程技术(Rx和C#的async/await就是使用这种方式)，也可以使用类似于libuv之类的I/O异步封装配合事件驱动(node就是使用这种方式)。并于异步流控制的部分我们之后会讨论。</p>
</blockquote>
<p>所以如果你的应用是计算密集型的，在充分分析场景的前提下可以适当的采用异步的方式。大部分的计算密集型场景是不用介入异步控制技术的，除非它可以显著改善应用的流程控制能力。</p>
<h3 id="I-O密集型应用"><a href="#I-O密集型应用" class="headerlink" title="I/O密集型应用"></a>I/O密集型应用</h3><p>何为I/O密集型应用？Web服务器天然就是I/O密集型的，因为有着高并发量与网络吞吐。文件服务器和CDN是I/O密集型的，因为高网络吞吐高磁盘访问量。数据库是I/O密集型的，涉及磁盘的访问及网络访问。说到底，一切和输入输出相关的场景都是I/O密集型的。</p>
<p>I/O囊括的方面主要是两方面：</p>
<ul>
<li>网络访问</li>
<li>磁盘读写</li>
</ul>
<p>简单粗暴的解释，就是接在主板南桥上的设备的访问都属于I/O。多提一句，内存是直接接在北桥上的，这货，快。</p>
<p>开发者遇到最多的场景便是Web应用和数据库的高并发访问。其它的服务调用都属于网络I/O，可归为一类。</p>
<p>典型的就是Web服务器接收到了HTTP请求，然后具体的Web框架会单开一个线程服务这个请求。因为HTTP是构建在TCP之上的，所以在请求结束返回结果之前，socket并没有关闭，在windows系统上这就是一个句柄，在*nix之类的posix系统上这就是一个文件描述符，都是系统资源紧张的很。这是硬性的限制，能打开多少取决与内存与操作系统，我们暂且不关注这部分。该线程如果采用同步的方式，那么它程的生命周期会吻合socket的生命周期，期间不管是访问文件系统花了10s导致cpu空闲10s的时间片，还是访问数据库有3s的时间片空隙，这个线程都不会释放，就是说，这个线程是专属的，即便是使用线程池技术，该占还得占。</p>
<p>这有点像是银行的VIP专线，服务人员就那么多，如果每人服务一个VIP且甭管人家在聊人生聊理想还是默默注视，后面人就算是VIP也得等着，因为没人可以服务你了。</p>
<p>那么我们继续深入，线程也是一种相对昂贵的资源，虽然比创建进程快了太多，但是仍然有限制。windows的32位操作系统默认每进程可使用2GB用户态内存（64bit是8Tb用户态内存, LoL），每个线程有1Mb的栈空间（能改，但不建议。）；*nix下是8Mb栈空间，32位的进程空间是4Gb，64位则大到几近没有用户态内存限制。我们可以假定32位系统下一个合理的单进程线程数量：1500。那么一个进程最大的并发量就是1500请求了，抛开多核不谈，这1500个线程就算轮班倒，并发量不会再上去了，因为一个socket一个线程。如果每个请求都是web服务器处理1s加访问数据库服务器3s，那么时钟浪费率则大的惊人。况且，1500个线程的上下文切换想想都是<a href="http://www.zhihu.com/question/23544144" target="_blank" rel="noopener">开心，开了又开</a>。</p>
<p>不幸的是，之前的web服务器都是这么干的。此时我们思考，如果采用异步的方式，那3s的阻塞完全可以规避，从而使线程轮转的更快，因为1s的处理时间结束后线程返回线程池然后服务于另一个请求，从而整体提高服务器的吞率。</p>
<blockquote>
<p>事实上，node压根就没有多线程的概念，使用事件循环配合异步I/O，一个线程总够你甩传统的Web服务器吞吐量几条街。没错，请叫我node雷锋。</p>
</blockquote>
<p>再继续深入异步编程前，我们先理一理几个经常混淆的概念。</p>
<h2 id="一些概念的区别"><a href="#一些概念的区别" class="headerlink" title="一些概念的区别"></a>一些概念的区别</h2><h3 id="多核与多线程"><a href="#多核与多线程" class="headerlink" title="多核与多线程"></a>多核与多线程</h3><p>多核是一种物理上的概念，即指主机所拥有的物理CPU核心数量，<code>总核心数 = CPU个数 * 每个CPU的核心数</code>。每个核心是独立的，可以同时服务于不同的进程/线程。</p>
<p>多线程是一种操作系统上的概念，单个进程可能创建多个线程来达到细粒度进行流程控制的目的。操作系统的核心态调度进程与线程，在用户态之下其实还可以对单个线程有更细粒度的控制，这称之为<code>协程（coroutine）</code>或<code>纤程（fibers）</code>。</p>
<p>多线程是指在单个进程空间内通过操作系统的调度来达到多流程同时执行的一种机制，当然，单个CPU核心在单位时间内永远都只是执行一个线程的指令，所以需要以小的时间片段雨露均沾的执行每个线程的部分指令。在切换线程时是有上下文的切换的，包括寄存器的保存/还原，线程堆栈的保存/还原，这就是开销。</p>
<h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p>关于并行，真相只有一个，单个CPU核心在单位时间内只能执行一个线程的指令，所以如果总核心数为20，那么我们可以认为该主机的并行能力为20，但是用户态的并行能力是要比这个低的，因为操作系统服务和其它软件也是要用cpu的，因此这个数值是达不到的。</p>
<p>一个题外话，如果并行能力为20，那么我们可以粗略的认为，该主机一次可以同时执行20个线程，如果程序的线程使用率健康的话，保持线程池为20左右的大小可以做到完全的线程并行执行没有上下文切换。</p>
<p>那么并发则关注于应用的处理能力。这是一个更加侧重网络请求/服务响应能力的概念，可以理解为单位时间内可以同时接纳并处理用户请求的能力。它和多少CPU没有必然的关系，单纯的考量了服务器的响应回复能力。</p>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞/非阻塞与同步/异步是经常被混淆的。同步/异步其实在说事件的执行顺序，阻塞/非阻塞是指做一件事能不能立即返回。</p>
<p>我们举个去KFC点餐的例子。点完餐交完钱了，会有这么几种情况：</p>
<ul>
<li>服务人员直接把东西给我，因为之前已经做好了，所以能马上给我，这叫做非阻塞，我不需要等，结果立即返回。这整个过程是同步完成的。</li>
<li>服务人员一看没有现成的东西了，跑去现做，那么我就在这儿一直等，没刷微信没做别的干等，等到做出来拿走，这叫阻塞，因为我傻到等结果返回再离开点餐台。这整个过程是同步完成的。</li>
<li>服务人员一看没有现成的东西了，跑去现做，并告诉我说：先去做别的，做好了我叫你的号。于是我开心的找了个座位刷微信，等叫到了我的号了取回来。这叫做非阻塞，整个过程是异步的，因为我还刷了微信思考了人生。</li>
</ul>
<p>异步是非阻塞的，但是同步可以是阻塞的也可以是非阻塞的，取决于消费的资源。</p>
<h2 id="异步编程的挑战"><a href="#异步编程的挑战" class="headerlink" title="异步编程的挑战"></a>异步编程的挑战</h2><p>异步编程的主要困难在于，构建程序的执行逻辑时是非线性的，这需要将任务流分解成很多小的步骤，再通过异步回调函数的形式组合起来。在异步大行其道的<code>javascript</code>界经常可以看到很多层的<code>});</code>，简单酸爽到妙不可言。这一节将讨论一些常用的处理异步的技术手段。</p>
<h3 id="回调函数地狱"><a href="#回调函数地狱" class="headerlink" title="回调函数地狱"></a>回调函数地狱</h3><p>开头的那个例子使用了4层的嵌套回调函数，如果流程更加复杂的话，还需要嵌套更多，这不是一个好的实践。而且以回调的方式组织流程，在视觉上并不是很直白，我们需要更加优雅的方式来解耦和组织异步流。</p>
<p>使用传统的<code>javascript</code>技术，可以展平回调层次，例如我们可以改写之前的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ohs = <span class="built_in">require</span>(<span class="string">'./anticorruption/OpenHostService'</span>);</span><br><span class="line"><span class="keyword">var</span> localConvertingService = <span class="built_in">require</span>(<span class="string">'./services/LocalConverting'</span>);</span><br><span class="line"><span class="keyword">var</span> remoteRepository = <span class="built_in">require</span>(<span class="string">'./repositories/BusinessData'</span>);</span><br><span class="line"><span class="keyword">var</span> calculationService = <span class="built_in">require</span>(<span class="string">'./services/Calculation'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userData = req.body;</span><br><span class="line"></span><br><span class="line">    ohs.retrieveResource(userData, ohsCb);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ohsCb</span>(<span class="params">err, rs1</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        localConvertingService.unitize(rs1, convertingCb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">convertingCb</span>(<span class="params">err, rs2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        remoteRepository.loadBusinessData(rs2, loadDataCb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">loadDataCb</span>(<span class="params">err, bs1</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        calculationService.doCalculation(bs1 , calclationCb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">calclationCb</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.view(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解嵌套的关键在于如何处理函数作用域，之后金字塔厄运迎刃而解。</p>
<p>还有一种更为优雅的<code>javascript</code>回调函数处理方式，可以参考后面的<code>Promise</code>部分。</p>
<p>而对于像<code>C#</code>之类的内建异步支持的语言，那么上述问题更加的不是问题，例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> IActionResult <span class="title">CrazyCase</span>(<span class="params">UserData userData</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ticket = CrazyApplication.Ticket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ohsFactory = <span class="keyword">new</span> OpenHostServiceFactory(ticket);</span><br><span class="line">    <span class="keyword">var</span> ohs = ohsFactory.CreateService();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ohsAdapter = <span class="keyword">new</span> OhsAdapter(userData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rs1 = <span class="keyword">await</span> ohs.RetrieveResource(ohsAdapter);</span><br><span class="line">    <span class="keyword">var</span> rs2 = <span class="keyword">await</span> _localConvertingService.Unitize(rs1);</span><br><span class="line">    <span class="keyword">var</span> bs1 = <span class="keyword">await</span> _remoteRepository.LoadBusinessData(rs2);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> _calculationService.DoCalculation(bs1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> View(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>async/await</code>这糖简直不能更甜了，其它<code>C#</code>的编译器还是生成了使用<code>TPL</code>特性的代码来做异步，说白了就是一些<code>Task&lt;T&gt;</code>在做后台的任务，当遇到<code>async/await</code>关键字后，编译器将该方法编译为状态机，所以该方法就可以在<code>await</code>的地方挂起和恢复了。整个的开发体验几乎完全是同步式的思维在做异步的事儿。后面有关于<code>TPL</code>的简单介绍。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>由于异步执行采用非阻塞的方式，所以当前的执行线程在调用后捕获不到异步执行栈，因此传统的异步处理将不再适用。举两个例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Task.Factory.StartNew(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"diablo coming."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InvalidOperationException e) &#123;</span><br><span class="line">    <span class="comment">// nothing captured.</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'diablo coming.'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// nothing captured.</span></span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这两个例子中，<code>try</code>语句块中的调用会立即返回，不会触发<code>catch</code>语句。那么如何在异步中处理异常呢？我们考虑异步执行结束后会触发回调函数，那么这便是处理异常的最佳地点。<code>node</code>的回调函数几乎总是接受一个错误作为其首个参数，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'file.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123; &#125;);</span><br></pre></td></tr></table></figure>
<p>其中的<code>err</code>是由异步任务本身产生的，这是一种自然的处理异步异常的方式。那么回到<code>C#</code>中，因为有了好用的<code>async/await</code>，我们可以使用同步式的思维来处理异常：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Factory.StartNew(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"diablo coming."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InvalidOperationException e) &#123;</span><br><span class="line">    <span class="comment">// exception handling.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器所构建的状态机可以支持异常的处理，简直是强大到无与伦比。当然，对于<code>TPL</code>的处理也有其专属的支持，类似于<code>node</code>的处理方式：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Task.Factory.StartNew(() =&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"diablo coming."</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.ContinueWith(parent =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> parentException = parent.Exception;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意这里访问到的<code>parent.Exception</code>是一个<code>AggregateException</code>类型，对应的处理方式也较传统的异常处理也稍有不同：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parentException.Handle(e =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(e <span class="keyword">is</span> InvalidOperationException) &#123;</span><br><span class="line">        <span class="comment">// exception handling.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="异步流程控制"><a href="#异步流程控制" class="headerlink" title="异步流程控制"></a>异步流程控制</h3><p>异步的技术也许明白了，但是遇到更复杂的异步场景呢？假设我们需要异步并行的将目录下的3个文件读出，全部完成后进行内容拼接，那么就需要更细粒度的流程控制。</p>
<p>我们可以借鉴<a href="https://github.com/caolan/async" target="_blank" rel="noopener">async.js</a>这款优秀的异步流程控制库所带来的便捷。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.parallel([</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            fs.readFile(<span class="string">'f1.txt'</span>, <span class="string">'utf-8'</span>, callback)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            fs.readFile(<span class="string">'f2.txt'</span>, <span class="string">'utf-8'</span>, callback)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            fs.readFile(<span class="string">'f3.txt'</span>, <span class="string">'utf-8'</span>, callback)</span><br><span class="line">    &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, fileResults</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// concat the content of each files</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果使用<code>C#</code>并配合<code>TPL</code>，那么这个场景可以这么实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">AsyncDemo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> files = <span class="keyword">new</span> []&#123;</span><br><span class="line">        <span class="string">"f1.txt"</span>,</span><br><span class="line">        <span class="string">"f2.txt"</span>,</span><br><span class="line">        <span class="string">"f3.txt"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tasks = files.Select(file =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> Task.Factory.StartNew(() =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> File.ReadAllText(file);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> Task.WhenAll(tasks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fileContents = tasks.Select(t =&gt; t.Result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// concat the content of each files</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再回到我们开头遇到到的那个场景，可以使用<code>async.js</code>的<code>waterfall</code>来简化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ohs = <span class="built_in">require</span>(<span class="string">'./anticorruption/OpenHostService'</span>);</span><br><span class="line"><span class="keyword">var</span> localConvertingService = <span class="built_in">require</span>(<span class="string">'./services/LocalConverting'</span>);</span><br><span class="line"><span class="keyword">var</span> remoteRepository = <span class="built_in">require</span>(<span class="string">'./repositories/BusinessData'</span>);</span><br><span class="line"><span class="keyword">var</span> calculationService = <span class="built_in">require</span>(<span class="string">'./services/Calculation'</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userData = req.body;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span>.waterfall([</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            ohs.retrieveResource(userData, <span class="function"><span class="keyword">function</span>(<span class="params">err, rs1</span>) </span>&#123;</span><br><span class="line">                callback(err, rs1);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">rs1, callback</span>) </span>&#123;</span><br><span class="line">            localConvertingService.unitize(rs1, <span class="function"><span class="keyword">function</span>(<span class="params">err, rs2</span>) </span>&#123;</span><br><span class="line">                callback(err, rs2);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">rs2, callback</span>) </span>&#123;</span><br><span class="line">            remoteRepository.loadBusinessData(rs2, <span class="function"><span class="keyword">function</span>(<span class="params">err, bs1</span>) </span>&#123;</span><br><span class="line">                callback(err, bs1);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">bs1, callback</span>) </span>&#123;</span><br><span class="line">            calculationService.doCalculation(bs1, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">                callback(err, result);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.view(result);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要处理前后无依赖的异步任务流可以使用<code>async.series()</code>来串行异步任务，例如先开电源再开热水器电源最后亮起红灯，并没有数据的依赖，但有先后的顺序。用法和之前的<code>parallel()</code>及<code>waterfall()</code>大同小异。另外还有优秀的轻量级方案<a href="https://github.com/creationix/step" target="_blank" rel="noopener">step</a>，以及为<code>javascript</code>提供monadic扩展的<a href="https://github.com/JeffreyZhao/wind" target="_blank" rel="noopener">wind.js</a>（特别像<code>C#</code>提供的方案），有兴趣可以深入了解。</p>
<h3 id="反人类的编程思维"><a href="#反人类的编程思维" class="headerlink" title="反人类的编程思维"></a>反人类的编程思维</h3><blockquote>
<p>异步是反人类的</p>
</blockquote>
<p>人类生活在一个充满异步事件的世界，但是开发者在构建应用时却遵循同步式思维，究其原因就是因为同步符合直觉，并且可以简化应用程序的构建。</p>
<p>究其深层原因，就是因为现实生活中我们是在演绎，并通过不同的<code>口头回调</code>来完成一系列的异步任务，我们会说你要是有空了来找我聊人生，货到了给我打电话，小红你写完文案了交给小明，小丽等所有的钱都到了通知小强……而在做开发时，我们是在列清单，我们的说法就是：我等着你有空然后开始聊人生，我等着货到了然后我就知道了，我等着小红文案写完了然后开始让她交给小明，我等着小丽确认所有的钱到了然后开始让她通知小强……</p>
<p>同步的思维可以简化编程的关注点，但是没有将流程进行现实化的切分，我们总是倾向于用同步阻塞的方式来将开发变成简单的步骤程序化，却忽视了用动态的视角以及消息/事件驱动的方式构建任务流程。</p>
<p>异步在编程看来是反人类的，但是从业务角度看却是再合理不过的了。通过当的工具及技术，使用异步并不是难以企及的，它可以使应用的资源利用更加的高效，让应用的响应性更上一个台阶。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="Promise-Deferred"><a href="#Promise-Deferred" class="headerlink" title="Promise/Deferred"></a>Promise/Deferred</h3><blockquote>
<p>在一般情况下，Promise、Deferred、Future这些词可以当做是同义词，描述的是同一件事情。</p>
</blockquote>
<p>在<code>jQuery 1.5+</code>之后出现了一种新的API调用方式，相比于旧的API，新的方式更好的解耦了关注点，并带来了更好的组合能力。</p>
<p>我们看一个传统的使用<code>ajax</code>的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/api/service1', &#123;</span><br><span class="line">    success: onSuccess,</span><br><span class="line">    failure: onFailure,</span><br><span class="line">    always:  onAlways</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用新的API后，调用的方式变成了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/api/service1')</span><br><span class="line">    .done(onSussess)</span><br><span class="line">    .fail(onFailure)</span><br><span class="line">    .always(onAlways);</span><br></pre></td></tr></table></figure>
<p><code>get</code>方法返回的是一个<code>promise</code>对象，表示这个方法会在未来某个时刻执行完毕。</p>
<p><code>Promise</code>是<a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="noopener">CommonJS</a>提出的规范，而<code>jQuery</code>的实现在其基础上有所扩展，旗舰级的实现可以参考<a href="https://github.com/kriskowal" target="_blank" rel="noopener">Kris Kowal</a>的<a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">Q.js</a>。</p>
<p>我们使用<code>jQuery</code>来构建一个<code>promise</code>对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longTimeOperation = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deferred = $.Deferred();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// taste like setTimeout()</span></span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// do operation.</span></span><br><span class="line">        deferred.resolve();</span><br><span class="line">        <span class="comment">// if need error handling, use deferred.reject();</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> deferred.promise();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.when(longTimeOperation())</span><br><span class="line">    .done(success)</span><br><span class="line">    .fail(failure);</span><br></pre></td></tr></table></figure>
<p>由于<code>jQuery</code>生成的<code>Deferred</code>可以自由的进行<code>resolve()</code>和<code>reject()</code>，所以在返回时我们使用<code>.promise()</code>生成不含这个两方法的对象，从而更好的封装逻辑。</p>
<p>那么<code>Promise</code>究竟带给我们的便利是什么？<code>Promise</code>表示在未来这个任务会成功或失败，可以使用1和0来表示，那么开发者马上就开始欢呼了，给我布尔运算我能撬动地球！于是，我们可以写出如下的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.when(uploadPromise, downloadPromise)</span><br><span class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// do animation.</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>对于开头的那个例子我们说过有着更优雅的解回调函数嵌套的方案，那就是使用<code>promise</code>，我们来尝试改写开头的那个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ohs = <span class="built_in">require</span>(<span class="string">'./anticorruption/OpenHostService'</span>);</span><br><span class="line"><span class="keyword">var</span> localConvertingService = <span class="built_in">require</span>(<span class="string">'./services/LocalConverting'</span>);</span><br><span class="line"><span class="keyword">var</span> remoteRepository = <span class="built_in">require</span>(<span class="string">'./repositories/BusinessData'</span>);</span><br><span class="line"><span class="keyword">var</span> calculationService = <span class="built_in">require</span>(<span class="string">'./services/Calculation'</span>);</span><br><span class="line"><span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userData = req.body;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">deferredCallback</span>(<span class="params">deferred</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                deferred.reject(err);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">                deferred.resolve(args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">makeDeferred</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> deferred = $.Deferred();</span><br><span class="line">        <span class="keyword">var</span> callback = deferredCallback(deferred);</span><br><span class="line">        fn(callback);</span><br><span class="line">        <span class="keyword">return</span> deferred.promise();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> retrieveResourcePromise = makeDeferred(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        ohs.retrieveResource(userData, callback);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> convertingPromise = makeDeferred(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        localConvertingService.unitize(rs1, callback);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> loadBusinessDataPromise = makeDeferred(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        remoteRepository.loadBusinessData(rs2, callback);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> calculationPromise = makeDeferred(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        calculationService.doCalculation(bs1 , callback);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pipedPromise = retrieveResourcePromise</span><br><span class="line">        .pipe(convertingPromise)</span><br><span class="line">        .pipe(loadBusinessDataPromise)</span><br><span class="line">        .pipe(calculationPromise);</span><br><span class="line"></span><br><span class="line">    pipedPromise</span><br><span class="line">        .done(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            res.view(result);</span><br><span class="line">        &#125;)</span><br><span class="line">        .fail(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用了一个高阶函数来生成可以兼容<code>deferred</code>构造的回调函数，进而使用<code>jQuery</code>的<code>pipe</code>特性(在<code>Q.js</code>里可以使用<code>then()</code>组合每个<code>promise</code>)，使解决方案优雅了很多，而这个工具函数在<code>Q.js</code>里直接提供，于是新的解决方案可以如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ohs = <span class="built_in">require</span>(<span class="string">'./anticorruption/OpenHostService'</span>);</span><br><span class="line"><span class="keyword">var</span> localConvertingService = <span class="built_in">require</span>(<span class="string">'./services/LocalConverting'</span>);</span><br><span class="line"><span class="keyword">var</span> remoteRepository = <span class="built_in">require</span>(<span class="string">'./repositories/BusinessData'</span>);</span><br><span class="line"><span class="keyword">var</span> calculationService = <span class="built_in">require</span>(<span class="string">'./services/Calculation'</span>);</span><br><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userData = req.body;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> retrieveResourceFn = Q.denodeify(ohs.retrieveResource)</span><br><span class="line">    <span class="keyword">var</span> convertingFn = Q.denodeify(localConvertingService.unitize);</span><br><span class="line">    <span class="keyword">var</span> loadBusinessDataFn = Q.denodeify(remoteRepository.loadBusinessData);</span><br><span class="line">    <span class="keyword">var</span> calculationFn = Q.denodeify(calculationService.doCalculation);</span><br><span class="line"></span><br><span class="line">    retrieveResourceFn(userData)</span><br><span class="line">        .then(convertingFn)</span><br><span class="line">        .then(loadBusinessDataFn)</span><br><span class="line">        .then(calculationFn)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            res.view(result);</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们如何看待<code>TPL</code>特性呢？我们看看<code>TPL</code>可以做什么：</p>
<ul>
<li>以<code>Task</code>为基本构造单位，执行时不阻塞调用线程</li>
<li>每个<code>Task</code>是独立的，<code>Task</code>有不同的状态，可以使用<code>Task.Status</code>获取</li>
<li><code>Task</code>可以组合，使用类似<code>.ContinueWith(Task))</code>以及<code>.WhenAll(Task[])</code>、<code>.WhenAny(Task[])</code>的方式自由组合。</li>
</ul>
<p>对比一下<code>Promise</code>：</p>
<ul>
<li>以<code>Promise</code>为基本构造单位，表示一个将来完成的任务，调用时立即返回</li>
<li>每个<code>Promise</code>是独立的，<code>Promise</code>有不同的状态，可以使用<code>.state</code>获取</li>
<li><code>Promise</code>可以组合，使用<code>.then()</code>、<code>.pipe()</code>以及<code>.when()</code>来组合执行流程</li>
</ul>
<p>可以看到，不论是<code>Promise</code>还是<code>TPL</code>，在设计上都有着惊人的相似性。我们有理由猜想在其它的的语言或平台都存在着类似的构造，因为异步说白了，就是让未来完成的事情自己触发后续的步骤。</p>
<h3 id="Pull-vs-Push"><a href="#Pull-vs-Push" class="headerlink" title="Pull vs. Push"></a>Pull vs. Push</h3><p>在<a href="http://en.wikipedia.org/wiki/Design_Patterns" target="_blank" rel="noopener">GoF32</a>中没有提到迭代器模式(Iterator)与观察者模式(Observer)的区别和联系，其实这两个模式有着千丝万缕的联系。</p>
<p>Iterator反映的是一种Pull模型，数据通过同步的方式从生产者那里拉过来，我们通过它的定义便可看到这一事实：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IEnumerator&lt;out T&gt;: IDisposable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>;</span><br><span class="line">    T Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过阻塞的方式调用<code>MoveNext()</code>，数据一个一个的拉取到本地。</p>
<p>而Observer反映的是一种Push模型，通过注册一个观察者（类似于回调函数），当生产者有数据时，主动的推送到观察者手里。观察者注册结束后，本地代码没有阻塞，推送数据的整个过程是异步执行的。我们通过它的定义来对比Iterator：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IObserver&lt;in T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnCompleted</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnError</span>(<span class="params">Exception exception</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnNext</span>(<span class="params">T <span class="keyword">value</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，其实这两个接口是完全对偶的（参见<a href="http://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)" target="_blank" rel="noopener">Erik Meijer</a>大大的论文<a href="http://csl.stanford.edu/~christos/pldi2010.fit/meijer.duality.pdf" target="_blank" rel="noopener">Subject/Observer is Dual to Iterator</a>）：</p>
<ul>
<li><code>MoveNext()</code>拉取下一个数据，<code>OnNext(T)</code>推送下一个数据</li>
<li><code>MoveNext()</code>返回值指示了有无剩余数据（完成与否），<code>OnCompleted()</code>指示了数据已完成（推送数据完成的消息）</li>
<li>Iterator是同步的，所以出现了异常直接在当前运行栈上，Observer是异步的，所以需要另一种方式来通知发生了异常（参见上文中的异步处理一节），于是有了<code>OnError(Exception)</code>。</li>
</ul>
<p>那么事情就变的有意思了，我们知道<code>Enumerable</code>的数据可以任意的方式组合，于是产生了像<code>LINQ</code>之类的库可供我们使用，但是这是一种阻塞的方式，因为Iterator本身就是一种Pull模型，这造就了同步等待的结果。</p>
<blockquote>
<p>没错你是对的，如果使用EF之类的框架来查询数据库，大部分的操作是延迟执行的，表明操作并没有发生而是像占位符一样在那里。但是别忘了，你最终需要去查询数据库的，在查询的一刹那，世界还是阻塞的，等结果吧亲。</p>
</blockquote>
<p>而Observer是异步Push的，有点像是事件驱动，有事件了触发，没事件了也不干扰订阅者的执行。</p>
<blockquote>
<p>你是不是也隐隐的觉得事件也可以和Push模式一样有统一的模型？而且不只一次？</p>
</blockquote>
<p>好，我们重复一遍：事件，非阻塞触发（并带有事件数据）。Push，非阻塞通知订阅者。</p>
<p>其实，这是同一种模式，语言中对事件（就是<code>event</code>关键字）的支持其实就是对Observer模式的支持，而<code>foreach</code>则实现了对Iterator模式的语言内建支持。所谓设计模式，就是因为语言的内建支持不够而出现的，说白了，是语言的补丁。</p>
<p>那么我们来看一看异常强大的<a href="https://github.com/Reactive-Extensions/" target="_blank" rel="noopener">Rx</a>如何改变事件。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unitized event</span></span><br><span class="line"><span class="keyword">var</span> mouseDown = Observable</span><br><span class="line">    .FromEventPattern&lt;MouseEventArgs&gt;(<span class="keyword">this</span>.myPictureBox, <span class="string">"MouseDown"</span>)</span><br><span class="line">    .Select(x =&gt;x.EventArgs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// unitized APM model</span></span><br><span class="line"><span class="keyword">var</span> request = WebRequest.Create(<span class="string">"https://www.shinetechchina.org"</span>);</span><br><span class="line"><span class="keyword">var</span> webRequest = Observable</span><br><span class="line">    .FromAsyncPattern&lt;WebResponse&gt;(request.BeginGetResponse, request.EndGetResponse);</span><br></pre></td></tr></table></figure>
<p>最后我们看一个更加复杂的组合事件的例子，也就是之前一直讨论的异步流组合问题。Drag and Drop这个场景做<code>Winform</code>的同学不会陌生，需要多少代码冷暖自知，如果借助<code>Rx</code>，那么事情就简单很多：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mouseDown = Observable</span><br><span class="line">    .FromEventPattern&lt;MouseEventArgs&gt;(<span class="keyword">this</span>.controlSource, <span class="string">"MouseDown"</span>)</span><br><span class="line">    .Select(x =&gt; x.EventArgs.GetPosition(<span class="keyword">this</span>));</span><br><span class="line"><span class="keyword">var</span> mouseUp = Observable</span><br><span class="line">    .FromEventPattern&lt;MouseEventArgs&gt;(<span class="keyword">this</span>.controlSource, <span class="string">"MouseUp"</span>)</span><br><span class="line">    .Select(x =&gt; x.EventArgs.GetPosition(<span class="keyword">this</span>));</span><br><span class="line"><span class="keyword">var</span> mouseMove = Observable</span><br><span class="line">    .FromEventPattern&lt;MouseEventArgs&gt;(<span class="keyword">this</span>.controlSource, <span class="string">"MouseMove"</span>)</span><br><span class="line">    .Select(x =&gt; x.EventArgs.GetPosition(<span class="keyword">this</span>));</span><br><span class="line"><span class="keyword">var</span> dragandDrop = </span><br><span class="line">    <span class="keyword">from</span> down <span class="keyword">in</span> mouseDown</span><br><span class="line">    <span class="keyword">from</span> move <span class="keyword">in</span> mouseMove.StartWith(down).TakeUntil(mouseUp)</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span> &#123;</span><br><span class="line">        X = move.X - down.X,</span><br><span class="line">        Y = move.Y - down.Y</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">dragandDrop.Subscribe(<span class="keyword">value</span> =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    DesktopCanvas.SetLeft(<span class="keyword">this</span>.controlSource, <span class="keyword">value</span>.X);</span><br><span class="line">    DesktopCanvas.SetTop(<span class="keyword">this</span>.controlSource, <span class="keyword">value</span>.Y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Rx</code>也提供了<code>javascript</code>扩展，有兴趣可以深入研究。</p>
<p>（完）</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/productivity/">productivity</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/productivity/">productivity</a><a href="/tags/C/">C#</a><a href="/tags/asynchronous/">asynchronous</a><a href="/tags/javascript/">javascript</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/12/03/async-programming/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/05/coolshell-puzzle-guides/" title="coolshell puzzle guides" itemprop="url">coolshell puzzle guides</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2014-08-05T02:14:41.000Z" itemprop="datePublished"> Published 2014-08-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><a href="http://www.coolshell.cn" target="_blank" rel="noopener">CoolShell</a>博主<a href="http://weibo.com/haoel" target="_blank" rel="noopener">陈皓</a>做了一个在线的puzzle很有意思，链接在<a href="http://fun.coolshell.cn" target="_blank" rel="noopener">这里</a>，这里记录一下解题的一些步骤。</p>
<h2 id="Puzzle-0"><a href="#Puzzle-0" class="headerlink" title="Puzzle 0"></a>Puzzle 0</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++++++++[&gt;+&gt;++&gt;+++&gt;++++&gt;+++++&gt;++++++&gt;+++++++&gt;++++++++&gt;+++++++++&gt;++++++++++&gt;+++++++++++&gt;++++++++++++&gt;+++++++++++++&gt;++++++++++++++&gt;+++++++++++++++&gt;++++++++++++++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+++.---&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;--.++&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;.&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.</span><br></pre></td></tr></table></figure>
<p>如果之前没有听说过变态的编程语言，就让你见识一下。<a href="http://www.muppetlabs.com/~breadbox/bf/" target="_blank" rel="noopener">BrainFuck</a>也称BF，是一门只有8个指令构成的图灵完备的语言。<a href="http://www.coolshell.cn" target="_blank" rel="noopener">CoolShell</a>博主<a href="http://weibo.com/haoel" target="_blank" rel="noopener">陈皓</a>写过一篇简单的介绍在<a href="http://coolshell.cn/articles/1142.html" target="_blank" rel="noopener">这里</a><br>具体的指令解释不多说了，直接打长<a href="http://esoteric.sange.fi/brainfuck/impl/interp/i.html" target="_blank" rel="noopener">这里</a>，把上面的指令粘进去，运行得到下一关的地址：<code>welcome.html</code>。</p>
<h2 id="Puzzle-welcome-html"><a href="#Puzzle-welcome-html" class="headerlink" title="Puzzle welcome.html"></a>Puzzle welcome.html</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X * Y</span><br><span class="line">2, 3, 6, 18, 108, ?</span><br><span class="line">What is the meaning of life, the universe and everything?</span><br><span class="line">生命、宇宙以及任何事情的终极答案</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
            <a href="/2014/08/05/coolshell-puzzle-guides/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/other/">other</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/08/05/coolshell-puzzle-guides/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2013/02/22/how-to-recovery-macos-password-without-installation-cd/" title="MacOS密码恢复" itemprop="url">MacOS密码恢复</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2013-02-22T07:22:00.000Z" itemprop="datePublished"> Published 2013-02-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>官方解决方法。找出电脑原配的系统盘，找不到就借一张或者刻录一张，重启电脑，启动的时候按C键，选好语言后进入安装的时候，点击“常用工具”，里面有一项是“重设密码”，这时就可以重新设定Mac OS系统的管理员密码了。</p>
        
        
        <p class="article-more-link">
          
            <a href="/2013/02/22/how-to-recovery-macos-password-without-installation-cd/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/tips/">tips</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2013/02/22/how-to-recovery-macos-password-without-installation-cd/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2010/07/21/razor-quick-glance/" title="初探Razor视图引擎" itemprop="url">初探Razor视图引擎</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2010-07-21T09:18:00.000Z" itemprop="datePublished"> Published 2010-07-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>前一段时间，ScottGu在博客上发表了一些有关WebMatrix的文章，其中提到了一个新的ASP.NET视图引擎——Razor。</p>
<p>Razor有着非常简单和干净的语法，但是不管怎么样，它毕竟只是一个表现层面的东西，其底层仍然使用ASP.NET，与平时的开发没有什么大的区别，唯一的区别在于：视图的简洁。<br>
        
        
        </p><p class="article-more-link">
          
            <a href="/2010/07/21/razor-quick-glance/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/asp-net/">asp-net</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2010/07/21/razor-quick-glance/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://github.com/lurongkai" target="_blank" title="Github">Github</a>
            
          </li>
        
          <li>
            
            	<a href="/software-designing-perspective" target="_blank" title="软件和设计">软件和设计</a>
            
          </li>
        
          <li>
            
            	<a href="/human-being-and-life-perspective" target="_blank" title="人类和生活">人类和生活</a>
            
          </li>
        
    </ul>
</div>

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/productivity/" title="productivity">productivity<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C#">C#<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/security/" title="security">security<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/microservice/" title="microservice">microservice<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/F/" title="F#">F#<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/collaboration/" title="collaboration">collaboration<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/asynchronous/" title="asynchronous">asynchronous<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/javascript/" title="javascript">javascript<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Golang/" title="Golang">Golang<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/error-handling/" title="error-handling">error-handling<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Functional-Programming/" title="Functional-Programming">Functional-Programming<sup>1</sup></a></li>
			
		
		</ul>
</div>


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/asp-net/" title="asp-net">asp-net<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/dot-net/" title="dot-net">dot-net<sup>5</sup></a></li>
		  
		
		  
		
		  
		
		  
		
		  
			<li><a href="/categories/other/" title="other">other<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/productivity/" title="productivity">productivity<sup>4</sup></a></li>
		  
		
		  
		
		  
			<li><a href="/categories/tips/" title="tips">tips<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/training/" title="training">training<sup>1</sup></a></li>
		  
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer">
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m lurongkai on Github <br>
			</p>
	</section>
	 
	<div class="social-font">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/lurongkai" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="Lu Rongkai">Lu Rongkai</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?74291727c50712cd2fcc785ef807bd0c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
