
 <!DOCTYPE HTML>
<html lang="default">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  
    <title>lurongkai&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Lu Rongkai">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="lurongkai&#39;s blog">
<meta property="og:url" content="https://lurongkai.github.io/index.html">
<meta property="og:site_name" content="lurongkai&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lurongkai&#39;s blog">

    
    <link rel="alternative" href="/atom.xml" title="lurongkai&#39;s blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="lurongkai&#39;s blog">lurongkai&#39;s blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search">
						<input type="hidden" name="q" value="site:lurongkai.github.io">
					</form>
					
					</li>
				</ul>
			</ul></nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/26/handle-error-gracefully-in-golang/" title="如何优雅的在Golang中进行错误处理" itemprop="url">如何优雅的在Golang中进行错误处理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2019-07-26T04:06:14.000Z" itemprop="datePublished"> Published 2019-07-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>如何优雅的在<code>Golang</code>中进行错误处理？</p>
<p>答案是：没有……（本文完）</p>
<hr>
<p>开个玩笑，<code>Golang</code>中的错误处理方式一直是社区热烈讨论的话题，有力挺者，有抱怨者，但不论如何，自2009年<code>Golang</code>正式发布以来，关于错误处理就一直是现在这种状况。</p>
<p>随着<code>Golang</code>愈加的火爆，原本是<code>Java</code>、<code>Node</code>、<code>C#</code>等语言擅长的应用级开发领域也逐渐出现<code>Golang</code>的身影。<code>Golang</code>自身其实更加擅长做基础设施级开发，例如<code>docker</code>，例如<code>k8s</code>，再如<code>etcd</code>，它友好的内存管理和简单到粗暴的语法（25个关键字），特别适合过去<code>C</code>和<code>C++</code>这些语言所擅长的部分场景。我们有理由相信，<code>Golang</code>下一个大的引爆点将也许会在<code>IoT</code>上，因为它天然的适合。</p>
<p>当一门语言火起来，就会出现各式各样的应用，于是<code>MVC</code>框架有了，音视频处理库有了，各种数据库驱动有了，甚至服务框架也出现了，游戏、<code>Machine Learning</code>都不在话下，还要啥自行车？组合一下做应用级开发妥妥的没毛病。</p>
<p>但是，成也这25个关键字，败也这25个关键字，究其根本原因，都是因为它背后<strong>简单</strong>的哲学。</p>
<p>做应用级开发可不是那么简单的，这涉及到很多的细节处理，例如本文将要讨论的错误处理。如果只是写一个库，那么这个话题相对比较简单，因为与<code>API</code>打交道的都是开发者，你只管开心的往外扔<code>error</code>就好了，总会有倒霉的程序员在使用你的代码时<strong>DEBUG</strong>到白头，最后，以最严谨的方式，小心使用你的库；可是有人出现的地方就会有幺蛾子，一个常见的误区就是将<strong>业务错误</strong>、<strong>运行时错误</strong>、<strong>程序错误</strong>一股脑的当成相同的<code>error</code>来处理。</p>
<blockquote>
<p>你是还没在<code>error</code>上栽跟头，当你栽了跟头时才会哭着想起来，当年为什么没好好思考和反省<strong>错误处理</strong>这么一个宏大的话题</p>
</blockquote>
<p>那么，如何在现有的语言支持下，用一种相对优雅的方式进行错误处理呢？我们通过本文的思考和讨论，尝试予以解决。虽说主要讨论的是<code>Golang</code>，但是这背后的思考其实适合大部分语言。</p>
<h2 id="语言级别的错误处理"><a href="#语言级别的错误处理" class="headerlink" title="语言级别的错误处理"></a>语言级别的错误处理</h2><p><code>Golang</code>是原生支持鸭子类型（<a href="https://en.wikipedia.org/wiki/Duck_typing" target="_blank" rel="noopener">duck typing</a>）的，所以<code>error</code>可以理解成一个“鸭子”的定义，它是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换句话讲，一切实现了<code>Error() string</code>方法的<code>struct</code>，都可以当成<code>error</code>往外扔，神不神奇？不神奇……把它看成接口也无碍，反正其它语言也长的类似，比如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SystemException</span> : <span class="title">Exception</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InvalidOperationException</span> : <span class="title">SystemException</span></span><br></pre></td></tr></table></figure>
<p>问题来了，<code>Golang</code>是没有继承这一说的，所以如果你想把错误规划成层级结构是行不通的，而且也不是<code>Golang</code>的调调。不过定义多种错误终归是可以的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"errors"</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrNotAuthenticated = errors.New(<span class="string">"not authenticated"</span>)</span><br><span class="line">    ErrNotAuthorized    = errors.New(<span class="string">"not authorized"</span>)</span><br><span class="line">    ErrNoPermission     = errors.New(<span class="string">"no permission"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>鸭子类型在不使用继承的情况下变相支持了多态，所以是可以认为<code>error</code>是个接口，<code>error</code>的消费方可以不用关心背后是具体什么结构，只需要满足<code>error</code>契约就行，这就是所谓的多态。</p>
<p>那么到这里为止，我们有了具体的<code>error</code>，然后呢？总是得有一个地方去处理。从这里开始，<code>Golang</code>与别的语言区分开了。</p>
<p>本来想解释一下什么是错误(error)，什么是异常(exceptional)，但是貌似太多的语言在混搭使用这两个术语，所以我们干脆放弃解释错误和异常，而使用可恢复和不可恢复来说明。同时，我个人实名点赞<code>Golang</code>和<code>Rust</code>在这两个概念上的区分。</p>
<h3 id="不可恢复故障"><a href="#不可恢复故障" class="headerlink" title="不可恢复故障"></a>不可恢复故障</h3><p><code>Golang</code>和<code>Rust</code>都有<code>panic</code>的概念，也就是指不可恢复的故障，一般遇到<code>panic</code>时基本就不用再救了，大部分的时候都是直接以<code>-1</code>为返回值退出程序就好，<strong>除非你觉得我行我可以我还想再试试</strong>，那么使用<code>recover</code>手段，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line">fun horrible() &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"some bad things happened"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">business</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// give me another chance</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    horrible()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不处理的话，程序就会自动退出，并打印出错误信息以及错误堆栈。<code>Rust</code>的方式几乎一模一样，只不过有两点不同：<code>Rust</code>中对应<code>panic</code>的是<code>panic!</code>宏，和<code>recover</code>类似的功能是<code>std::panic::catch_unwind</code>；另外就是退出后默认不打印堆栈，需要的话得手动设置<code>RUST_BACKTRACE=1</code>环境变量。</p>
<p>这个非常好理解，比如数组越界了，内存满了，堆栈爆了，几乎碰到<code>panic</code>就很少有恢复的可能。</p>
<p><code>panic</code>背后其实是一种<strong>短路</strong>（或者叫<strong>快捷方式</strong>）哲学，任何层级的流程在执行过程中，通过<code>panic</code>都可以直接让程序跳到结束或者有<code>recover</code>的地方。这与大多数据的高级语言的<code>Exception</code>不谋而合，举个例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSometingIntresting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"not allowed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要碰到<code>Exception</code>就一定会中断正常的执行顺序。稍显遗憾的是，这些语言中的<code>Exception</code>不完全能把程序打死，因为它们大多都提供了<code>try-catch</code>语言构造，让你可以在任何想处理的地方，或处理或加工，总之手法多样。打不死的原因也正是因为，一个简单的<code>catch (Exception ex) {}</code>就足够吃掉所有的故障。</p>
<p>这也是为什么在开头那部分里不用错误和异常的原因，因为：</p>
<blockquote>
<p>大多数支持<code>try-catch-exception</code>机制的语言里，可恢复和不可恢复的故障都用Exception来表示，这加剧了开发者的心智负担，因为这需要仔细的处理Exception的类型。例如，C#里的<strong>不可恢复</strong>错误往往都有特定的继承链，比如<code>SystemException</code>，使用时需要小心处理。</p>
</blockquote>
<p>更好的理解方式是，把<code>try-catch-exception</code>这种机制，主要作为处理<strong>可恢复</strong>故障的手段，而把少量<strong>不可恢复</strong>的故障，在充分思考的情况下处理或放任。换句话讲，<strong>catch一定尽可能的按下游方法可能出现的<code>Exception</code>类型去匹配，不要随意通吃</strong>。</p>
<h3 id="可恢复故障"><a href="#可恢复故障" class="headerlink" title="可恢复故障"></a>可恢复故障</h3><p>与<code>panic</code>有所区别的<strong>可恢复</strong>故障，<code>Golang</code>也有约定的方式。这就是<code>error</code> 。</p>
<p>所谓可恢复，就是虽然无法顺利的将当前的流程执行完毕，但是不影响大局，消费方可以按自己的意愿去安排接下来的逻辑，或中断执行某个业务，或检查是否自己使用的方式有问题，或有备用的流程替换等等。</p>
<p>实践中经常碰到的可恢复故障有几大类：</p>
<ul>
<li><strong>前置检查失败</strong>，大多是指参数没有按约定提供，例如参数不可空校验失败的错误，参数数值范围不正确等等，这是<strong>调用方的bug</strong></li>
<li><strong>程序错误</strong>，例如通过<code>req.(sometype)</code>进行类型转换，到运行时发现转不过去，这是<strong>自身的bug</strong></li>
<li><strong>依赖服务调用错误</strong>，比如查询数据库时发生了异常，往往都是第三方产生运行时错误，是最经常处理的错误</li>
<li><strong>业务执行错误</strong>，例如一个发送验证码的函数，在执行过程中发现某个用户的发送频率超过阈值，那这是一个特定业务的失败</li>
</ul>
<p>基本所有在开发过程中碰到的错误都能归入以上4类。而往往需着重关注的，是后两类。前两类实属于<strong>bug</strong>，需要在上线前就清理完毕的。</p>
<h2 id="可恢复故障的抛出方式"><a href="#可恢复故障的抛出方式" class="headerlink" title="可恢复故障的抛出方式"></a>可恢复故障的抛出方式</h2><p>我们来做一个思考。在一门语言中，如果一个方法有可能出错，通常会通过什么途径把错误信息告诉调用者呢？换句话讲，正常的方法返回数据，不正常的方法需要有途径“带货”，把错误信息以某种方式带出去。</p>
<h3 id="单值函数的方式"><a href="#单值函数的方式" class="headerlink" title="单值函数的方式"></a>单值函数的方式</h3><p>如果这门语言只支持单值函数，也就是返回值只能是一个，那么就需要有一个容器来储存正常的值和出错时需要返回的错误信息，就像：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Result</span>&lt;'T&gt; </span>= &#123;</span><br><span class="line">    Data: <span class="symbol">'T</span> </span><br><span class="line">    Error: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，每个使用该方法的地方，只需要简单判断一下<code>res.Error</code>就能知道有没有错误发生。</p>
<p>像不像是很多<code>Restful</code>接口返回数据的模样？是的，完全是一个模式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">"errmsg: "</span><span class="string">",</span></span><br><span class="line">    "errcode": "610100"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先忽略这个错误码，后面的内容我们会涉及到。</p>
<h3 id="多值函数的方式"><a href="#多值函数的方式" class="headerlink" title="多值函数的方式"></a>多值函数的方式</h3><p>那如果语言支持多值返回（其实还是单值，大多是引入<code>元组（Tuple）</code>来处理，例如<code>Python</code>），概念上和如下的方式相同：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Tuple&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt; <span class="title">Multiple</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Tuple.Create(<span class="number">0</span>, <span class="string">"something wrong"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，该<code>Golang</code>出场了，既然我支持多值返回，那么应该不用明显的包装类型就可以做到了吧：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiple</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="string">"something wrong"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等等，错误用<code>string</code>表示有点丑是不是，没关系，<code>Golang</code>帮你抽象出一个<code>error</code>接口来，最终就变成了<code>func multiple() (int, error) {}</code>这样子了，<br>和定义一个<code>type res struct { Data int; Err error}</code>相比，好像没进步太多？</p>
<h3 id="函数式的方式"><a href="#函数式的方式" class="headerlink" title="函数式的方式"></a>函数式的方式</h3><p>那还有没有更好的方式了呢？如果有接触过<code>Functional Programming</code>的东西，就会想到，通过<code>Generic</code> + <code>Discriminated Unions</code> + <code>partten matching</code>的方式更加优雅。</p>
<p>核心在<code>Discriminated Unions</code>上，也叫做<code>Enum</code>，<code>Union</code>，<code>Tagged Union</code>，<code>variant</code>，<code>variant record</code>，<code>choice type</code>，<code>disjoint union</code>，<code>sum type</code>，<code>coproduct</code>……它是一种可以存储多种（但是数量固定）类型值的结构，同一时间<strong>只可以</strong>使用其中的一种类型。举个例子，如下的<code>DUs</code>可以避免<code>null</code>的显式使用：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Option</span>&lt;'T&gt; </span>=</span><br><span class="line">    | None</span><br><span class="line">    | Some <span class="keyword">of</span> <span class="symbol">'T</span></span><br></pre></td></tr></table></figure>
<p>这个<code>Option&lt;&#39;T&gt;</code>（也有叫<code>Maybe</code>的）要么只有<code>None</code>值，要么只有一个包含<code>&#39;T</code>的<code>Some</code>值，于是，当函数返回一个<code>Option</code>类型的值时，消费方就可以不再写诸如<code>Golang</code>中的<code>if err != nil {}</code>了，而是使用更加高级的模式匹配完成：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> res = somemethod() <span class="comment">// will return an Option value</span></span><br><span class="line"><span class="keyword">match</span> res <span class="keyword">with</span></span><br><span class="line">    | None   -&gt; <span class="comment">// data is empty, like null</span></span><br><span class="line">    | Some d -&gt; <span class="comment">// d is data</span></span><br></pre></td></tr></table></figure>
<p>等等，这不像是在做错误处理？没关系，稍微变换一下：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Result</span>&lt;'T, 'TError&gt; </span>= </span><br><span class="line">    | Ok <span class="keyword">of</span> <span class="symbol">'T</span> </span><br><span class="line">    | Error <span class="keyword">of</span> 'TError</span><br></pre></td></tr></table></figure>
<p>现在的使用方式变成了：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> res = somemethod() <span class="comment">// will return an Option value</span></span><br><span class="line"><span class="keyword">match</span> res <span class="keyword">with</span></span><br><span class="line">    | Ok t      -&gt; <span class="comment">// t is normal result</span></span><br><span class="line">    | Error err -&gt; <span class="comment">// err is error</span></span><br></pre></td></tr></table></figure>
<p>好像还是没什么用？那是因为没有接触过<code>FP</code>中的<code>Warpper</code>类型的概念，基本上有了<code>Warpper</code>类型，就可以<code>bind</code>或者<code>lift</code>等等了。<code>Rust</code>走的就是这种路子，并有配套的函数支持。由于<code>Option</code>和<code>Result</code>如此常用，以至于很多语言核心库都内置了对应的结构，有兴趣可以参考我很早之前写过的一点<a href="http://www.ituring.com.cn/article/207638" target="_blank" rel="noopener">东西</a>。</p>
<p>那么，<code>Golang</code>为什么不使用这种方式呢？因为，第一缺乏泛型支持，<code>Warpper</code>如果没有泛型支持的话就无法泛化，会导致很多的模板代码，进而还不如直白的处理<code>error</code>；第二没有<code>Discriminated Unions</code>，多个类型无法联合起来并在同一时间只使用其中一种，也就快速区分彼此；第三没有模式匹配，也就无法更进一步的简化代码，不如还是使用<code>if err != nil {}</code>。</p>
<p>上面诸多方式仍然停留在<code>调用-返回-处理</code>这个流程上，顶多也就是代码简洁与否的问题。我个人是认可<code>Golang</code>的错误处理方式的，虽然会出现很多的模板代码，但是在写代码的每一步都能清晰的并强迫性的让开发者处理潜在的错误，也是一种提高质量的不错手段。</p>
<p>实践中使用最多的方式，是隔空传送<code>Exception</code>，虽然有很多的文章在指导大家如何去花式处理<code>Exception</code>，但是仍然值得大家留意其中的陷阱。毕竟，异常是一种中断当前执行流程的手段，并且会穿透调用栈，所以需要格外留意捕获到的异常究竟代表了什么含义，而不是一股脑的全部捕获。这一点要赞一下<code>Java</code>，<code>Java</code>中的方法签名会强制列出有可能抛出的异常类型，以供开发者快速处理可能出现的异常。</p>
<p>有关<code>Exception</code>设计和使用的话题，我们将来有机会再来聊。</p>
<h3 id="Golang中将来可能的方式"><a href="#Golang中将来可能的方式" class="headerlink" title="Golang中将来可能的方式"></a>Golang中将来可能的方式</h3><p>在<code>Go 2</code>的草案中，我们看到了有关于<code>error</code>相关的一些提案，那就是<code>check/handle</code>函数。</p>
<p>我们也许在下一个大版本的<code>Golang</code>可以像下面这样处理错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">game</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    handle err &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"dependencies error: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    resource := check findResource() <span class="comment">// return resource, error</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        resource.Release()</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    profile := check loadProfile() <span class="comment">// return profile, error</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        profile.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有兴趣的同学请关注<a href="https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md" target="_blank" rel="noopener">这个提案</a>。题外话，还有一个<code>try</code><a href="https://go.googlesource.com/proposal/+/master/design/32437-try-builtin.md" target="_blank" rel="noopener">提案</a>正式被<a href="https://github.com/golang/go/issues/32437#issuecomment-513002788" target="_blank" rel="noopener">否了</a>。</p>
<p>所以，在<code>Golang</code>中我们目前可以使用的方式，就是以<code>error</code>接口为基础，通过不同的错误类型，来向消费方提供有价值的信息。</p>
<h2 id="可恢复故障具体该怎么抛"><a href="#可恢复故障具体该怎么抛" class="headerlink" title="可恢复故障具体该怎么抛"></a>可恢复故障具体该怎么抛</h2><p>重点来了，说了这么多，错误终归是要扔出去的，虽然都是统一的<code>error</code>接口，但是手法却应该仔细斟酌。</p>
<h3 id="错误应该包含的信息"><a href="#错误应该包含的信息" class="headerlink" title="错误应该包含的信息"></a>错误应该包含的信息</h3><p>错误最主要包含的，就是错误信息，是给人类阅读使用的，更确切的讲，是<strong>给开发者阅读的</strong>。所以<code>error</code>接口里的<code>Error() string</code>直接将这个信息返回。那为什么要返回<code>error</code>，而不是直接返回<code>string</code>呢？因为在开发过程中，我们往往需要一些额外的信息。</p>
<p>首先，如果只有错误的文本，我们很难定位到具体的出错地点。虽然通过在代码中搜索错误文本也是有可能找到出错地点的，但是信息有限。所以，在实践中，我们往往会将出错时的调用栈信息也附加上去。调用栈对消费方是没有意义的，从隔离和自治的角度来看，消费方唯一需要关心的就是错误文本和错误类型。调用栈对实现者自身才是是有价值的。所以，如果一个方法需要返回错误，我们一般会使用<code>errors.WithStack(err)</code>或者<code>errors.Wrap(err, &quot;custom message&quot;)</code>的方式，把此刻的调用栈加到<code>error</code>里去，并且在某个统一地方记录日志，方便开发者快速定位问题。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/pkg/errors"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindUser</span><span class="params">(userId <span class="keyword">string</span>)</span> <span class="params">(*User, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> userId == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"userId is required"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    user, err := db.FindUserById(userId)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"query user %s failed"</span>, userId)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> user, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此，在记录日志的地方通过使用<code>%+v</code>格式化占位符就可以把堆栈信息完整的记录下来。</p>
<p>其次，如果是业务执行时的错误，只有错误消息的话，往往是不够的，因为调用方更加关心错误背后业务上的原因，例如，提交订单接口返回了<strong>提交订单失败</strong>的错误，为什么失败？这个时候就需要某种机制来告诉调用者一些业务上的原因。显然，如果通过错误消息告诉的话，调用方就不得不对错误文本进行判断，这很不优雅，所以我们往往通过其它两种方式来处理。</p>
<p><strong>1. 特定错误类型</strong>，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrInventoryInsufficient      = errors.New(<span class="string">"product inventory insufficient"</span>)</span><br><span class="line">    ErrProductSalesTerritoryLimit = errors.New(<span class="string">"product sales torritory limit"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ordering</span><span class="params">(userId <span class="keyword">string</span>, preOrder *PreOrder)</span> <span class="params">(*model.Order, error)</span></span> &#123;</span><br><span class="line">    order := &amp;model.Order&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    shippingAddress := preOrder.Shipping</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> preOrder.Items &#123;</span><br><span class="line">        <span class="keyword">if</span> findInventory(item.Product.Id) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrInventoryInsufficient</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> !isValidSalesTerritory(item.Product.Id, shippingAddress) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrProductSalesTerritoryLimit</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        order.AddItem(item)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// other processing</span></span><br><span class="line">    <span class="keyword">return</span> order, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，消费方拿到错误后，可以很简单的判断一下就能知道具体发生了什么：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserOrderController</span><span class="params">(ctx context.Context, preOrder *PreOrder)</span></span> &#123;</span><br><span class="line">    <span class="comment">// some preparing</span></span><br><span class="line">    user := FromContext(ctx)</span><br><span class="line">    order, err := service.Ordering(user.userId, preOrder)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> err &#123;</span><br><span class="line">            <span class="keyword">case</span> service.ErrInventoryInsufficient:      <span class="comment">// handling</span></span><br><span class="line">            <span class="keyword">case</span> service.ErrProductSalesTerritoryLimit: <span class="comment">// handling</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也是很多组件向外部提供错误的首选方式，例如，<code>mongo.ErrNoDocuments</code></p>
<p>但是遗憾的是，如果是跨边界的<code>RPC</code>调用的话（假如刚才的<code>Ordering</code>是个微服务），那么就不能采用这种方式了，因为错误<strong>类型</strong>是无法有效序列化的，即使序列化了也失去了类型判断的能力。所以，我们在集成有边界的服务时，往往会采用另一种方式。</p>
<p><strong>2. 错误标记</strong>，也就是通过某种约定好的标记，用于表示某种类型的业务错误。客户端调用远程的<code>Restful</code>服务也是边界与边界间的调用，所以我们经常可以在<code>API</code>的文档中看到这样的模式：</p>
<table>
<thead>
<tr>
<th>返回码</th>
<th>错误码描述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>40001</td>
<td>invalid credential</td>
<td>不合法的调用凭证</td>
</tr>
<tr>
<td>40002</td>
<td>invalid grant_type</td>
<td>不合法的grant_type</td>
</tr>
</tbody>
</table>
<p>这里的返回码就是一种约定好的标记，也叫<strong>业务码</strong>。所谓跨边界调用，也可以换个说法，叫做进程间通讯，如果只在进程内通讯，那使用特定错误类型就足够了，但是一旦出了进程，就需要某种标记手段了。</p>
<p><code>Golang</code>在实践中也可以采用这种方式，尤其是在边界间传递错误的时候：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"regexp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BusinessError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code    <span class="keyword">string</span> <span class="string">`json:"code"`</span></span><br><span class="line">    Msg     <span class="keyword">string</span> <span class="string">`json:"msg"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(be BusinessError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Printf(<span class="string">"[%s] %s"</span>, be.Code, be.Msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> codeReg = regexp.MustCompile(<span class="string">"^\\d&#123;6&#125;$"</span>)</span><br><span class="line"><span class="comment">// factory method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBusinessError</span><span class="params">(code <span class="keyword">string</span>, msg <span class="keyword">string</span>)</span> *<span class="title">BusinessError</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !codeReg.MatchString(code) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"code can only contain 6 numbers"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> msg == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"msg is required"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> &amp;BusinessError&#123; code， msg &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrInventoryInsufficient      = NewBusinessError(<span class="string">"301001"</span>, <span class="string">"product inventory insufficient"</span>)</span><br><span class="line">    ErrProductSalesTerritoryLimit = NewBusinessError(<span class="string">"301002"</span>, <span class="string">"product sales torritory limit"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>注意<code>NewBusinessError</code>内部使用的是<code>panic</code>，这背后的思考是，如果程序初始化时连错误码的定义都能出现问题，我倾向于让程序跑不起来，这样便在开发阶段就能妥善处理。</p>
<p>消费方拿到反序列化后的错误时，里面已经包含了标记，查询文档分别做处理就好。不管是<code>Restful</code>，还是<code>GRPC</code>、<code>GraphQL</code>，都可以使用这种模式来处理。甚至更大好处是，客户端不必判断错误文本并设法解析出用户友好的提示，服务不再提供用户提示（想想看，如果要对错误文本提供<code>i18n</code>支持的话，得多难看……），一切都交给客户端去自主选择。</p>
<h3 id="错误信息应该暴露多少"><a href="#错误信息应该暴露多少" class="headerlink" title="错误信息应该暴露多少"></a>错误信息应该暴露多少</h3><p><strong>暴露多少错误细节，取决于对这个错误感兴趣的一方是谁。</strong><br><strong>暴露多少错误细节，取决于对这个错误感兴趣的一方是谁。</strong><br><strong>暴露多少错误细节，取决于对这个错误感兴趣的一方是谁。</strong></p>
<p>如果感兴趣一方是其他开发者，那么事情就会变的愉快很多，因为，开发者感兴趣的错误，一般都是<strong>bug</strong>或者<strong>缺陷</strong>，我们不必把所有的细节都解释给开发者，但是必要的信息是要提供的，比如一个简单的错误文本。</p>
<p>举个例子，我们正在写一个包，其中有一个用于发送（大陆）短信的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"regexp"</span></span><br><span class="line">    <span class="string">"github.com/pkg/errors"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    phoneRegexp = regexp.MustCompile(<span class="string">"^((\\+86)|(86))?\\d&#123;11&#125;$"</span>)</span><br><span class="line">    ErrPhoneSmsExceedLimit = errors.New(<span class="string">"target phone exceed send limits"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendSms</span><span class="params">(phone <span class="keyword">string</span>, content <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> phone == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"phone is required"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> content == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"content is required"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> !phoneRegexp.MatchString(phone) &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"phone format incorrect"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> exceedLimits(phone) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrPhoneSmsExceedLimit</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于使用<code>SendSms</code>的人只可能是开发者，所以简单的将错误信息返回就可以了，无须再多做处理。</p>
<p>这里需要插一句，一切的错误都会影响消费方的执行（除非消费方总是忽略错误），所以总在某个地方将我们返回的错误展示给开发者。</p>
<p>在上面这个例子中，我们已经要求了<code>phone</code>和<code>content</code>不应该为空字符串，那么消费方为什么还要给我空字符串呢？<strong>这是bug</strong>。</p>
<p>另外，如果手机号超过了每日发送的条数限制，这<strong>不是bug</strong>，而是业务错误，所以我们用<code>ErrPhoneSmsExceedLimit</code>提醒开发者，需要额外留意和处理一下，必要的时候用一些友好信息告诉用户。在该例子中是假定<code>SendSms</code>和消费方处于同一进程，所以只需要通过判断<code>err == sms.ErrPhoneSmsExceedLimit</code>就可以准确的捕获到业务错误。那如果这个发短信的方法在一个微服务之后呢？上面我们也提到了，这时候需要有某种标记：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">var</span> ErrPhoneSmsExceedLimit = NewBusinessError(<span class="string">"310001"</span>, <span class="string">"target phone exceed send limits"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendSms</span><span class="params">(phone <span class="keyword">string</span>, content <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> exceedLimits(phone) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrPhoneSmsExceedLimit</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是殊途同归了？当然了，这其中还涉及到一些边界上对错误的包装与转换，我们在后面会提到。</p>
<p>那么接下来，如果这个方法还需要调用一些别的<code>RPC</code>（这里假定是个<code>Restful</code>服务）才能完成最终的发送，并且调用有可能会有错误，该怎么处理呢？我们会包装它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendSms</span><span class="params">(phone <span class="keyword">string</span>, content <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    provider := service.NewSmsProvider(<span class="string">"appid"</span>, <span class="string">"appsecret"</span>)</span><br><span class="line">    res, err := provider.Send(phone, content)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.Wrapf(err, <span class="string">"send sms to phone %s failed"</span>, phone)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此，消费方看到的只是<code>send sms to phone xxx failed</code>（包装进去的低层<code>err</code>会在边界处切掉），不过不影响我们服务本身打印出调用栈，方便我们知道是我们使用<code>RPC</code>的姿势有问题，还是网络出现故障了，还是……总之，我们进行不下去了。我们不必告诉消费方这些低层的错误细节，但是我们需要保留这些细节方便自己。</p>
<p>我们继续思考，如果调用<code>RPC</code>成功返回了，就一定代表成功了吗？当然不是，没有<code>err</code>很可能只是说明整个<code>RPC</code>成功完成，但没说业务一定是成功的呀，所以我们还得对<code>res</code>进一步分析：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendSms</span><span class="params">(phone <span class="keyword">string</span>, content <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    res, err := provider.Send(phone, content)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> res.Code &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"0000"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"1001"</span>: </span><br><span class="line">            log.Printf(<span class="string">"sms provider report [%s] insufficient balance"</span>, res.code)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            log.Printf(<span class="string">"sms provider report [%s] %s"</span>, res.Code, res.Msg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"send sms failed"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们已知的业务码只有<code>0000</code>代表成功，所以返回<code>nil</code>表示本次调用成功；<code>1001</code>代表余额不足，其它的我们可能并不关心，那么在简单的记录日志之后，返回给调用方的只有<code>send sms failed</code>。这是因为，我的错误我知道，我依赖服务的错误我也应该知道，但是，依赖我的服务如果不是使用姿势不对，或者业务不正确的话，没有理由了解这背后发生的过多细节，唯一需要让消费方知道的就是<strong>没成功</strong>。与此同时，我们记录了所有的细节，不管是显式的<code>log.Printf</code>还是在边界上打印的调用栈，都将进一步帮助我们分析和修复错误，或者改善实现细节。</p>
<p>那么，如果此时<code>SendSms</code>方法还需要调用并处理另一个<strong>内部</strong>的方法<code>darkMagic(phone string) error</code>返回的错误呢？没关系，仍然<code>errors.Wrap(err, &quot;cannot perform such operation&quot;)</code>就好了。这不仅仅是给调用方看，更重要的是，这说明了在<code>darkMagic</code>里<strong>可能有一个bug</strong>，需要我们自己处理，因为，我们是最清楚这些逻辑的，如果一切检查（参数的，业务的）都没问题，还会在内部出错，那么就可能是我们的实现有问题了。好在，这一类的缺陷通过单元测试一般都可以检测出来。</p>
<blockquote>
<p>一个小问题，<code>darkMagic()</code>里如果调用<code>spellForce()</code>又得到<code>error</code>了怎么办？<br>答案是，直接<code>return err</code><br>堆栈信息在<code>spellForce()</code>扔出的<code>error</code>里就有了，错误信息也很明确，着实不用再包装一层。<br>也就是说，进程内遇到的<code>error</code>，只在离边界最近的地方才需要<code>errors.Wrap()</code>成对调用方友好（和隐藏细节）的<code>error</code>，其它的都直白的往上<code>return err</code>就好</p>
</blockquote>
<p>总结一下：</p>
<ul>
<li>你使用我的姿势不对，例如空字符串，会造成我的错误，直接返回<code>errors.New()</code>，这是<strong>bug</strong>，你去处理</li>
<li>你使用的姿势是对的，我定睛一看是业务上问题，给你一个让你有机会通过<strong>错误类型</strong>或者<strong>错误码</strong>知道的原因，你<strong>酌情处理</strong></li>
<li>你使用的姿势是对的，我检查发现业务也没毛病，但是我依赖的一些服务（例如数据库）出幺蛾子了，那么我会<code>Wrap</code>成一个既方便我调查原因，同时在不让你关注过多细节的前提下告诉你：<strong>失败了</strong>，你<strong>酌情处理</strong>，例如重试或者告诉最终用户“我们的服务开了会小差，请稍后重试”等</li>
<li>如果我觉得这一定是个很严重的问题，并且我也无法解决，同时认为你也不该尝试解决，那么就<code>panic</code>吧。这一点在在线业务上几乎遇不到，除了“内存满了”、“堆栈爆了”这些无法抗拒的原因，<code>panic</code>的很少会有</li>
</ul>
<h2 id="可恢复故障如何处理"><a href="#可恢复故障如何处理" class="headerlink" title="可恢复故障如何处理"></a>可恢复故障如何处理</h2><p>我们在“错误信息应该暴露多少”一节里已经展示过一些处理方式，尤其是对跨越多层边界的错误，进程内遇到错误的情形等。非边界处的错误处理很直白，上一节也做出了解释和示例，这一节我们讨论一下在边界处如何处理遇到的<code>error</code>。</p>
<p>所谓边界，就是离调用方最近的地方，调用方可以是某个服务，也可以是用户使用的某种客户端，总之是在消费你在边界处提供的服务。边界以内，只有进程内可见。</p>
<p>所以，我们可以认为，一个<strong>用户微服务的<code>GetUserById()</code></strong>在边界上，一个<code>beego.Get(&quot;/&quot;,func(ctx *context.Context){})</code> 用<code>MVC</code>实现的方法也在边界上。</p>
<p>通常情况下，在边界处，我们就需要对下游产生的错误做出判断，同时，对一些非业务错误一些包装，隐藏错误细节。如果边界不是面向最终用户的，那么也会提供一些开发者友好的错误文本。</p>
<p>我们分别来这其中处理错误的不同。</p>
<p>对于一个用户微服务的<code>GetUserById()</code>，它的消费方一般不会是最终用户，而是某种<strong>聚合网关</strong>或者其它<strong>微服务</strong>，所以它藏匿在整个安全壁垒之后。我们通常会这么处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"github.com/pkg/errors"</span></span><br><span class="line">	<span class="string">"go.mongodb.org/mongo-driver/bson"</span></span><br><span class="line">	<span class="string">"go.mongodb.org/mongo-driver/bson/primitive"</span></span><br><span class="line">	<span class="string">"go.mongodb.org/mongo-driver/mongo"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> ErrUserNotValid = NewBusinessError(<span class="string">"500213"</span>, <span class="string">"user is not valid"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserById</span><span class="params">(userId <span class="keyword">string</span>)</span> <span class="params">(*model.User, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> userId == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"userId is required"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    uid, err := primitive.ObjectIDFromHex(userId)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"userId format incorrect"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    user := &amp;model.User&#123;&#125;</span><br><span class="line">    coll := db.Collection(<span class="string">"users"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err := coll.FindOne(context.TODO(), bson.M&#123;<span class="string">"_id"</span>: uid&#125;).Decode(user); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err == mongo.ErrNoDocuments &#123;</span><br><span class="line">            <span class="comment">// maybe return nil, nil is fine</span></span><br><span class="line">            <span class="comment">// but, depends on design, be careful</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"cannot perform such operation"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// maybe do local business check</span></span><br><span class="line">    <span class="keyword">if</span> localBusinessCheck(user) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrUserNotValid</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// maybe call RPC to do business action</span></span><br><span class="line">    fine, err := rpc.BusinessAction(user)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// err usually wrapped in rpc particular message type</span></span><br><span class="line">        <span class="comment">// so we need abstract real error from wrapper type</span></span><br><span class="line">        rpcStatus := rpc.Convert(err)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> rpcStatus.Type == rpc.Status_Business_Error &#123;</span><br><span class="line">            code := rpcStatus.GetMeta(<span class="string">"code"</span>)</span><br><span class="line">            msg  := rpcStatus.GetMeta(<span class="string">"msg"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, NewBusinessError(code, msg)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cause := rpcStatus.Error()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(cause, <span class="string">"service unavailable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !fine &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrUserNotValid</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> user, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段示例很有意思。首先，如何处理下游支撑服务返回的异常？支撑服务（例如数据库、缓存、中间件等等）往往没有业务，它们返回的错误就是单纯的错误，需要开发者每时每刻关注和处理。所以，在这里直接包装并返回。于此同时，<code>GetUserById()</code>的消费方得到了只应该它们关注的<code>cannot perform such operation</code>，而在用户微服务里，我们得到了完整的调用栈和错误信息。</p>
<p>其次，本地的业务检查如果失败，我们将直接返回一个预定义好的<code>ErrUserNotValid</code>，表示一个业务上的失败。</p>
<p>最后，如果涉及进一步的远程<code>RPC</code>调用，事情会变的稍微麻烦一些。远程的<code>RPC</code>调用可能有错误，但是错误类型比较复杂。通过<code>RPC</code>的方式传递错误不如进程内调用那么简单直白，为了能够顺利序列化，很多的<code>RPC</code>框架都会将错误信息打包成为某种专有的结构，所以，我们需要一些手段从这些专有结构中提取出我们需要的信息出来。</p>
<blockquote>
<p>GRPC会将错误打包成为<code>google.golang.org/genproto/googleapis/rpc/status</code>包中的<code>status.Status</code>结构，<code>status.Status</code>里包含了<code>Code</code>、<code>Message</code>、<code>Details</code>，我们通常可以约定<code>Code</code>为<code>10</code>代表业务错误（10代表Aborted），同时将业务码打包进<code>Details</code>里。</p>
</blockquote>
<blockquote>
<p>GraphQL也有类似的方式，在返回的数据中，除了包含正常数据的<code>data</code>字段外，还有一个<code>errors</code>数组字段。一般发生错误时，会通过<code>errors.[].message</code>提供错误信息供客户端使用，但当我们需要提供业务码信息时，这个字段显然不太适合使用。不过好在，除了<code>errors.[].message</code>，GraphQL还提供了<code>errors.[].extensions</code>结构用于扩展错误信息。于是乎，可以和消费方约定一个业务码所使用的具体字段，例如<code>errors.[].extensions.code</code>，如此便很好的解决了问题。</p>
</blockquote>
<blockquote>
<p>Restful的方式其实很像是GraphQL的方式，由于<code>http</code>上不提供额外的序列化通道，能用的只有<code>body</code>这一个选项（用<code>header</code>？不能够！），所以看起来只能提供<code>{ &quot;data&quot;: {}, &quot;err_code&quot;: &quot;&quot;, &quot;err_msg&quot;: &quot;&quot; }</code>这样的万能包装。其实大可不必，没有错误的情况下，正常把数据写入<code>body</code>，当出现业务错误时，只要返回<code>{ &quot;err_code&quot;: &quot;&quot;, &quot;err_msg&quot;: &quot;&quot; }</code>，<strong>同时把status code设置为400</strong>即可，这样就能把万能的<code>data</code>字段解放出来了。如果是一般的错误，例如少参数、参数不允许为空等，这时候不用提供<code>err_code</code>，只提供<code>err_msg</code>，<strong>同时把status code设置为500</strong>即可。一股脑的<code>200</code>真的不是什么好设计。</p>
</blockquote>
<p>通过<code>rpc.Convert()</code>类似的工具函数，我们能从<code>RPC</code>的<code>error</code>中拿到原始的结构数据，然后通过判断，确定是否为业务上的错误（所代表的类型），进而将原始的业务错误重新向外扔出，不需要做额外的处理。如果不是业务上的错误，那么就是<strong>bug</strong>、缺陷或者传输级别的故障，我们仍旧可以通过包装扔出，留下堆栈和详细信息在微服务内。</p>
<p>这或多或少的需要一种<strong>统一的设计和约定</strong>，例如将<code>RPC</code>错误的类型字段的某个特定key，约定好专门用于存放业务错误码，否则的话将无法区分“业务错误”和“其它错误”。</p>
<p>示例中关于<code>RPC</code>错误的代码稍显啰嗦，我们其实可以稍微重构一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleRpcError</span><span class="params">(err error, wrapMsg <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rpcStatus := rpc.Convert(err)</span><br><span class="line">    <span class="keyword">if</span> rpcStatus.Type == rpc.Status_Business_Error &#123;</span><br><span class="line">        code := rpcStatus.GetMeta(<span class="string">"code"</span>)</span><br><span class="line">        msg  := rpcStatus.GetMeta(<span class="string">"msg"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, NewBusinessError(code, msg)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cause := rpcStatus.Error()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(cause, wrapMsg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in pratice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindUserById</span><span class="params">(userId <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    fine, err := rpc.BusinessAction(user)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, handleRpcError(err, <span class="string">"service unavailable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，如果是更靠近最终用户的“边界”，又该如何处理呢？</p>
<p>很明确的就是，首先用户很大程度上是关心<strong>业务码</strong>的，至少用户使用的客户端是关心的；其次，用户是不关心什么连接字符串错误、<code>userId is required</code>等等这些错误的。所以，<strong>业务错误需要明确给出，前置检查错误只给开发者，其它不可预料的错误全部简单转换为“服务当前不可用”</strong>。</p>
<p>有几个简单的观点：</p>
<ul>
<li>有业务码错误的才需要对用户显示信息，其它的一律可显示为视为<strong>出错了，请稍后重试</strong></li>
<li>有业务码的，说明是非技术的错误，其他一切要么是<strong>bug</strong>，需要开发人员在上线前处理完毕，要么是运行错误，比如数据库异常。需要告诉用户的只有<strong>出错了，请稍后重试</strong>，不会也不能再告诉更多</li>
<li>身份证号格式不对，电话号格式不对，这种错误在严格意义上算是<strong>bug</strong>，应该在调用<code>API</code>前就检验好的。如果设计不那么严格，可以适当的返回业务码帮助一下，但也只是友情帮助，该客户端做的验证还是得做的</li>
</ul>
<p>我们来看最后一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/pkg/errors"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> ServiceUnavailableMessage = <span class="string">"service unavailable"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LoginReq <span class="keyword">struct</span> &#123;</span><br><span class="line">    Username <span class="keyword">string</span></span><br><span class="line">    Password <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Login</span><span class="params">(ctx context.Context, req LoginReq)</span> <span class="params">(*model.Credential, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> req.Username == <span class="string">""</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"username is required"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> req.Password == <span class="string">""</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"password is required"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// FindByUsername</span></span><br><span class="line">	<span class="comment">// maybe got business error: '[10011] user doesn't exists'</span></span><br><span class="line">	user, err := rpc.UserService.FindByUsername(req.Username)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> handleRpcError(err, ServiceUnavailableMessage)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// SignIn</span></span><br><span class="line">	<span class="comment">// maybe got business error: '[20001] account is disabled'</span></span><br><span class="line">	<span class="comment">// maybe got business error: '[20002] password is incorrect'</span></span><br><span class="line">	<span class="comment">// maybe got business error: '[20003] login place abnormal'</span></span><br><span class="line">	cred, err := rpc.AccountService.SignIn(user.Id, req.Password)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> handleRpcError(err, ServiceUnavailableMessage)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	credential := &amp;model.Credential&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> err := credential.Load(cred); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> errors.Wrap(err, ServiceUnavailableMessage)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> credential, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是非常常见的一种<code>API</code>服务的写法，我省去了一些不必要的细节，例如<code>Routing</code>或者<code>Response</code>相关的东西。其实和普通的微服务实现没有什么两样，除了几个小细节：</p>
<ul>
<li>对参数的校验还是必要的，不能因为微服务校验过参数，消费方就不做校验了</li>
<li>除了参数校验的错误，仍然需要对下游服务返回的业务错误同步的向上返回</li>
<li>除了参数错误和业务错误，其它的错误会包装成<code>service unavailable</code>，不向用户泄露任何的技术细节</li>
</ul>
<p>通常，在这种类型的服务中，会有一个类似中间件的东西，统一的处理一切的错误（或者，建议自己实现一个），或者叫全局的错误处理函数、生命周期钩子等等，总之在我们的<code>Login()</code>函数返回错误后，能够以统一的方式响应给用户端，那具体会是什么样呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">type</span> UserError <span class="keyword">struct</span> &#123;</span><br><span class="line">    ErrCode <span class="keyword">string</span> <span class="string">`json:"err_code"`</span></span><br><span class="line">    ErrMsg  <span class="keyword">string</span> <span class="string">`json:"err_msg"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleGlobalError</span><span class="params">(ctx HttpContext, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e, ok := err.(*BusinessError); ok &#123;</span><br><span class="line">            ue := &amp;UserError&#123;</span><br><span class="line">                ErrCode: e.Code,</span><br><span class="line">                ErrMsg:  e.Msg,</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ctx.Response.WriteJson(ue)</span><br><span class="line">            ctx.Response.SetStatus(<span class="number">400</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ue := &amp;UserError&#123;</span><br><span class="line">                ErrMsg:  err.Error(),</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ctx.Response.WriteJson(ue)</span><br><span class="line">            ctx.Response.SetStatus(<span class="number">500</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这个函数只是概念上的解释，具体到每一个不同的场景会有不同的<code>API</code>和方式。实际上，如果能够支持这种全局错误处理，那么<code>credential.Load(cred)</code>产生的错误实际都不用<code>Wrap</code>，只需在处理全局错误的时候，直接将非业务错误的<code>UserError</code>的<code>ErrMsg</code>设置成<code>service unavailable</code>就可以了，这也避免了处处都<code>errors.Wrap(err, ServiceUnavailableMessage)</code>，让简洁性更进一步。</p>
<p>如此，世界得以清静。</p>
<p>（完）</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Golang/">Golang</a><a href="/tags/error-handling/">error-handling</a><a href="/tags/microservice/">microservice</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/07/26/handle-error-gracefully-in-golang/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/02/15/shinetech-2018-security-training-summary/" title="shinetech 2018 security training summary" itemprop="url">shinetech 2018 security training summary</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2019-02-15T05:10:40.000Z" itemprop="datePublished"> Published 2019-02-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><strong>「关注软件开发中的安全」</strong></p>
<blockquote>
<p>18年10月底的时候，我在Shinetech Software内部做了一场在线的培训，主要关注的是在软件开发过程中，对于安全方面的工程实践，并不算是很深入的探讨，更多的是一些极不易察觉但又很常见的疏忽，这篇博客整理出来。</p>
</blockquote>
        
        
        <p class="article-more-link">
          
            <a href="/2019/02/15/shinetech-2018-security-training-summary/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/training/">training</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/security/">security</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/02/15/shinetech-2018-security-training-summary/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/02/retional-team-with-communication/" title="理性沟通的团队" itemprop="url">理性沟通的团队</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2017-03-02T13:33:00.000Z" itemprop="datePublished"> Published 2017-03-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>（部分整理自Shinetech 2016-10-19内部分享）</p>
<blockquote>
<p>《敏捷软件开发宣言》<br>我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：</p>
<p>个体和互动 高于 流程和工具<br>工作的软件 高于 详尽的文档<br>客户合作 高于 合同谈判<br>响应变化 高于 遵循计划</p>
<p>也就是说，尽管右项有其价值，我们更重视左项的价值。</p>
</blockquote>
<p>小而精的团队，往往更具有战斗力。我们提倡敏捷，也愿意相信它的价值，然而敏捷的实践却不仅仅是清晨站会、打打估算扑克那么简单。在我看来，其中最容易被忽视的一句便是：<code>尽管右项有其价值，我们更重视左项的价值</code>。如果一个开发者不写文档的理由是“我敏捷”，这就大错特错了，我所理解的敏捷，是关于『沟通』和『协作』的方式。<br>
        
        
        </p><p class="article-more-link">
          
            <a href="/2017/03/02/retional-team-with-communication/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/productivity/">productivity</a><a href="/tags/collaboration/">collaboration</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/03/02/retional-team-with-communication/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/24/functional-programming-skills/" title="函数式编程中的常用技巧" itemprop="url">函数式编程中的常用技巧</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2015-11-24T08:53:34.000Z" itemprop="datePublished"> Published 2015-11-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在Closure、Haskell、Python、Ruby这些语言越来越流行的今天，我们撇开其在数学纯度性上的不同，单从它们都拥有<code>一类函数</code>特性来讲，讨论函数式编程也显得很有意义。</p>
<p>一类函数为函数式编程打下了基础，虽然这并不能表示可以完整发挥函数式编程的优势，但是如果能掌握一些基础的函数式编程技巧，那么仍将对并行编程、声明性编程以及测试等方面提供新的思路。</p>
<p>很多开发者都有听过函数式编程，但更多是抱怨它太难，太碾压智商。的确，函数式编程中很多的概念理解起来都有一定的难度，最著名的莫过于<a href="https://en.wikipedia.org/wiki/Monad_(functional_programming" target="_blank" rel="noopener">单子</a>，但是通过一定的学习和实践会发现，函数式编程能让你站在一个更高的角度思考问题，并在某种层面上提升效率甚至是性能。我们都知道飞机比汽车难开，但是开飞机却明显比开汽车快，高学习成本的东西解决的大部分是高回报的需求，这不敢说是定论，但从实践来看这句话基本也正确。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener">wikipedia</a>上对于函数式编程的解释是这样的：</p>
<blockquote>
<p>In computer science, functional programming is a programming paradigm—a style of building the structure and elements of computer programs—that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data. </p>
</blockquote>
<p>翻译过来是这样的：</p>
<blockquote>
<p>在计算机科学中，函数式编程是一种编程范式，一种构建计算机结构和元素的风格，它将计算看作是对数学函数的求值，并避免改变状态以及可变数据。</p>
</blockquote>
<p>关键的其实就两点：不可变数据以及函数求值（表达式求值）。由这两点引申出了一些重要的方面。</p>
<h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p>FP中并没有变量的概念，东西一旦创建后就不能再变化，所以在FP中经常使用“值”这一术语而非“变量”。</p>
<p>不变性对程序并行化有着深远的影响，因为一切不可变意味着可以就地并行，不涉及竞态，也就没有了锁的概念。</p>
<p>不变性还对测试有了新的启发，函数的输入和输出不改变任何状态，于是我们可以随时使用REPL工具来测试函数，测试通过即可使用，不用担心行为的异常，不变性保证了该函数在任何地方都能以同样的方式工作。事实上，在函数式编程实践中，“编写函数、使用REPL工具测试，使用”三步曲有着强大的生产力。</p>
<p>不变性还对重构有了新的意义，因为它使得对函数的执行有了数学意义，于是乎重构本身成了对函数的化简。FP使代码的分析变的容易，从而使重构的过程也变的轻松了许多。</p>
<h3 id="声明性风格"><a href="#声明性风格" class="headerlink" title="声明性风格"></a>声明性风格</h3><p>FP程序代码是一个描述期望结果的表达式，所以可以很轻松、安全的将这些表达式组合起来，在隐藏执行细节的同时隐藏复杂性。可组合性是FP程序的基本能力之一，所以要求每个组合子都有良好的语义，这和声明式风格不谋而合。</p>
<p>我们经常写<code>SQL</code>，它就是一种声明性的语言，声明性只提出<code>what to do</code>而不解决<code>how to do</code>的问题，例如下面：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> create_date &gt; <span class="string">'2015-11-21'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> create_date <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
<p>省去了具体的数据库查询细节，我们只需要告诉数据库要orders表里创建日期大于11月21号的数据，并只要id和amout两个字段，然后按创建日期降序。这是一种典型的声明性风格。</p>
<blockquote>
<p>是的，我同意靠嘴是解决不了任何问题的，what to do提出来后总得有地方或有人实现具体的细节，也就是说总是需要有how to do的部分来支持。但是换个思路，假如你每天都在写foreach语句来遍历某个集合数据，难道你没有想过你此时正在重复的how to do吗？就不能将某种通用的“思想”提取出来复用吗？假如你可以提取，那么你会发现，这个提取出来的词语（或函数名）已经是一种what to do层面的思想了。</p>
</blockquote>
<p>再比如，对于一个整型数据集合，我们要通过C#遍历并拿到所有的偶数，典型的命令式编程会这么做：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> sourceList) &#123;</span><br><span class="line">    <span class="keyword">if</span>(item % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        result.Add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>这对很多人来说都很轻松，因为就是在按照计算机的思维一步一步的指挥。那么声明性的风格呢？</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">return</span> sourceList.Where(item =&gt; item %<span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// or LINQ style</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">from</span> item <span class="keyword">in</span> sourceList <span class="keyword">where</span> item % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">select</span> item;</span><br></pre></td></tr></table></figure>
<p>甚至更进一步，假设我们有声明性原语，可以做到更好：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="comment">// if we already defined an atom function like below:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">NumberIsEven</span>(<span class="params"><span class="keyword">int</span> number</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then we can re-use it directly.</span></span><br><span class="line"><span class="keyword">return</span> sourceList.Where(NumberIsEven);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说句题外话，我有个数据库背景很深的C#工程师同事，第一次见到LINQ时一脸不屑的说：C#的LINQ就是抄SQL的。其实我并没有告诉它C#的LINQ借鉴的是FP的高阶函数以及monad，只是和SQL长的比较像而已。当然我并不排除这可能是为了避免新的学习成本所以选用了和SQL相近的关键字，但是LINQ的启蒙却真的不是SQL。</p>
</blockquote>
<blockquote>
<p>我更没有说GC、闭包、高阶函数等先进的东西并不是.NET抄Java或者谁抄谁，大家都是从50多年前的LISP以及LISP系的Scheme来抄。我似乎听到了apple指着ms说：你抄我的图形界面技术…</p>
</blockquote>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>在FP中，每个表达式都有对应的类型，这确保了表达式组合的正确性。表达式的类型可以是某种基元类型，可以是复合类型，当然，也可以是支持泛型类型的，例如F#、ML、Haskell。类型也为编译时检查提供了基础，同时，也让屌炸天的类型推断有了根据。</p>
<p>F#的类型推断要比C#强太多了，一方面是受益于ML及OCamel的影响，一方面是在CLR层面上泛型的良好设计。很多人并不知道F#的历史可以追溯到.NET第一个版本的发布（2002年），而当时F#作为一个研究项目，对泛型的需求很大，遗憾的是.NET第一版并没有从CLR层面支持泛型。所以，F#团队参与设计了.NET的泛型设计并加入到.NET 2.0开始的后续版本，这也同时让所有.NET语言获益。</p>
<p>那么我们以不同的视角审视一下泛型。何为泛型？泛型是一种代码重用的技术，它使用类型占位符来将真正的类型延迟到运行时再决定，类似一种类型模板，当需要的时候会插入真实的类型。我们换一个角度，将泛型理解为一种包装而非模板，它打包了某种具体的类型，使用类似F#的签名表达会是这样：<code>&#39;T -&gt; M&lt;&#39;T&gt;</code>，转变这种思维很重要，尤其是在编写F#的计算表达式（即Monad）时，经常会使用<strong>包装类</strong>这个术语。在C#中也可以看到类似的方面，例如<code>int?</code>其实是指<code>Nullable&lt;T&gt;</code>对<code>int</code>类型的包装。</p>
<h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p>由于整个程序就是一个大的表达式，计算机在不断的求值这个表达式的同时也就意味着我们的程序正在运行。那么很有挑战的一方面就是，程序该如何组织？</p>
<p>FP中没有语句的概念，就连常用的绑定值操作也是一个表达式而非语句。那么这一切如何实现呢？假设我们有下面这段C#代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="number">9</span>;</span><br></pre></td></tr></table></figure>
<p>我们有两个赋值语句（并且有先后依赖），如何用表达式的方式来重写？</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="comment">// we build this helper function for next use.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Eval</span>(<span class="params"><span class="keyword">int</span> binding, Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; continues</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> contineues(binding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then, below sample is totally one expression.</span></span><br><span class="line">Eval(<span class="number">11</span>, a =&gt; </span><br><span class="line">    <span class="comment">//now a is binding to 11</span></span><br><span class="line">    Eval(a + <span class="number">9</span>, b =&gt; b</span><br><span class="line">        <span class="comment">// now, b is binding to a + 9, </span></span><br><span class="line">        <span class="comment">// which is evaluate to 11 + 9</span></span><br><span class="line">    ));</span><br></pre></td></tr></table></figure>
<p>这里使用了函数闭包，我们会在接下来的柯里化部分继续谈到。通过使用continues（延续）技术以及闭包，我们成功的将赋值语句变了函数式的表达式，这也是F#中<code>let</code>的基本工作方式。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p><code>一类函数</code>特性使得高阶函数成为可能。何为高阶函数？高阶函数(higher-order function)就是指能函数自身能够接受函数，并可以返回函数的一种函数。我们来看下面两个例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C#</span></span><br><span class="line"><span class="keyword">var</span> filteredData = Products.Where(p =&gt; p.Price &gt; <span class="number">10.0</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello world."</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>C#中的<code>Where</code>接受了一个匿名函数（Lambda表达式），所以它是一个高阶函数，javascript的<code>SetInterval</code>函数接受一个匿名的回调函数，因而也是高阶的。</p>
<p>我们用一个更加有表现力的例子来说明高阶函数可以提供的强大能力：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> addBy value = <span class="keyword">fun</span> n -&gt; n + value</span><br><span class="line"><span class="keyword">let</span> add10 = addBy <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> add20 = addBy <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result11 = add10 <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> result21 = add20 <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>addBy</code>函数接受一个值value，并返回一个匿名函数，该匿名函数对参数n和闭包值value相加后返回结果。也就是说，<code>addBy</code>函数通过传入的参数，返回了一个经过定制的函数。</p>
<p>高阶函数使函数定制变的容易，它可以隐藏具体的执行细节，将可定制的部分（或行为）抽象出来并传给某个高阶函数使用。</p>
<blockquote>
<p>是的，这听起来很像是OO设计模式中的模板方法，在FP中并没有模板方法的概念，使用高阶函数就可以达到目的了。</p>
</blockquote>
<p>在下节的柯里化部分将会看到，这种定制函数的能力内建在很多FP语言中，Haskell、F#中都有提供。</p>
<p>在FP中最常用的就是<code>map</code>、<code>filter</code>、<code>fold</code>了，我们通过检查在F#中它们的签名就可以推测它们的用途：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map:    (&apos;a -&gt; &apos;b) -&gt; &apos;a list -&gt; &apos;b list</span><br><span class="line">filter: (&apos;a -&gt; bool) -&gt; &apos;a list -&gt; &apos;a list</span><br><span class="line">fold:   (&apos;a -&gt; &apos;b -&gt; &apos;a) -&gt; &apos;a -&gt; &apos;b list -&gt; &apos;a</span><br></pre></td></tr></table></figure>
<p><code>map</code>通过对列表中的每个元素执行参数函数，得到相应的结果，是一种映射。C#对应的操作为<code>Select</code>。<br><code>filter</code>通过对列表中的每个元素执行参数函数，将结果为<code>true</code>的元素返回，是一种过滤。C#对应的操作为<code>Where</code>。<br><code>fold</code>相对复杂一些，我们可以理解为一种带累加器的化简函数。C#对应的操作为<code>Aggregate</code>。</p>
<p>之前我们提到过，泛型本身可以看做是某种类型的包装，所以如果我们面对一个<code>&#39;T list</code>，那么我们可以说这是一个<code>&#39;T</code>类型的<strong>包装</strong>，注意此处并没有说它是个范型列表。于是乎，我们对<code>map</code>有了一种更加高层次的理解，我们可以尝试一种新的签名：<code>(&#39;a -&gt; &#39;b) -&gt; M&lt;&#39;a&gt; -&gt; M&lt;&#39;b&gt;</code>，这就是说，<code>map</code>将拆开包装，对包装内类型进行转换产生某种新的类型，然后再以同样的包装将其重新打包。</p>
<p><code>map</code>也叫普通投影，请记住这个签名，我们在最后的延续一节将提出一个新的术语叫<strong>平展投影</strong>，到时候还会来对比<code>map</code>。</p>
<p>如果我们对两个甚至是三个包装类型的值进行投影呢？我们会猜想它的签名可能是这样：</p>
<ul>
<li>lift2: <code>(&#39;a -&gt; &#39;b -&gt; &#39;c) -&gt; M&lt;&#39;a&gt; -&gt; M&lt;&#39;b&gt; -&gt; M&lt;&#39;c&gt;</code></li>
<li>lift3: <code>(&#39;a -&gt; &#39;b -&gt; &#39;c -&gt; &#39;d) -&gt; M&lt;&#39;a&gt; -&gt; M&lt;&#39;b&gt; -&gt; M&lt;&#39;c&gt; -&gt; M&lt;&#39;d&gt;</code></li>
</ul>
<p>其实这便是FP中为人们广泛熟知的“提升”，它甚至可以称作是一种函数式设计模式。提升允许将一个对值进行处理的函数转换为一个在不同设置中完成相同任务的函数。</p>
<h2 id="柯里化和部分函数应用"><a href="#柯里化和部分函数应用" class="headerlink" title="柯里化和部分函数应用"></a>柯里化和部分函数应用</h2><blockquote>
<p>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p>
</blockquote>
<p>这段定义有些拗口，我们借助前面的一个例子，并通过javascript来解释一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addBy</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n + value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add10 = addBy(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> result11 = add10(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>javascript版本完全是F#版本的复刻，如果我们想换个方式来使用它呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result11 = addBy(<span class="number">10</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这明显是不可以的（并不是说不能调用，而是说结果并非所期望的），因为<code>addBy</code>函数只接收一个参数。但是柯里化要求我们函数只能接受一个参数，该如何处理呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result11 = addBy(<span class="number">10</span>)(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//             ~~~~~~~~~    return an anonymous fn(anonymousFn, e.g)</span></span><br></pre></td></tr></table></figure>
<p>如此就可以了，<code>addBy(10)</code>将被正常调用没有问题，返回的匿名函数又立即被调用<code>anonymousFn(1)</code>，结果正是我们所期望的。</p>
<p>假如javascript在调用函数时可以像Ruby和F#那样省略括号呢？我们会得到<code>addBy 10 1</code>，这和真实的多参数函数调用就更像了。在<code>addBy</code>函数内部，返回匿名函数时带出了<code>value</code>的值，这是一个典型的闭包应用。在<code>addBy</code>调用后，<code>value</code>值将在外部作用域中不可见，而在返回的匿名函数内部，<code>value</code>值仍然是可以采集到的。</p>
<blockquote>
<p>闭包（Closure）是词法闭包（Lexical Closure）或函数闭包（function closures）的简称，可参见<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming" target="_blank" rel="noopener">wikipedia</a>)上的详细解释。</p>
</blockquote>
<p>如此看来，是不是所有的多参数函数都能被柯里化呢？我们假想一个这样的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAddFn</span>(<span class="params">n1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n3</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n4</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> n1 + n2 + n3 + n4;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = fakeAddFn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//           ~~~~~~~~~~~~           now is function(n2)</span></span><br><span class="line"><span class="comment">//                       ~~~        now is function(n3)</span></span><br><span class="line"><span class="comment">//                          ~~~     now is function(n4)</span></span><br><span class="line"><span class="comment">//                             ~~~  return n1 + n2 + n3 + n4</span></span><br></pre></td></tr></table></figure>
<p>但是这样又显得非常麻烦并且经常会出现智商不够用的情况，如果语言能够内建支持currying，那么情况将乐观许多，例如F#可以这样做：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fakeAddFn n1 n2 n3 n4 = n1 + n2 + n3 + n4</span><br></pre></td></tr></table></figure>
<p>编译器将自动进行柯里化，完全展开形式如下：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fakeAddFn n1 = <span class="keyword">fun</span> n2 -&gt; <span class="keyword">fun</span> n3 -&gt; <span class="keyword">fun</span> n4 -&gt; n1 + n2 + n3 + n4</span><br></pre></td></tr></table></figure>
<p>并且F#调用函数时可以省略括号，所以对<code>fakeAddFn</code>的调用看上去就像是对多参数函数的调用：<code>let result = fakeAddFn 1 2 3 4</code>。到这里你也许会问，currying到底有什么用呢？答案是：部分函数应用。</p>
<p>由于编译器自动进行currying，所以每一个函数本身是可以部分调用的，举个例子，F#中的<code>+</code>运算符其实是一个函数，定义如下：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (+) a b = a + b</span><br></pre></td></tr></table></figure>
<p>利用前面的知识我们知道它的完全形式是这样：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (+) a = <span class="keyword">fun</span> b -&gt; a + b</span><br></pre></td></tr></table></figure>
<p>所以我们自然可以编写一个表达式只给<code>+</code>运算符一个参数，这样返回的结果是另一个接受一个参数的函数，之后，再传入剩余一个参数。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add10partial = (+) <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> result = add10partial <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>同时，由于<code>add10partial</code>函数的签名是<code>int -&gt; int</code>，所以可以直接用于<code>List.map</code>函数，如下：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add10partial = (+) <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> result = someIntList |&gt; List.map add10partial</span><br><span class="line"></span><br><span class="line"><span class="comment">// upon expression equals below </span></span><br><span class="line"><span class="comment">// let result = List.map add10partial someIntList</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or, more magic, make List.map partially:</span></span><br><span class="line"><span class="keyword">let</span> mapper = (+) <span class="number">10</span> |&gt; List.map</span><br><span class="line"><span class="keyword">let</span> sameResult = someIntList |&gt; mapper</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>|&gt;</code>运算符本身也是一个函数，简单的定义就是<code>let (|&gt;) p f = f p</code>，这种类似管道的表达式为FP提供了更高级的表达。</p>
</blockquote>
<p>我们知道FP是以<code>Alonzo Church</code>的lambda演算为理论基础的，lambda演算的函数都是接受一个参数，后来<code>Haskell Curry</code>提出的currying概念为lambda演算补充了表示多参数函数的能力。</p>
<h2 id="递归及优化"><a href="#递归及优化" class="headerlink" title="递归及优化"></a>递归及优化</h2><p>由于FP没有可变状态的概念，所以当我们以OO的思维来思考时会觉得无从下手，在这个时候，递归就是强有力的武器。</p>
<blockquote>
<p>其实并不是说现代的FP语言没有可变状态，其实几乎所有的FP语言都做了一定程度的妥协，诸如F#构建在.NET平台之上，那么在与BCL提供的类库互操作时避免不了要涉及状态的改变，而且如果全部使用递归的方式来处理可变状态，在性能上也是一个严峻的考验。所以F#其实提供了可变操作，但是需要明确的使用<code>mutable</code>关键字来声明或者使用<code>引用单元格</code>。</p>
</blockquote>
<p>以一个典型的例子为开始，我们实现一个Factorial阶乘函数，如果以命令式的方式来实现是这样的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Factorial</span>(<span class="params"><span class="keyword">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">2</span>; index &lt;= n; index++) &#123;</span><br><span class="line">        result = result * index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是典型的how to do，我们开始尝试用递归并且尽可能的用表达式来解决问题：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Factorial</span>(<span class="params"><span class="keyword">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span></span><br><span class="line">        ? <span class="number">1</span></span><br><span class="line">        : n * Factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是可以正常工作的，但是如果n的值为10,000呢？会栈溢出。此时便出现了本节要解决的第二个问题：递归优化。</p>
<p>那么这段递归代码为什么会溢出？我们展开它的调用过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n               (n-1)       ...      3         2       1  // state</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">n*f(n-1) -&gt; (n-1)*f(n-2) -&gt; ... -&gt; 3*f(2) -&gt; 2*f(1) -&gt; 1  // stack in</span><br><span class="line">                                                       |  </span><br><span class="line">n*r      &lt;-  (n-1)*(r-1) &lt;- ... &lt;-   3*2  &lt;-   2*1  &lt;- 1  // stack out</span><br></pre></td></tr></table></figure>
<p>简单来说，因为当<code>n</code>大于1时，每次递归都卡在了<code>n * _</code>上，必须等后面的结果返回后，当前的函数调用栈才能返回，久而久之就会爆栈。那可以做点什么呢？如果我们在递归调用的时候不需要做任何工作（例如不去乘以n），那么就可以从当前的调用栈直接跳到下一次的调用栈上去。这称为尾递归优化。</p>
<p>我们考虑，当前调用时的n，如果以某种形式直接带到下一次的递归调用中，那么是不是就达到了目的？没错，这就是累加器技术，来尝试一下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">FactorialHelper</span>(<span class="params">acc, n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span></span><br><span class="line">        ? acc</span><br><span class="line">        : FactorialHelper(acc * n, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Factorial</span>(<span class="params"><span class="keyword">int</span> n</span>)</span> &#123; <span class="keyword">return</span> FactorialHelper(<span class="number">1</span>, n); &#125;</span><br></pre></td></tr></table></figure>
<p>C#毕竟没有F#那么方便的内嵌函数支持，所以我们声明了一个Helper函数用来达到目的，对应的F#实现如下：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> factorial n =</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> helper acc n' =</span><br><span class="line">        <span class="keyword">if</span> n' &lt;= <span class="number">1</span> <span class="keyword">then</span> acc</span><br><span class="line">        <span class="keyword">else</span> helper (acc * n') (n' - <span class="number">1</span>)</span><br><span class="line">    helper <span class="number">1</span> n</span><br></pre></td></tr></table></figure>
<p>下面的示意表达了我们想达到的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">init        f(1, n)             // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">n           f(n, n-1)           // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">n-1         f(n*(n-1), n-2)     // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">...         ...                 // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">3           f((k-2), 2)         // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">2           f((k-1), 1)         // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">1           k                   // return result</span><br></pre></td></tr></table></figure>
<p>可以看到，调用展开成尾递归的形式，从而避免了栈溢出。尾递归是一项基本的递归优化技术，其中关键的就是对累加器的使用。几乎所有的递归函数都可以优化成尾递归的形式，所以掌握这项技能对编写FP程序是有重要的意义的。</p>
<p>假如我们遇到的是一个非常庞大的列表需要处理，例如找到最大数或者列表求和，那么尾递归技术也将会让我们避免在深度的遍历时发生栈溢出的情形。</p>
<p>在前面我们说过<code>fold</code>是一种自带累加器的化简函数，那么列表求和以及最大数查找是不是可以直接用<code>fold</code>来实现呢？我们来尝试一下。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> sum l = l |&gt; List.fold (+) <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> times l = l |&gt; List.fold <span class="comment">(*) 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">let max l = </span></span><br><span class="line"><span class="comment">    let compare s e = if s &gt; e then s else e</span></span><br><span class="line"><span class="comment">    l |&gt; List.fold compare 0</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>fold</code>抽取了遍历并化简的核心步骤，仅将需要自定义的部分以参数的形式开放出来。这也是高阶函数组合的威力。</p>
<blockquote>
<p>还有一个和<code>fold</code>很类型的术语叫<code>reduce</code>，它和<code>fold</code>的唯一区别在于，<code>fold</code>的累加器需要一个初始值需要指定，而<code>reduce</code>的初始累加器使用列表的第一个元素的值。</p>
</blockquote>
<h2 id="记忆化"><a href="#记忆化" class="headerlink" title="记忆化"></a>记忆化</h2><p>我们知道大多数的FP函数是没有副作用的，这意味着以相同的参数调用同一函数将会返回相同的结果，那么如果有一个函数会被调用很多次，为什么不把对应参数的求值结果缓存起来，当参数匹配时直接返回缓存结果呢？这个过程就是记忆化，也是FP编程中常用的技巧。</p>
<p>我们以一个简单的加法函数为例：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add (a, b) = a + b</span><br></pre></td></tr></table></figure>
<p>注意这里我们使用了非currying化的参数，它是一个元组。接下来我们尝试使用记忆化来缓存结果：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> memoizedAdd = </span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> Dictionary&lt;_, _&gt;()</span><br><span class="line">    <span class="keyword">fun</span> p -&gt;</span><br><span class="line">        <span class="keyword">match</span> cache.TryGetValue(p) <span class="keyword">with</span></span><br><span class="line">        | <span class="keyword">true</span>, result -&gt; result</span><br><span class="line">        | _ -&gt;</span><br><span class="line">            <span class="keyword">let</span> result = add p</span><br><span class="line">            cache.Add(p, result)</span><br><span class="line">            result</span><br></pre></td></tr></table></figure>
<p>借助一个字典，将已经求值的结果缓存起来，下次以同样的参数调用时就可以直接从字典中检索出值，避免了重新计算。</p>
<p>我们甚至可以设计一个通用的记忆化函数，用于将任意函数记忆化：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> memorize f =</span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> Dictionary&lt;_, _&gt;()</span><br><span class="line">    <span class="keyword">fun</span> p -&gt;</span><br><span class="line">        <span class="keyword">match</span> cache.TryGetValue(p) <span class="keyword">with</span></span><br><span class="line">        | <span class="keyword">true</span>, result -&gt; result</span><br><span class="line">        | _ -&gt;</span><br><span class="line">            <span class="keyword">let</span> result = f p</span><br><span class="line">            cache.Add(p, result)</span><br><span class="line">            result</span><br></pre></td></tr></table></figure>
<p>那么前面的<code>memorizedAdd</code>函数可以写为<code>let memorizedAdd = memorize add</code>。这也是一个高阶函数应用的好例子。</p>
<h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><p>Haskell是一种纯函数语言，它不允许存在任何的副作用，并且在Haskell中，当表达式不必立即求值时是不会主动求值的，换句话说，是延迟计算的。而在大多数主流语言中，计算策略却是即时计算的（eager evaluation），这在某种极端情况下会不经意的浪费计算资源。有没有什么方法能够模拟类似Haskell中的延迟计算？</p>
<p>假如我们需要将表达式<code>n % 2 == 0 ? &quot;right&quot; : &quot;wrong&quot;</code>绑定到标识（即变量名）<code>isEven</code>上，例如<code>var isEven = n % 2 == 0 ? &quot;right&quot; : &quot;wrong&quot;;</code>，那么整个表达式是立即求值的，但是<code>isEven</code>可能在某种状况下不会被使用，有没有什么办法能在我们确定需要<code>isEven</code>时再计算表达式的值呢？</p>
<p>假如我们将<code>isEven</code>绑定到某种结构上，这个结构知道如何求值，并且是按需求值的，那么我们的目的就达到了。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">var</span> isEven = <span class="keyword">new</span> Lazy&lt;<span class="keyword">string</span>&gt; (() =&gt; n % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">"right"</span> : <span class="string">"wrong"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> isEven = <span class="keyword">lazy</span> (<span class="keyword">if</span> n % <span class="number">2</span> = <span class="number">0</span> <span class="keyword">then</span> <span class="string">"right"</span> <span class="keyword">else</span> <span class="string">"wrong"</span>)</span><br></pre></td></tr></table></figure>
<p>当使用<code>isEven</code>时，C#可以直接使用<code>isEven.Value</code>来即时求值并返回结果，而F#的使用方式也是一样的<code>isEven.Value</code>。</p>
<p>还有一种更加通用的方式来实现惰性求值，就是通过函数，函数表达了某种可以得到值的方式，但是需要调用才能得到，这和惰性求值的思想不谋而合。我们可以改写上面的例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">var</span> isEven = (Func&lt;<span class="keyword">string</span>&gt;)(() =&gt; n % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">"right"</span> : <span class="string">"wrong"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> isEven = <span class="keyword">fun</span> () -&gt; <span class="keyword">if</span> n % <span class="number">2</span> = <span class="number">0</span> <span class="keyword">then</span> <span class="string">"right"</span> <span class="keyword">else</span> <span class="string">"wrong"</span></span><br></pre></td></tr></table></figure>
<p>这样，在需要使用<code>isEven</code>的值时就是一个简单的函数调用，C#和F#都是<code>isEven()</code>。</p>
<h2 id="延续"><a href="#延续" class="headerlink" title="延续"></a>延续</h2><p>如果你之前使用过jQuery，那么在某种程度上已经接触过延续的概念了。<br>通过jQuery发起ajax调用其实就是一种延续：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('http://test.com/data.json', function(data) &#123;</span><br><span class="line">    <span class="comment">// processing.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>ajax调用成功后会调用匿名回调函数，而此函数表达了我们希望ajax调用成功后继续执行的行为，这就是延续。</p>
<p>现在，我们回顾一下，在概述-表达式求值一节，我们为了将两个C#赋值语句改写成表达式的方式，新增了一个<code>Eval</code>函数：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Eval</span>(<span class="params"><span class="keyword">int</span> binding, Action&lt;<span class="keyword">int</span>&gt; continues</span>)</span> &#123;</span><br><span class="line">    contineues(binding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它也是一种延续，指定了在<code>binding</code>求值后继续执行延续的行为，我们将它稍做修改：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">public</span> TOutput binding&lt;TEvalValue, TOutput&gt;(</span><br><span class="line">    TEvalValue evaluation, </span><br><span class="line">    Func&lt;TEvalValue, TOutput&gt; continues) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> continues(evaluation());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> binding v cont = cont v</span><br><span class="line"><span class="comment">// binding: 'a -&gt; cont:('a -&gt; 'b) -&gt; 'b</span></span><br></pre></td></tr></table></figure>
<p>于是我们可以模拟<code>let</code>的工作方式：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line">binding <span class="number">11</span> (<span class="keyword">fun</span> a -&gt; printfn <span class="string">"%d"</span> a)</span><br></pre></td></tr></table></figure>
<p>那么延续这种技术在实践中有什么用途呢？你可以说它就是个回调函数，这没有问题。深层次的理解在于，它延后了某种<strong>行为</strong>且该行为对上下文有依赖。</p>
<p>我们考虑这样一个场景，假设我们有一颗树需要遍历并求和，例如：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">NumberTree</span> </span>=</span><br><span class="line">    | Leaf <span class="keyword">of</span> int</span><br><span class="line">    | Node <span class="keyword">of</span> NumberTree * NumberTree</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> sumTree tree =</span><br><span class="line">    <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">    | Leaf(n)           -&gt; n</span><br><span class="line">    | Node(left, right) -&gt; sumTree(left) + sumTree(right)</span><br></pre></td></tr></table></figure>
<p>那么问题来了，我们显然可以发现当树的层级太深时<code>sumTree</code>函数会发生栈溢出，我们也自然而然的想到了使用尾递归来优化，但是当我们在尝试做优化时会发现，然并卵。这就是一个无法使用尾递归的场景。</p>
<p>核心的诉求在于，我们希望进行尾递归调用（<code>sumTree(left)</code>），但在尾递归调用完成之后，还有需要执行的代码（<code>sumTree(right)</code>）。延续为我们提供了一种手段，在函数调用结束后自动调用指定的行为（函数），于是当前正在编写的函数便仅包含一次递归调用了。我们仍然可以将它看作是一种累加器技术，区别在于，之前是累加值，而延续是累加行为。</p>
<p>我们尝试为<code>sumTree</code>递归函数加上延续功能：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> sumTree tree continues =</span><br><span class="line">    <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">    | Leaf(n) -&gt; continues n</span><br><span class="line">    | Node(left, right) -&gt;</span><br><span class="line">        sumTree left (<span class="keyword">fun</span> leftSum -&gt; </span><br><span class="line">            sumTree right (<span class="keyword">fun</span> rightSum -&gt; </span><br><span class="line">                continues(leftSum + rightSum)))</span><br></pre></td></tr></table></figure>
<p>此时，<code>sumTree</code>的签名从<code>NumberTree -&gt; int</code>变成了<code>NumberTree -&gt; (int -&gt; &#39;a) -&gt; &#39;a</code>。<code>Node(left, right)</code>分支现在变成了单个函数的调用，所以它是尾递归优化的，每次计算时都会将结束后需要继续执行的行为以函数的方式指定，直到整个递归完成。</p>
<p>使用时，可以以延续的方式来调用<code>sumTree</code>函数，也可以像往常一样从返回值获取结果：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="comment">// continues way:</span></span><br><span class="line">sumTree sampleTree (<span class="keyword">fun</span> result -&gt; printfn <span class="string">"result: %d"</span> result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// normal way:</span></span><br><span class="line"><span class="keyword">let</span> result = sumTree sampleTree (<span class="keyword">fun</span> r -&gt; r)</span><br></pre></td></tr></table></figure>
<p>我们甚至可以从延续的思想逐渐推导出类似<code>bind</code>的函数，我们将它与<code>map</code>的签名对比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bind</span><br><span class="line">(&apos;a -&gt; M&lt;&apos;b&gt;) -&gt; M&lt;&apos;a&gt; -&gt; M&lt;&apos;b&gt;</span><br><span class="line">// map</span><br><span class="line">(&apos;a -&gt; &apos;b)    -&gt; M&lt;&apos;a&gt; -&gt; M&lt;&apos;b&gt;</span><br></pre></td></tr></table></figure>
<p>在高阶函数一节我们说过，<code>map</code>叫普通投影，而新的<code>bind</code>叫做平展投影，它是一种外层匹配模式，在C#中对应的操作是<code>SelectMany</code>，在F#中就是<code>bind</code>，是一种通用函数。</p>
<p>在前面我们定义了一个<code>binding</code>函数，我们稍微调整一下参数顺序，并把它和<code>bind</code>对比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// binding:</span><br><span class="line">(&apos;a -&gt; &apos;b)    -&gt; &apos;a -&gt; &apos;b</span><br><span class="line">// map:</span><br><span class="line">(&apos;a -&gt; &apos;b)    -&gt; M&lt;&apos;a&gt; -&gt; M&lt;&apos;b&gt;</span><br><span class="line">// bind:</span><br><span class="line">(&apos;a -&gt; M&lt;&apos;b&gt;) -&gt; M&lt;&apos;a&gt; -&gt; M&lt;&apos;b&gt;</span><br></pre></td></tr></table></figure>
<p>也就是说，如果我们为<code>&#39;a</code>加上某种包装，然后在bind里再做一些转换，那么我们就可以推导出<code>bind</code>函数。</p>
<p>C#的LINQ里<code>SelectMany</code>对应的就是<code>from</code>语句，比如下面：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> a <span class="keyword">in</span> l1</span><br><span class="line">             <span class="keyword">from</span> b <span class="keyword">in</span> l2</span><br><span class="line">             <span class="keyword">from</span> c <span class="keyword">in</span> l3</span><br><span class="line">             <span class="keyword">select</span> &#123; a, b &#125;</span><br></pre></td></tr></table></figure>
<p>这将转换成一系统嵌套的<code>SelectMany</code>调用，而<code>select</code>将转换为某种类似于<code>Return&lt;T&gt;()</code>的操作。对于F#来说，类似的代码可以用计算表达式（或者更加具体的序列表达式）：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = seq &#123;</span><br><span class="line">    <span class="keyword">let!</span> a = l1</span><br><span class="line">    <span class="keyword">let!</span> b = l2</span><br><span class="line">    <span class="keyword">let!</span> c = l3</span><br><span class="line">    <span class="keyword">return</span> (a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，似乎差不多该结束了，我们不打算继续深究<code>bind</code>，因为再往下走就到了<code>monad</code>了。事实上，大家已经看到了<code>monad</code>，F#的序列表达式以及C#中LINQ的一部分操作，就是<code>monad</code>。</p>
<hr>
<p>希望本文讲述的一些浅显的函数式编程概念可以在实践中对你有所帮助。最重要的是通过对思维的训练，可以从更加抽象的角度思考问题，提取问题最核心的部分以复用，将可变部分提出，从而使问题可组合，并且获得更好的表达性。</p>
<p>有关<code>monad</code>，推荐大家看看<a href="https://en.wikipedia.org/wiki/Erik_Meijer_%28computer_scientist%29" target="_blank" rel="noopener">Erik Meijer</a>大大在Channel9上的课程<a href="https://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals" target="_blank" rel="noopener">Functional Programming Fundamentals</a>，它同时也是<a href="https://github.com/Reactive-Extensions" target="_blank" rel="noopener">Rx</a>库的作者之一，以及LINQ的作者。</p>
<p>（完）</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/productivity/">productivity</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C#</a><a href="/tags/F/">F#</a><a href="/tags/Functional-Programming/">Functional-Programming</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/24/functional-programming-skills/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/10/14/improve-work-efficiency-and-happiness-2/" title="提高工作效率与幸福度-工具篇" itemprop="url">提高工作效率与幸福度-工具篇</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2015-10-14T05:35:42.000Z" itemprop="datePublished"> Published 2015-10-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这篇文章略难产，事实上距离”基本篇”的发布已然过去了小半年了，生孩子生到这份儿上也真是够够的了。那时天还是辣么蓝，微风徐徐鸟语花香，我独自抚摸着猫在键盘上激情的写作……后来，把下篇给忘了。据说刨坑不填的都得拉去烧死，我想了想觉得挺疼的，所以抓紧补上吧。</p>
<p>先回顾一下基本篇阐述的基本事实：</p>
<ul>
<li>邮件 is bitch</li>
<li>电话有时让对方不爽</li>
<li>信息的组织与提取不是容易的事情</li>
</ul>
<p>对于这几个bitch上篇给出了简单的建议，不妨作为一种过渡手段，但是身为现代人类，有辣么多好用而且几乎都是免费的工具可以使用，why not?</p>
<blockquote>
<p>不过说到底，再牛逼的工具也不能解决人懒惰的问题，工具只能让你更好的做事，不能帮你做事，躺着就把钱赚了的事不多，要想清楚。</p>
</blockquote>
        
        
        <p class="article-more-link">
          
            <a href="/2015/10/14/improve-work-efficiency-and-happiness-2/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/productivity/">productivity</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/10/14/improve-work-efficiency-and-happiness-2/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/04/28/improve-work-efficiency-and-happiness-1/" title="提高工作效率与幸福度-基本篇" itemprop="url">提高工作效率与幸福度-基本篇</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2015-04-28T11:12:46.000Z" itemprop="datePublished"> Published 2015-04-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>现代企业有着复杂的协作，人与人间的信息交流、资源间的协调分配，各种碎片信息的整理，这还不包含人际关系处理等等狗血剧情，每天的工作被打散成七零八落，看似忙成狗，其实就是狗一般的活着，仰望天空，噢shit一天又特么过去了，好多事儿还没做完……</p>
<p>有没有办法通过改善自身来提高生产力？不妨看看这些行之有效的建议能否帮到你。要知道，这些建议来自于脑力协作最为密集的软件开发行业，对其实生产制造或者创造性工作也有着不错的借鉴意义。毕竟，自身的生产力提高了，才能从容的面对复杂的工作，从而让自己的竞争力更上一层台阶。</p>
<p>本文共分两部分：</p>
<ul>
<li>《提高工作效率与幸福度-基本篇》，讲述老百姓自己的故事</li>
<li>《提高工作效率与幸福度-工具篇》，讲述新人类的工作方式
        
        
        <p class="article-more-link">
          
            <a href="/2015/04/28/improve-work-efficiency-and-happiness-1/#more">Read More</a>
          
       </p>
    </li></ul></div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/productivity/">productivity</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/04/28/improve-work-efficiency-and-happiness-1/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/04/27/who-is-developer/" title="程序员是怎样一群人" itemprop="url">程序员是怎样一群人</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2015-04-27T11:14:51.000Z" itemprop="datePublished"> Published 2015-04-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>深夜，厚重的眼镜背后闪烁着淡淡的光，几个小时的努力没有白费，他拿起旁边的杯子将咖啡一饮而尽，角落里已经堆砌成山的红牛，四周弥漫一股着泡面的味道，就在这时，他用厚重的低音大骂一声：艹，这个Bug终于解决了，然后点燃了一支软盒的中华，蓬头垢面的离开公司。窗外，已经开始泛白，他找到一个卖煎饼的地方，要了份顶配版煎饼鸡蛋，三口并作两口吃完。此时已经到了上班的高峰，他路过望京SOHO，猥琐的朝里看了看，希望看看外表鲜丽的小姑娘能使他疲惫的身心得到一丝丝的宽慰。正当沉醉其中时，电话响了：快点回来，客户说线上系统挂了，让赶紧看看！他紧了紧衣领，仰头看了看灰色的天空，感觉，眼角有东西湿润了……</p>
</blockquote>
<p>可能这是很多人眼中的程序员，但你也很难想像这段诗一般的故事也出自于一个程序员之手。</p>
<p>程序员究竟是一种什么物种？其实他们一点儿也不神秘，他们自嘲为码农，自嘲没有妹子，自嘲是过劳死的一群人，但其实这只是他们极客精神的一种表现。<br>我认识很多的程序员，智力正常言谈得体，没有一丝木讷的痕迹，他们除了写得一手好码，还能淫得一首好诗。他们谈古论今，从三国到ChinaJoy，从文化艺术到岛国电影，自由的在神与屌之单穿梭往复，就像他们极客的影子一般，如影随形。<br>
        
        
        </p><p class="article-more-link">
          
            <a href="/2015/04/27/who-is-developer/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/joke/">joke</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/04/27/who-is-developer/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/12/03/async-programming/" title="使用异步编程" itemprop="url">使用异步编程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2014-12-03T03:50:18.000Z" itemprop="datePublished"> Published 2014-12-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>现代的应用程序面临着诸多的挑战，如何构建具有可伸缩性和高性能的应用成为越来越多软件开发者思考的问题。随着应用规模的不断增大，业务复杂性的增长以及实时处理需求的增加，开发者不断尝试榨取硬件资源、优化。</p>
<p>在不断的探索中，出现了很多简化场景的工具，比如提供可伸缩计算资源的<a href="http://aws.amazon.com/cn/s3/" target="_blank" rel="noopener">Amazon S3</a>、<a href="http://azure.microsoft.com/" target="_blank" rel="noopener">Windows Azure</a>，针对大数据的数据挖掘工具<a href="http://research.google.com/archive/mapreduce.html" target="_blank" rel="noopener">MapReduce</a>，各种CDN服务，云存储服务等等。还有很多的工程实践例如<a href="http://agilemanifesto.org/" target="_blank" rel="noopener">敏捷</a>、<a href="http://www.domaindrivendesign.org/" target="_blank" rel="noopener">DDD</a>等提供了指导。可以看到，将每个关注层面以服务的方式提供，成为了越来越流行的一种模式，或许我们可以激进的认为，这就是<a href="http://en.wikipedia.org/wiki/Service-oriented_architecture/" target="_blank" rel="noopener">SOA</a>。</p>
<p>开发者需要将不同的资源粘合在一起来提供最终的应用，这就需要协调不同的资源。</p>
<p>我们可以设想一个大的场景，开发者正在开发的一个用例会从用户的浏览器接收到请求，该请求会先从一个开放主机服务(OHS)获取必要的资源res1，然后调用本机的服务s1对资源res1进行适应的转换产生资源res2，接着以res2为参数调用远程的数据仓库服务rs1获取业务数据bs1，最后以bs1为参数调用本机的计算服务calc并经过10s产生最终的数据。</p>
<p>简单的用ASP.NET MVC 5表示就是这样的（这些代码是我瞎掰的）：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// notes: ASP.NET vNext changed MVC 5 usage, </span></span><br><span class="line"><span class="comment">// ActionResult now became IActionResult</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">CrazyCase</span>(<span class="params">UserData userData</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ticket = CrazyApplication.Ticket;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> ohsFactory = <span class="keyword">new</span> OpenHostServiceFactory(ticket);</span><br><span class="line">    <span class="keyword">var</span> ohs = ohsFactory.CreateService();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> ohsAdapter = <span class="keyword">new</span> OhsAdapter(userData);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> rs1 = ohs.RetrieveResource(ohsAdapter);</span><br><span class="line">    <span class="keyword">var</span> rs2 = _localConvertingService.Unitize(rs1);</span><br><span class="line">    <span class="keyword">var</span> bs1 = _remoteRepository.LoadBusinessData(rs2);</span><br><span class="line">    <span class="keyword">var</span> result = _calculationService.DoCalculation(bs1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> View(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可能是中等复杂度的一个场景，但是相信开发者已经意识到了这其中所涉及的复杂度。我们看到每一步都是依赖于前者所产生的数据，在这样一种场景之下，传统的多线程技术将极度受限，并且最顶层的协调服务将始终占用一个线程来协调每一步。</p>
<p>线程是要增加开销的，尤其是上下文的转换，别扯什么线程池了，创建线程的开销是节省了，上下文切换的开销才是要命的。</p>
<blockquote>
<p>经济不景气，能省点儿资源就省点儿吧。</p>
</blockquote>
<hr>
<p>所以我们该怎么办？纵向扩展给服务器加多点内存？横向扩展上负载均衡？别闹了我们又不是民工，想问题不要太简单粗暴。解决的办法就是，异步，而且我们这篇也只讨论异步这一种技术。</p>
<h2 id="为什么使用异步"><a href="#为什么使用异步" class="headerlink" title="为什么使用异步"></a>为什么使用异步</h2><p>那么，异步的优势在哪里？这首先要和同步做一个对比。</p>
<p>还是开头那个场景，示例代码所展示的是使用同步阻塞的方式来一步一步的执行，如下示意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main) +++$----$------$--------$----------$+++</span><br><span class="line">         |   /|     /|       /|         /</span><br><span class="line">ohs )    $++$ |    / |      / |        /</span><br><span class="line">              |   /  |     /  |       /</span><br><span class="line">rs1 )         $++$   |    /   |      /</span><br><span class="line">                     |   /    |     /</span><br><span class="line">s1  )                $++$     |    /</span><br><span class="line">                              |   /</span><br><span class="line">calc)                         $++$</span><br><span class="line"></span><br><span class="line">notes:</span><br><span class="line">$ code point</span><br><span class="line">+ thread busy</span><br><span class="line">- thread blocked(means, wasted)</span><br></pre></td></tr></table></figure>
<p>可以明显的看到，当主线程发起各个service请求后，完全处于闲置占用的状态，所做的无非是协调任务间的依赖顺序。这里所说的占用，其实就是CPU的时间片。</p>
<p>我们为什么要等所有的子任务结束？因为任务间有先后顺序依赖。有没有更好的方式来规避等待所带来的损耗呢？考虑一个场景，正上着班呢，突然想起要在网上买个东西，那么打开京东你就顺利的下单了，事情并没有结束，你不会等快递的小哥给你送来东西以后再接着今天的工作吧？你会给快递留下你的联系方式，让他<strong>到了给你打电话</strong>(耗时的I/O任务)，然后你继续今天烧脑的编程任务(CPU密集型)。从人类的角度来看，这一定是最正常不过的，也就是要讨论的异步的方式。</p>
<blockquote>
<p>一定有人会提议单开一个线程做收快递的任务，我同意这是一种解决方案，但是如果用等效的人类角度的语言来说，就是你将大脑的资源分成了两半，一半在烧脑编程，一半在盯着手机发呆，脑利用率下降太明显。而用异步的方式，你不需要关注手机，因为手机响了你就自然得到了通知。<br>当然，你也可以任性的说，我就喜欢等快递来了再干活。if so，我们就不要做朋友了。</p>
</blockquote>
<p>所以我们可以有一个推论：异步所解决的，就是节省低速的IO所阻塞的CPU计算时间。</p>
<p>转换一下思路，我们使用异步非阻塞的方式来构建这段业务，并借助异步思想早已深入人心的<code>javascript</code>语言来解释，可以是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ohs = <span class="built_in">require</span>(<span class="string">'./anticorruption/OpenHostService'</span>);</span><br><span class="line"><span class="keyword">var</span> localConvertingService = <span class="built_in">require</span>(<span class="string">'./services/LocalConverting'</span>);</span><br><span class="line"><span class="keyword">var</span> remoteRepository = <span class="built_in">require</span>(<span class="string">'./repositories/BusinessData'</span>);</span><br><span class="line"><span class="keyword">var</span> calculationService = <span class="built_in">require</span>(<span class="string">'./services/Calculation'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userData = req.body;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// level1 nest</span></span><br><span class="line">    ohs.retrieveResource(userData, <span class="function"><span class="keyword">function</span>(<span class="params">err, rs1</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// level2 nest</span></span><br><span class="line">        localConvertingService.unitize(rs1, <span class="function"><span class="keyword">function</span>(<span class="params">err, rs2</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                <span class="comment">// error handling</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//level3 nest</span></span><br><span class="line">            remoteRepository.loadBusinessData(rs2, <span class="function"><span class="keyword">function</span>(<span class="params">err, bs1</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                    <span class="comment">// error handling</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//level4 nest</span></span><br><span class="line">                calculationService.doCalculation(bs1, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                        <span class="comment">// error handling</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    res.view(result);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看着一层又一层的花括号也是醉了，我们之后会讨论如何解嵌套。那么这段代码所反应的是怎样的事实呢？如下示意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main) +++$                           $+++</span><br><span class="line">          \                         /</span><br><span class="line">ohs )      $++$                    /</span><br><span class="line">               \                  /</span><br><span class="line">rs1 )           $++$             /</span><br><span class="line">                    \           /</span><br><span class="line">s1  )                $++$      /</span><br><span class="line">                         \    /</span><br><span class="line">calc)                     $++$</span><br><span class="line"></span><br><span class="line">notes:</span><br><span class="line">$ code point</span><br><span class="line">+ thread busy</span><br><span class="line">- thread blocked(means, wasted)</span><br></pre></td></tr></table></figure>
<p>由于异步解放了原始的工作线程，使CPU资源可以不被线程的阻塞而被浪费，从而可以有效的提高吞吐率。</p>
<h2 id="异步的使用场景"><a href="#异步的使用场景" class="headerlink" title="异步的使用场景"></a>异步的使用场景</h2><blockquote>
<p>技术和选择和使用场景有着很大的关系，每项技术不都是银弹，使用对的工具/技术解决对的问题是开发者的义务。</p>
</blockquote>
<p>开发者最多关注的是计算密集和I/O密集这两个维度，对于这两个维度往往有着不同的技术选型。</p>
<h3 id="计算密集型应用"><a href="#计算密集型应用" class="headerlink" title="计算密集型应用"></a>计算密集型应用</h3><p>何为计算密集型应用？下面两个人畜皆知的函数都是计算密集型的。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F#</span></span><br><span class="line"><span class="keyword">let</span> fibonacci n =</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> f a b n =</span><br><span class="line">        <span class="keyword">match</span> n <span class="keyword">with</span></span><br><span class="line">        | <span class="number">0</span> -&gt; a</span><br><span class="line">        | <span class="number">1</span> -&gt; b</span><br><span class="line">        | n -&gt; (f b (a + b) (n - <span class="number">1</span>))</span><br><span class="line">    f <span class="number">0</span> <span class="number">1</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> factorial n = </span><br><span class="line">    <span class="keyword">match</span> n <span class="keyword">with</span></span><br><span class="line">    | <span class="number">0</span> -&gt; <span class="number">1</span></span><br><span class="line">    | n -&gt; n * factorial (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>尤其是第二个阶乘函数，如果在调用的时候不小心手抖多加了几个0，基本上可以出去喝个咖啡谈谈理想聊聊人生玩一天再回来看看有没有算完了。</p>
<p>简而言之，计算密集型的任务是典型的重度依赖CPU/GPU，不涉及磁盘、网络、输入输出的任务。游戏中场景渲染是计算密集的，MapReduce中的<code>Reduce</code>部分是计算密集的，视频处理软件的实时渲染是计算密集的，等等。</p>
<p>在这样的场景之下，异步是没有太大的优势的，因为计算资源就那么多，不增不减，用多线程也好用异步流也好，CPU永远处于高负荷状态，这病不能治，解决方案只能是：</p>
<ul>
<li>横向的集群方案</li>
<li>纵向的升级主机CPU或采用更快的GPU</li>
<li>优化算法，使之空间/时间成本降低</li>
</ul>
<p>但是有一种场景是可以考虑使用异步的，考虑一个分布式的计算场，一个计算任务发起后，协调者需要等待所有的计算节点子结果集返回后者能做最后的结果化简。那么此时，虽然场景是计算密集的，但是由于涉及到任务的依赖协调，采用异步的方式，可以避免等待节点返回结果时的阻塞，也可以避免多线程方式的上下文切换开销，要知道在这样的场景下，上下文切换的开销是可以大的惊人的。</p>
<p>相似的场景还有，一个桌面应用，假设点击界面上一个按钮之后会进行大量的计算，如果采用同步阻塞的方式，那么当计算完成之前UI是完全阻塞的跟假死一样，但是如何使用异步的方式，则不会发生UI阻塞，计算在结束后会以异步的方式来更新界面。还记得WinForm编程中的<code>BeginInvoke</code>和<code>EndInvoke</code>吗？虽然它们的实现方式是以单独线程的方式来实现异步操作的，但是这仍然属于异步流控制的范畴。</p>
<blockquote>
<p>异步的实现方式有很多，可以使用已有的线程技术(Rx和C#的async/await就是使用这种方式)，也可以使用类似于libuv之类的I/O异步封装配合事件驱动(node就是使用这种方式)。并于异步流控制的部分我们之后会讨论。</p>
</blockquote>
<p>所以如果你的应用是计算密集型的，在充分分析场景的前提下可以适当的采用异步的方式。大部分的计算密集型场景是不用介入异步控制技术的，除非它可以显著改善应用的流程控制能力。</p>
<h3 id="I-O密集型应用"><a href="#I-O密集型应用" class="headerlink" title="I/O密集型应用"></a>I/O密集型应用</h3><p>何为I/O密集型应用？Web服务器天然就是I/O密集型的，因为有着高并发量与网络吞吐。文件服务器和CDN是I/O密集型的，因为高网络吞吐高磁盘访问量。数据库是I/O密集型的，涉及磁盘的访问及网络访问。说到底，一切和输入输出相关的场景都是I/O密集型的。</p>
<p>I/O囊括的方面主要是两方面：</p>
<ul>
<li>网络访问</li>
<li>磁盘读写</li>
</ul>
<p>简单粗暴的解释，就是接在主板南桥上的设备的访问都属于I/O。多提一句，内存是直接接在北桥上的，这货，快。</p>
<p>开发者遇到最多的场景便是Web应用和数据库的高并发访问。其它的服务调用都属于网络I/O，可归为一类。</p>
<p>典型的就是Web服务器接收到了HTTP请求，然后具体的Web框架会单开一个线程服务这个请求。因为HTTP是构建在TCP之上的，所以在请求结束返回结果之前，socket并没有关闭，在windows系统上这就是一个句柄，在*nix之类的posix系统上这就是一个文件描述符，都是系统资源紧张的很。这是硬性的限制，能打开多少取决与内存与操作系统，我们暂且不关注这部分。该线程如果采用同步的方式，那么它程的生命周期会吻合socket的生命周期，期间不管是访问文件系统花了10s导致cpu空闲10s的时间片，还是访问数据库有3s的时间片空隙，这个线程都不会释放，就是说，这个线程是专属的，即便是使用线程池技术，该占还得占。</p>
<p>这有点像是银行的VIP专线，服务人员就那么多，如果每人服务一个VIP且甭管人家在聊人生聊理想还是默默注视，后面人就算是VIP也得等着，因为没人可以服务你了。</p>
<p>那么我们继续深入，线程也是一种相对昂贵的资源，虽然比创建进程快了太多，但是仍然有限制。windows的32位操作系统默认每进程可使用2GB用户态内存（64bit是8Tb用户态内存, LoL），每个线程有1Mb的栈空间（能改，但不建议。）；*nix下是8Mb栈空间，32位的进程空间是4Gb，64位则大到几近没有用户态内存限制。我们可以假定32位系统下一个合理的单进程线程数量：1500。那么一个进程最大的并发量就是1500请求了，抛开多核不谈，这1500个线程就算轮班倒，并发量不会再上去了，因为一个socket一个线程。如果每个请求都是web服务器处理1s加访问数据库服务器3s，那么时钟浪费率则大的惊人。况且，1500个线程的上下文切换想想都是<a href="http://www.zhihu.com/question/23544144" target="_blank" rel="noopener">开心，开了又开</a>。</p>
<p>不幸的是，之前的web服务器都是这么干的。此时我们思考，如果采用异步的方式，那3s的阻塞完全可以规避，从而使线程轮转的更快，因为1s的处理时间结束后线程返回线程池然后服务于另一个请求，从而整体提高服务器的吞率。</p>
<blockquote>
<p>事实上，node压根就没有多线程的概念，使用事件循环配合异步I/O，一个线程总够你甩传统的Web服务器吞吐量几条街。没错，请叫我node雷锋。</p>
</blockquote>
<p>再继续深入异步编程前，我们先理一理几个经常混淆的概念。</p>
<h2 id="一些概念的区别"><a href="#一些概念的区别" class="headerlink" title="一些概念的区别"></a>一些概念的区别</h2><h3 id="多核与多线程"><a href="#多核与多线程" class="headerlink" title="多核与多线程"></a>多核与多线程</h3><p>多核是一种物理上的概念，即指主机所拥有的物理CPU核心数量，<code>总核心数 = CPU个数 * 每个CPU的核心数</code>。每个核心是独立的，可以同时服务于不同的进程/线程。</p>
<p>多线程是一种操作系统上的概念，单个进程可能创建多个线程来达到细粒度进行流程控制的目的。操作系统的核心态调度进程与线程，在用户态之下其实还可以对单个线程有更细粒度的控制，这称之为<code>协程（coroutine）</code>或<code>纤程（fibers）</code>。</p>
<p>多线程是指在单个进程空间内通过操作系统的调度来达到多流程同时执行的一种机制，当然，单个CPU核心在单位时间内永远都只是执行一个线程的指令，所以需要以小的时间片段雨露均沾的执行每个线程的部分指令。在切换线程时是有上下文的切换的，包括寄存器的保存/还原，线程堆栈的保存/还原，这就是开销。</p>
<h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p>关于并行，真相只有一个，单个CPU核心在单位时间内只能执行一个线程的指令，所以如果总核心数为20，那么我们可以认为该主机的并行能力为20，但是用户态的并行能力是要比这个低的，因为操作系统服务和其它软件也是要用cpu的，因此这个数值是达不到的。</p>
<p>一个题外话，如果并行能力为20，那么我们可以粗略的认为，该主机一次可以同时执行20个线程，如果程序的线程使用率健康的话，保持线程池为20左右的大小可以做到完全的线程并行执行没有上下文切换。</p>
<p>那么并发则关注于应用的处理能力。这是一个更加侧重网络请求/服务响应能力的概念，可以理解为单位时间内可以同时接纳并处理用户请求的能力。它和多少CPU没有必然的关系，单纯的考量了服务器的响应回复能力。</p>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞/非阻塞与同步/异步是经常被混淆的。同步/异步其实在说事件的执行顺序，阻塞/非阻塞是指做一件事能不能立即返回。</p>
<p>我们举个去KFC点餐的例子。点完餐交完钱了，会有这么几种情况：</p>
<ul>
<li>服务人员直接把东西给我，因为之前已经做好了，所以能马上给我，这叫做非阻塞，我不需要等，结果立即返回。这整个过程是同步完成的。</li>
<li>服务人员一看没有现成的东西了，跑去现做，那么我就在这儿一直等，没刷微信没做别的干等，等到做出来拿走，这叫阻塞，因为我傻到等结果返回再离开点餐台。这整个过程是同步完成的。</li>
<li>服务人员一看没有现成的东西了，跑去现做，并告诉我说：先去做别的，做好了我叫你的号。于是我开心的找了个座位刷微信，等叫到了我的号了取回来。这叫做非阻塞，整个过程是异步的，因为我还刷了微信思考了人生。</li>
</ul>
<p>异步是非阻塞的，但是同步可以是阻塞的也可以是非阻塞的，取决于消费的资源。</p>
<h2 id="异步编程的挑战"><a href="#异步编程的挑战" class="headerlink" title="异步编程的挑战"></a>异步编程的挑战</h2><p>异步编程的主要困难在于，构建程序的执行逻辑时是非线性的，这需要将任务流分解成很多小的步骤，再通过异步回调函数的形式组合起来。在异步大行其道的<code>javascript</code>界经常可以看到很多层的<code>});</code>，简单酸爽到妙不可言。这一节将讨论一些常用的处理异步的技术手段。</p>
<h3 id="回调函数地狱"><a href="#回调函数地狱" class="headerlink" title="回调函数地狱"></a>回调函数地狱</h3><p>开头的那个例子使用了4层的嵌套回调函数，如果流程更加复杂的话，还需要嵌套更多，这不是一个好的实践。而且以回调的方式组织流程，在视觉上并不是很直白，我们需要更加优雅的方式来解耦和组织异步流。</p>
<p>使用传统的<code>javascript</code>技术，可以展平回调层次，例如我们可以改写之前的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ohs = <span class="built_in">require</span>(<span class="string">'./anticorruption/OpenHostService'</span>);</span><br><span class="line"><span class="keyword">var</span> localConvertingService = <span class="built_in">require</span>(<span class="string">'./services/LocalConverting'</span>);</span><br><span class="line"><span class="keyword">var</span> remoteRepository = <span class="built_in">require</span>(<span class="string">'./repositories/BusinessData'</span>);</span><br><span class="line"><span class="keyword">var</span> calculationService = <span class="built_in">require</span>(<span class="string">'./services/Calculation'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userData = req.body;</span><br><span class="line"></span><br><span class="line">    ohs.retrieveResource(userData, ohsCb);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ohsCb</span>(<span class="params">err, rs1</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        localConvertingService.unitize(rs1, convertingCb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">convertingCb</span>(<span class="params">err, rs2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        remoteRepository.loadBusinessData(rs2, loadDataCb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">loadDataCb</span>(<span class="params">err, bs1</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        calculationService.doCalculation(bs1 , calclationCb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">calclationCb</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.view(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解嵌套的关键在于如何处理函数作用域，之后金字塔厄运迎刃而解。</p>
<p>还有一种更为优雅的<code>javascript</code>回调函数处理方式，可以参考后面的<code>Promise</code>部分。</p>
<p>而对于像<code>C#</code>之类的内建异步支持的语言，那么上述问题更加的不是问题，例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> IActionResult <span class="title">CrazyCase</span>(<span class="params">UserData userData</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ticket = CrazyApplication.Ticket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ohsFactory = <span class="keyword">new</span> OpenHostServiceFactory(ticket);</span><br><span class="line">    <span class="keyword">var</span> ohs = ohsFactory.CreateService();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ohsAdapter = <span class="keyword">new</span> OhsAdapter(userData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rs1 = <span class="keyword">await</span> ohs.RetrieveResource(ohsAdapter);</span><br><span class="line">    <span class="keyword">var</span> rs2 = <span class="keyword">await</span> _localConvertingService.Unitize(rs1);</span><br><span class="line">    <span class="keyword">var</span> bs1 = <span class="keyword">await</span> _remoteRepository.LoadBusinessData(rs2);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> _calculationService.DoCalculation(bs1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> View(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>async/await</code>这糖简直不能更甜了，其它<code>C#</code>的编译器还是生成了使用<code>TPL</code>特性的代码来做异步，说白了就是一些<code>Task&lt;T&gt;</code>在做后台的任务，当遇到<code>async/await</code>关键字后，编译器将该方法编译为状态机，所以该方法就可以在<code>await</code>的地方挂起和恢复了。整个的开发体验几乎完全是同步式的思维在做异步的事儿。后面有关于<code>TPL</code>的简单介绍。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>由于异步执行采用非阻塞的方式，所以当前的执行线程在调用后捕获不到异步执行栈，因此传统的异步处理将不再适用。举两个例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Task.Factory.StartNew(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"diablo coming."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InvalidOperationException e) &#123;</span><br><span class="line">    <span class="comment">// nothing captured.</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'diablo coming.'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// nothing captured.</span></span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这两个例子中，<code>try</code>语句块中的调用会立即返回，不会触发<code>catch</code>语句。那么如何在异步中处理异常呢？我们考虑异步执行结束后会触发回调函数，那么这便是处理异常的最佳地点。<code>node</code>的回调函数几乎总是接受一个错误作为其首个参数，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'file.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123; &#125;);</span><br></pre></td></tr></table></figure>
<p>其中的<code>err</code>是由异步任务本身产生的，这是一种自然的处理异步异常的方式。那么回到<code>C#</code>中，因为有了好用的<code>async/await</code>，我们可以使用同步式的思维来处理异常：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Factory.StartNew(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"diablo coming."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InvalidOperationException e) &#123;</span><br><span class="line">    <span class="comment">// exception handling.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器所构建的状态机可以支持异常的处理，简直是强大到无与伦比。当然，对于<code>TPL</code>的处理也有其专属的支持，类似于<code>node</code>的处理方式：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Task.Factory.StartNew(() =&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"diablo coming."</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.ContinueWith(parent =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> parentException = parent.Exception;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意这里访问到的<code>parent.Exception</code>是一个<code>AggregateException</code>类型，对应的处理方式也较传统的异常处理也稍有不同：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parentException.Handle(e =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(e <span class="keyword">is</span> InvalidOperationException) &#123;</span><br><span class="line">        <span class="comment">// exception handling.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="异步流程控制"><a href="#异步流程控制" class="headerlink" title="异步流程控制"></a>异步流程控制</h3><p>异步的技术也许明白了，但是遇到更复杂的异步场景呢？假设我们需要异步并行的将目录下的3个文件读出，全部完成后进行内容拼接，那么就需要更细粒度的流程控制。</p>
<p>我们可以借鉴<a href="https://github.com/caolan/async" target="_blank" rel="noopener">async.js</a>这款优秀的异步流程控制库所带来的便捷。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.parallel([</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            fs.readFile(<span class="string">'f1.txt'</span>, <span class="string">'utf-8'</span>, callback)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            fs.readFile(<span class="string">'f2.txt'</span>, <span class="string">'utf-8'</span>, callback)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            fs.readFile(<span class="string">'f3.txt'</span>, <span class="string">'utf-8'</span>, callback)</span><br><span class="line">    &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, fileResults</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// concat the content of each files</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果使用<code>C#</code>并配合<code>TPL</code>，那么这个场景可以这么实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">AsyncDemo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> files = <span class="keyword">new</span> []&#123;</span><br><span class="line">        <span class="string">"f1.txt"</span>,</span><br><span class="line">        <span class="string">"f2.txt"</span>,</span><br><span class="line">        <span class="string">"f3.txt"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tasks = files.Select(file =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> Task.Factory.StartNew(() =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> File.ReadAllText(file);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> Task.WhenAll(tasks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fileContents = tasks.Select(t =&gt; t.Result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// concat the content of each files</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再回到我们开头遇到到的那个场景，可以使用<code>async.js</code>的<code>waterfall</code>来简化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ohs = <span class="built_in">require</span>(<span class="string">'./anticorruption/OpenHostService'</span>);</span><br><span class="line"><span class="keyword">var</span> localConvertingService = <span class="built_in">require</span>(<span class="string">'./services/LocalConverting'</span>);</span><br><span class="line"><span class="keyword">var</span> remoteRepository = <span class="built_in">require</span>(<span class="string">'./repositories/BusinessData'</span>);</span><br><span class="line"><span class="keyword">var</span> calculationService = <span class="built_in">require</span>(<span class="string">'./services/Calculation'</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userData = req.body;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span>.waterfall([</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            ohs.retrieveResource(userData, <span class="function"><span class="keyword">function</span>(<span class="params">err, rs1</span>) </span>&#123;</span><br><span class="line">                callback(err, rs1);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">rs1, callback</span>) </span>&#123;</span><br><span class="line">            localConvertingService.unitize(rs1, <span class="function"><span class="keyword">function</span>(<span class="params">err, rs2</span>) </span>&#123;</span><br><span class="line">                callback(err, rs2);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">rs2, callback</span>) </span>&#123;</span><br><span class="line">            remoteRepository.loadBusinessData(rs2, <span class="function"><span class="keyword">function</span>(<span class="params">err, bs1</span>) </span>&#123;</span><br><span class="line">                callback(err, bs1);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">bs1, callback</span>) </span>&#123;</span><br><span class="line">            calculationService.doCalculation(bs1, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">                callback(err, result);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.view(result);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要处理前后无依赖的异步任务流可以使用<code>async.series()</code>来串行异步任务，例如先开电源再开热水器电源最后亮起红灯，并没有数据的依赖，但有先后的顺序。用法和之前的<code>parallel()</code>及<code>waterfall()</code>大同小异。另外还有优秀的轻量级方案<a href="https://github.com/creationix/step" target="_blank" rel="noopener">step</a>，以及为<code>javascript</code>提供monadic扩展的<a href="https://github.com/JeffreyZhao/wind" target="_blank" rel="noopener">wind.js</a>（特别像<code>C#</code>提供的方案），有兴趣可以深入了解。</p>
<h3 id="反人类的编程思维"><a href="#反人类的编程思维" class="headerlink" title="反人类的编程思维"></a>反人类的编程思维</h3><blockquote>
<p>异步是反人类的</p>
</blockquote>
<p>人类生活在一个充满异步事件的世界，但是开发者在构建应用时却遵循同步式思维，究其原因就是因为同步符合直觉，并且可以简化应用程序的构建。</p>
<p>究其深层原因，就是因为现实生活中我们是在演绎，并通过不同的<code>口头回调</code>来完成一系列的异步任务，我们会说你要是有空了来找我聊人生，货到了给我打电话，小红你写完文案了交给小明，小丽等所有的钱都到了通知小强……而在做开发时，我们是在列清单，我们的说法就是：我等着你有空然后开始聊人生，我等着货到了然后我就知道了，我等着小红文案写完了然后开始让她交给小明，我等着小丽确认所有的钱到了然后开始让她通知小强……</p>
<p>同步的思维可以简化编程的关注点，但是没有将流程进行现实化的切分，我们总是倾向于用同步阻塞的方式来将开发变成简单的步骤程序化，却忽视了用动态的视角以及消息/事件驱动的方式构建任务流程。</p>
<p>异步在编程看来是反人类的，但是从业务角度看却是再合理不过的了。通过当的工具及技术，使用异步并不是难以企及的，它可以使应用的资源利用更加的高效，让应用的响应性更上一个台阶。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="Promise-Deferred"><a href="#Promise-Deferred" class="headerlink" title="Promise/Deferred"></a>Promise/Deferred</h3><blockquote>
<p>在一般情况下，Promise、Deferred、Future这些词可以当做是同义词，描述的是同一件事情。</p>
</blockquote>
<p>在<code>jQuery 1.5+</code>之后出现了一种新的API调用方式，相比于旧的API，新的方式更好的解耦了关注点，并带来了更好的组合能力。</p>
<p>我们看一个传统的使用<code>ajax</code>的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/api/service1', &#123;</span><br><span class="line">    success: onSuccess,</span><br><span class="line">    failure: onFailure,</span><br><span class="line">    always:  onAlways</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用新的API后，调用的方式变成了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/api/service1')</span><br><span class="line">    .done(onSussess)</span><br><span class="line">    .fail(onFailure)</span><br><span class="line">    .always(onAlways);</span><br></pre></td></tr></table></figure>
<p><code>get</code>方法返回的是一个<code>promise</code>对象，表示这个方法会在未来某个时刻执行完毕。</p>
<p><code>Promise</code>是<a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="noopener">CommonJS</a>提出的规范，而<code>jQuery</code>的实现在其基础上有所扩展，旗舰级的实现可以参考<a href="https://github.com/kriskowal" target="_blank" rel="noopener">Kris Kowal</a>的<a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">Q.js</a>。</p>
<p>我们使用<code>jQuery</code>来构建一个<code>promise</code>对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longTimeOperation = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deferred = $.Deferred();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// taste like setTimeout()</span></span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// do operation.</span></span><br><span class="line">        deferred.resolve();</span><br><span class="line">        <span class="comment">// if need error handling, use deferred.reject();</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> deferred.promise();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.when(longTimeOperation())</span><br><span class="line">    .done(success)</span><br><span class="line">    .fail(failure);</span><br></pre></td></tr></table></figure>
<p>由于<code>jQuery</code>生成的<code>Deferred</code>可以自由的进行<code>resolve()</code>和<code>reject()</code>，所以在返回时我们使用<code>.promise()</code>生成不含这个两方法的对象，从而更好的封装逻辑。</p>
<p>那么<code>Promise</code>究竟带给我们的便利是什么？<code>Promise</code>表示在未来这个任务会成功或失败，可以使用1和0来表示，那么开发者马上就开始欢呼了，给我布尔运算我能撬动地球！于是，我们可以写出如下的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.when(uploadPromise, downloadPromise)</span><br><span class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// do animation.</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>对于开头的那个例子我们说过有着更优雅的解回调函数嵌套的方案，那就是使用<code>promise</code>，我们来尝试改写开头的那个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ohs = <span class="built_in">require</span>(<span class="string">'./anticorruption/OpenHostService'</span>);</span><br><span class="line"><span class="keyword">var</span> localConvertingService = <span class="built_in">require</span>(<span class="string">'./services/LocalConverting'</span>);</span><br><span class="line"><span class="keyword">var</span> remoteRepository = <span class="built_in">require</span>(<span class="string">'./repositories/BusinessData'</span>);</span><br><span class="line"><span class="keyword">var</span> calculationService = <span class="built_in">require</span>(<span class="string">'./services/Calculation'</span>);</span><br><span class="line"><span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userData = req.body;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">deferredCallback</span>(<span class="params">deferred</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                deferred.reject(err);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">                deferred.resolve(args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">makeDeferred</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> deferred = $.Deferred();</span><br><span class="line">        <span class="keyword">var</span> callback = deferredCallback(deferred);</span><br><span class="line">        fn(callback);</span><br><span class="line">        <span class="keyword">return</span> deferred.promise();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> retrieveResourcePromise = makeDeferred(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        ohs.retrieveResource(userData, callback);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> convertingPromise = makeDeferred(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        localConvertingService.unitize(rs1, callback);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> loadBusinessDataPromise = makeDeferred(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        remoteRepository.loadBusinessData(rs2, callback);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> calculationPromise = makeDeferred(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        calculationService.doCalculation(bs1 , callback);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pipedPromise = retrieveResourcePromise</span><br><span class="line">        .pipe(convertingPromise)</span><br><span class="line">        .pipe(loadBusinessDataPromise)</span><br><span class="line">        .pipe(calculationPromise);</span><br><span class="line"></span><br><span class="line">    pipedPromise</span><br><span class="line">        .done(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            res.view(result);</span><br><span class="line">        &#125;)</span><br><span class="line">        .fail(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用了一个高阶函数来生成可以兼容<code>deferred</code>构造的回调函数，进而使用<code>jQuery</code>的<code>pipe</code>特性(在<code>Q.js</code>里可以使用<code>then()</code>组合每个<code>promise</code>)，使解决方案优雅了很多，而这个工具函数在<code>Q.js</code>里直接提供，于是新的解决方案可以如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ohs = <span class="built_in">require</span>(<span class="string">'./anticorruption/OpenHostService'</span>);</span><br><span class="line"><span class="keyword">var</span> localConvertingService = <span class="built_in">require</span>(<span class="string">'./services/LocalConverting'</span>);</span><br><span class="line"><span class="keyword">var</span> remoteRepository = <span class="built_in">require</span>(<span class="string">'./repositories/BusinessData'</span>);</span><br><span class="line"><span class="keyword">var</span> calculationService = <span class="built_in">require</span>(<span class="string">'./services/Calculation'</span>);</span><br><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userData = req.body;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> retrieveResourceFn = Q.denodeify(ohs.retrieveResource)</span><br><span class="line">    <span class="keyword">var</span> convertingFn = Q.denodeify(localConvertingService.unitize);</span><br><span class="line">    <span class="keyword">var</span> loadBusinessDataFn = Q.denodeify(remoteRepository.loadBusinessData);</span><br><span class="line">    <span class="keyword">var</span> calculationFn = Q.denodeify(calculationService.doCalculation);</span><br><span class="line"></span><br><span class="line">    retrieveResourceFn(userData)</span><br><span class="line">        .then(convertingFn)</span><br><span class="line">        .then(loadBusinessDataFn)</span><br><span class="line">        .then(calculationFn)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            res.view(result);</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们如何看待<code>TPL</code>特性呢？我们看看<code>TPL</code>可以做什么：</p>
<ul>
<li>以<code>Task</code>为基本构造单位，执行时不阻塞调用线程</li>
<li>每个<code>Task</code>是独立的，<code>Task</code>有不同的状态，可以使用<code>Task.Status</code>获取</li>
<li><code>Task</code>可以组合，使用类似<code>.ContinueWith(Task))</code>以及<code>.WhenAll(Task[])</code>、<code>.WhenAny(Task[])</code>的方式自由组合。</li>
</ul>
<p>对比一下<code>Promise</code>：</p>
<ul>
<li>以<code>Promise</code>为基本构造单位，表示一个将来完成的任务，调用时立即返回</li>
<li>每个<code>Promise</code>是独立的，<code>Promise</code>有不同的状态，可以使用<code>.state</code>获取</li>
<li><code>Promise</code>可以组合，使用<code>.then()</code>、<code>.pipe()</code>以及<code>.when()</code>来组合执行流程</li>
</ul>
<p>可以看到，不论是<code>Promise</code>还是<code>TPL</code>，在设计上都有着惊人的相似性。我们有理由猜想在其它的的语言或平台都存在着类似的构造，因为异步说白了，就是让未来完成的事情自己触发后续的步骤。</p>
<h3 id="Pull-vs-Push"><a href="#Pull-vs-Push" class="headerlink" title="Pull vs. Push"></a>Pull vs. Push</h3><p>在<a href="http://en.wikipedia.org/wiki/Design_Patterns" target="_blank" rel="noopener">GoF32</a>中没有提到迭代器模式(Iterator)与观察者模式(Observer)的区别和联系，其实这两个模式有着千丝万缕的联系。</p>
<p>Iterator反映的是一种Pull模型，数据通过同步的方式从生产者那里拉过来，我们通过它的定义便可看到这一事实：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IEnumerator&lt;out T&gt;: IDisposable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>;</span><br><span class="line">    T Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过阻塞的方式调用<code>MoveNext()</code>，数据一个一个的拉取到本地。</p>
<p>而Observer反映的是一种Push模型，通过注册一个观察者（类似于回调函数），当生产者有数据时，主动的推送到观察者手里。观察者注册结束后，本地代码没有阻塞，推送数据的整个过程是异步执行的。我们通过它的定义来对比Iterator：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IObserver&lt;in T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnCompleted</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnError</span>(<span class="params">Exception exception</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnNext</span>(<span class="params">T <span class="keyword">value</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，其实这两个接口是完全对偶的（参见<a href="http://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)" target="_blank" rel="noopener">Erik Meijer</a>大大的论文<a href="http://csl.stanford.edu/~christos/pldi2010.fit/meijer.duality.pdf" target="_blank" rel="noopener">Subject/Observer is Dual to Iterator</a>）：</p>
<ul>
<li><code>MoveNext()</code>拉取下一个数据，<code>OnNext(T)</code>推送下一个数据</li>
<li><code>MoveNext()</code>返回值指示了有无剩余数据（完成与否），<code>OnCompleted()</code>指示了数据已完成（推送数据完成的消息）</li>
<li>Iterator是同步的，所以出现了异常直接在当前运行栈上，Observer是异步的，所以需要另一种方式来通知发生了异常（参见上文中的异步处理一节），于是有了<code>OnError(Exception)</code>。</li>
</ul>
<p>那么事情就变的有意思了，我们知道<code>Enumerable</code>的数据可以任意的方式组合，于是产生了像<code>LINQ</code>之类的库可供我们使用，但是这是一种阻塞的方式，因为Iterator本身就是一种Pull模型，这造就了同步等待的结果。</p>
<blockquote>
<p>没错你是对的，如果使用EF之类的框架来查询数据库，大部分的操作是延迟执行的，表明操作并没有发生而是像占位符一样在那里。但是别忘了，你最终需要去查询数据库的，在查询的一刹那，世界还是阻塞的，等结果吧亲。</p>
</blockquote>
<p>而Observer是异步Push的，有点像是事件驱动，有事件了触发，没事件了也不干扰订阅者的执行。</p>
<blockquote>
<p>你是不是也隐隐的觉得事件也可以和Push模式一样有统一的模型？而且不只一次？</p>
</blockquote>
<p>好，我们重复一遍：事件，非阻塞触发（并带有事件数据）。Push，非阻塞通知订阅者。</p>
<p>其实，这是同一种模式，语言中对事件（就是<code>event</code>关键字）的支持其实就是对Observer模式的支持，而<code>foreach</code>则实现了对Iterator模式的语言内建支持。所谓设计模式，就是因为语言的内建支持不够而出现的，说白了，是语言的补丁。</p>
<p>那么我们来看一看异常强大的<a href="https://github.com/Reactive-Extensions/" target="_blank" rel="noopener">Rx</a>如何改变事件。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unitized event</span></span><br><span class="line"><span class="keyword">var</span> mouseDown = Observable</span><br><span class="line">    .FromEventPattern&lt;MouseEventArgs&gt;(<span class="keyword">this</span>.myPictureBox, <span class="string">"MouseDown"</span>)</span><br><span class="line">    .Select(x =&gt;x.EventArgs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// unitized APM model</span></span><br><span class="line"><span class="keyword">var</span> request = WebRequest.Create(<span class="string">"https://www.shinetechchina.org"</span>);</span><br><span class="line"><span class="keyword">var</span> webRequest = Observable</span><br><span class="line">    .FromAsyncPattern&lt;WebResponse&gt;(request.BeginGetResponse, request.EndGetResponse);</span><br></pre></td></tr></table></figure>
<p>最后我们看一个更加复杂的组合事件的例子，也就是之前一直讨论的异步流组合问题。Drag and Drop这个场景做<code>Winform</code>的同学不会陌生，需要多少代码冷暖自知，如果借助<code>Rx</code>，那么事情就简单很多：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mouseDown = Observable</span><br><span class="line">    .FromEventPattern&lt;MouseEventArgs&gt;(<span class="keyword">this</span>.controlSource, <span class="string">"MouseDown"</span>)</span><br><span class="line">    .Select(x =&gt; x.EventArgs.GetPosition(<span class="keyword">this</span>));</span><br><span class="line"><span class="keyword">var</span> mouseUp = Observable</span><br><span class="line">    .FromEventPattern&lt;MouseEventArgs&gt;(<span class="keyword">this</span>.controlSource, <span class="string">"MouseUp"</span>)</span><br><span class="line">    .Select(x =&gt; x.EventArgs.GetPosition(<span class="keyword">this</span>));</span><br><span class="line"><span class="keyword">var</span> mouseMove = Observable</span><br><span class="line">    .FromEventPattern&lt;MouseEventArgs&gt;(<span class="keyword">this</span>.controlSource, <span class="string">"MouseMove"</span>)</span><br><span class="line">    .Select(x =&gt; x.EventArgs.GetPosition(<span class="keyword">this</span>));</span><br><span class="line"><span class="keyword">var</span> dragandDrop = </span><br><span class="line">    <span class="keyword">from</span> down <span class="keyword">in</span> mouseDown</span><br><span class="line">    <span class="keyword">from</span> move <span class="keyword">in</span> mouseMove.StartWith(down).TakeUntil(mouseUp)</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span> &#123;</span><br><span class="line">        X = move.X - down.X,</span><br><span class="line">        Y = move.Y - down.Y</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">dragandDrop.Subscribe(<span class="keyword">value</span> =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    DesktopCanvas.SetLeft(<span class="keyword">this</span>.controlSource, <span class="keyword">value</span>.X);</span><br><span class="line">    DesktopCanvas.SetTop(<span class="keyword">this</span>.controlSource, <span class="keyword">value</span>.Y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Rx</code>也提供了<code>javascript</code>扩展，有兴趣可以深入研究。</p>
<p>（完）</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/productivity/">productivity</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/productivity/">productivity</a><a href="/tags/C/">C#</a><a href="/tags/asynchronous/">asynchronous</a><a href="/tags/javascript/">javascript</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/12/03/async-programming/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/05/coolshell-puzzle-guides/" title="coolshell puzzle guides" itemprop="url">coolshell puzzle guides</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2014-08-05T02:14:41.000Z" itemprop="datePublished"> Published 2014-08-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><a href="http://www.coolshell.cn" target="_blank" rel="noopener">CoolShell</a>博主<a href="http://weibo.com/haoel" target="_blank" rel="noopener">陈皓</a>做了一个在线的puzzle很有意思，链接在<a href="http://fun.coolshell.cn" target="_blank" rel="noopener">这里</a>，这里记录一下解题的一些步骤。</p>
<h2 id="Puzzle-0"><a href="#Puzzle-0" class="headerlink" title="Puzzle 0"></a>Puzzle 0</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++++++++[&gt;+&gt;++&gt;+++&gt;++++&gt;+++++&gt;++++++&gt;+++++++&gt;++++++++&gt;+++++++++&gt;++++++++++&gt;+++++++++++&gt;++++++++++++&gt;+++++++++++++&gt;++++++++++++++&gt;+++++++++++++++&gt;++++++++++++++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+++.---&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;--.++&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;.&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.</span><br></pre></td></tr></table></figure>
<p>如果之前没有听说过变态的编程语言，就让你见识一下。<a href="http://www.muppetlabs.com/~breadbox/bf/" target="_blank" rel="noopener">BrainFuck</a>也称BF，是一门只有8个指令构成的图灵完备的语言。<a href="http://www.coolshell.cn" target="_blank" rel="noopener">CoolShell</a>博主<a href="http://weibo.com/haoel" target="_blank" rel="noopener">陈皓</a>写过一篇简单的介绍在<a href="http://coolshell.cn/articles/1142.html" target="_blank" rel="noopener">这里</a><br>具体的指令解释不多说了，直接打长<a href="http://esoteric.sange.fi/brainfuck/impl/interp/i.html" target="_blank" rel="noopener">这里</a>，把上面的指令粘进去，运行得到下一关的地址：<code>welcome.html</code>。</p>
<h2 id="Puzzle-welcome-html"><a href="#Puzzle-welcome-html" class="headerlink" title="Puzzle welcome.html"></a>Puzzle welcome.html</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X * Y</span><br><span class="line">2, 3, 6, 18, 108, ?</span><br><span class="line">What is the meaning of life, the universe and everything?</span><br><span class="line">生命、宇宙以及任何事情的终极答案</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
            <a href="/2014/08/05/coolshell-puzzle-guides/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/other/">other</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/08/05/coolshell-puzzle-guides/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/07/31/sports-change-thought/" title="运动改变思维" itemprop="url">运动改变思维</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lu Rongkai" target="_blank" itemprop="author">Lu Rongkai</a>
		
  </p><p class="article-time">
    <time datetime="2014-07-31T15:53:11.000Z" itemprop="datePublished"> Published 2014-07-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <img src="/photos/2014-07/running.jpg" width="800">
<p>今年的春天开始，Ninja逐渐的开始加强身体机能的锻炼，虽说没有惊天动地的成效，但是的确也带来了不错的效果。之前的日子波澜不惊，回过头来看发现过的挺颓的，尤其是12年从美国暴饮暴食回来后发现整个人胖的想死了，后知后觉后发现这种糟糕的状态真是可怕。是时候做出一些改变了。3个月后，Ninja从80kg降到了72kg，并且还在朝着<a href="http://baike.baidu.com/view/966047.htm" target="_blank" rel="noopener">BMI</a>推荐的体重67kg而努力。</p>
<h2 id="饮食"><a href="#饮食" class="headerlink" title="饮食"></a>饮食</h2><p>和@阳总 之前有过一段时间的尝试，就是晚上只喝粥，原本是想吃清淡一些，配合一些减脂运动可能会有不错的效果，后来证明这一点真的是错的可怕。精食，尤其是米类和面食类并不能有效的起到减脂效果，淀粉转化后的葡萄糖会让你的脂肪感觉爽爽的，套用@阳总 的理工男思维：葡萄糖转化后的ATP可直接为人体提供能量，回想起来怕怕的。后续的故事是这样，连喝三天体重不掉，整个人看起来都是粥色了，出去大吃一顿，尝试别的方案。</p>
<p>之后Ninja开始认真的调整饮食习惯，不刻意的减少每顿的摄入量。少食多餐，中午的两荤一素也改为两素一荤，只要有饱腹感立即停箸，3个月下来，感觉非常好，整个人都不油腻了。</p>
        
        
        <p class="article-more-link">
          
            <a href="/2014/07/31/sports-change-thought/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/life/">life</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/07/31/sports-change-thought/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://github.com/lurongkai" target="_blank" title="Github">Github</a>
            
          </li>
        
          <li>
            
            	<a href="/software-designing-perspective" target="_blank" title="软件和设计">软件和设计</a>
            
          </li>
        
          <li>
            
            	<a href="/human-being-and-life-perspective" target="_blank" title="人类和生活">人类和生活</a>
            
          </li>
        
    </ul>
</div>

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/productivity/" title="productivity">productivity<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C#">C#<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/security/" title="security">security<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/microservice/" title="microservice">microservice<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/F/" title="F#">F#<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/collaboration/" title="collaboration">collaboration<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/asynchronous/" title="asynchronous">asynchronous<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/javascript/" title="javascript">javascript<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Golang/" title="Golang">Golang<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/error-handling/" title="error-handling">error-handling<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Functional-Programming/" title="Functional-Programming">Functional-Programming<sup>1</sup></a></li>
			
		
		</ul>
</div>


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/asp-net/" title="asp-net">asp-net<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/dot-net/" title="dot-net">dot-net<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/essays/" title="essays">essays<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/joke/" title="joke">joke<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/life/" title="life">life<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/other/" title="other">other<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/productivity/" title="productivity">productivity<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/reproduce/" title="reproduce">reproduce<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/tips/" title="tips">tips<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/training/" title="training">training<sup>1</sup></a></li>
		  
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer">
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m lurongkai on Github <br>
			</p>
	</section>
	 
	<div class="social-font">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/lurongkai" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="Lu Rongkai">Lu Rongkai</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?74291727c50712cd2fcc785ef807bd0c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
