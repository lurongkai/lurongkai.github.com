<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lurongkai&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lurongkai.github.io/"/>
  <updated>2019-12-05T02:46:18.627Z</updated>
  <id>https://lurongkai.github.io/</id>
  
  <author>
    <name>Lu Rongkai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何优雅的在Golang中进行错误处理</title>
    <link href="https://lurongkai.github.io/2019/07/26/handle-error-gracefully-in-golang/"/>
    <id>https://lurongkai.github.io/2019/07/26/handle-error-gracefully-in-golang/</id>
    <published>2019-07-26T04:06:14.000Z</published>
    <updated>2019-12-05T02:46:18.627Z</updated>
    
    <content type="html"><![CDATA[<p>如何优雅的在<code>Golang</code>中进行错误处理？</p><p>答案是：没有……（本文完）</p><hr><p>开个玩笑，<code>Golang</code>中的错误处理方式一直是社区热烈讨论的话题，有力挺者，有抱怨者，但不论如何，自 2009 年<code>Golang</code>正式发布以来，关于错误处理就一直是现在这种状况。</p><p>随着<code>Golang</code>愈加的火爆，原本是<code>Java</code>、<code>Node</code>、<code>C#</code>等语言擅长的应用级开发领域也逐渐出现<code>Golang</code>的身影。<code>Golang</code>自身其实更加擅长做基础设施级开发，例如<code>docker</code>，例如<code>k8s</code>，再如<code>etcd</code>，它友好的内存管理和简单到粗暴的语法（25 个关键字），特别适合过去<code>C</code>和<code>C++</code>这些语言所擅长的部分场景。我们有理由相信，<code>Golang</code>下一个大的引爆点将也许会在<code>IoT</code>上，因为它天然的适合。</p><p>当一门语言火起来，就会出现各式各样的应用，于是<code>MVC</code>框架有了，音视频处理库有了，各种数据库驱动有了，甚至服务框架也出现了，游戏、<code>Machine Learning</code>都不在话下，还要啥自行车？组合一下做应用级开发妥妥的没毛病。</p><p>但是，成也这 25 个关键字，败也这 25 个关键字，究其根本原因，都是因为它背后<strong>简单</strong>的哲学。</p><p>做应用级开发可不是那么简单的，这涉及到很多的细节处理，例如本文将要讨论的错误处理。如果只是写一个库，那么这个话题相对比较简单，因为与<code>API</code>打交道的都是开发者，你只管开心的往外扔<code>error</code>就好了，总会有倒霉的程序员在使用你的代码时<strong>DEBUG</strong>到白头，最后，以最严谨的方式，小心使用你的库；可是有人出现的地方就会有幺蛾子，一个常见的误区就是将<strong>业务错误</strong>、<strong>运行时错误</strong>、<strong>程序错误</strong>一股脑的当成相同的<code>error</code>来处理。</p><a id="more"></a><blockquote><p>你是还没在<code>error</code>上栽跟头，当你栽了跟头时才会哭着想起来，当年为什么没好好思考和反省<strong>错误处理</strong>这么一个宏大的话题</p></blockquote><p>那么，如何在现有的语言支持下，用一种相对优雅的方式进行错误处理呢？我们通过本文的思考和讨论，尝试予以解决。虽说主要讨论的是<code>Golang</code>，但是这背后的思考其实适合大部分语言。</p><h2 id="语言级别的错误处理"><a href="#语言级别的错误处理" class="headerlink" title="语言级别的错误处理"></a>语言级别的错误处理</h2><p><code>Golang</code>是原生支持鸭子类型（<a href="https://en.wikipedia.org/wiki/Duck_typing" target="_blank" rel="noopener">duck typing</a>）的，所以<code>error</code>可以理解成一个“鸭子”的定义，它是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换句话讲，一切实现了<code>Error() string</code>方法的<code>struct</code>，都可以当成<code>error</code>往外扔，神不神奇？不神奇……把它看成接口也无碍，反正其它语言也长的类似，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SystemException</span> : <span class="title">Exception</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InvalidOperationException</span> : <span class="title">SystemException</span></span><br></pre></td></tr></table></figure><p>问题来了，<code>Golang</code>是没有继承这一说的，所以如果你想把错误规划成层级结构是行不通的，而且也不是<code>Golang</code>的调调。不过定义多种错误终归是可以的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"errors"</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrNotAuthenticated = errors.New(<span class="string">"not authenticated"</span>)</span><br><span class="line">    ErrNotAuthorized    = errors.New(<span class="string">"not authorized"</span>)</span><br><span class="line">    ErrNoPermission     = errors.New(<span class="string">"no permission"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>鸭子类型在不使用继承的情况下变相支持了多态，所以是可以认为<code>error</code>是个接口，<code>error</code>的消费方可以不用关心背后是具体什么结构，只需要满足<code>error</code>契约就行，这就是所谓的多态。</p><p>那么到这里为止，我们有了具体的<code>error</code>，然后呢？总是得有一个地方去处理。从这里开始，<code>Golang</code>与别的语言区分开了。</p><p>本来想解释一下什么是错误(error)，什么是异常(exceptional)，但是貌似太多的语言在混搭使用这两个术语，所以我们干脆放弃解释错误和异常，而使用可恢复和不可恢复来说明。同时，我个人实名点赞<code>Golang</code>和<code>Rust</code>在这两个概念上的区分。</p><h3 id="不可恢复故障"><a href="#不可恢复故障" class="headerlink" title="不可恢复故障"></a>不可恢复故障</h3><p><code>Golang</code>和<code>Rust</code>都有<code>panic</code>的概念，也就是指不可恢复的故障，一般遇到<code>panic</code>时基本就不用再救了，大部分的时候都是直接以<code>-1</code>为返回值退出程序就好，<strong>除非你觉得我行我可以我还想再试试</strong>，那么使用<code>recover</code>手段，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line">fun horrible() &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"some bad things happened"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">business</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// give me another chance</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    horrible()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不处理的话，程序就会自动退出，并打印出错误信息以及错误堆栈。<code>Rust</code>的方式几乎一模一样，只不过有两点不同：<code>Rust</code>中对应<code>panic</code>的是<code>panic!</code>宏，和<code>recover</code>类似的功能是<code>std::panic::catch_unwind</code>；另外就是退出后默认不打印堆栈，需要的话得手动设置<code>RUST_BACKTRACE=1</code>环境变量。</p><p>这个非常好理解，比如数组越界了，内存满了，堆栈爆了，几乎碰到<code>panic</code>就很少有恢复的可能。</p><p><code>panic</code>背后其实是一种<strong>短路</strong>（或者叫<strong>快捷方式</strong>）哲学，任何层级的流程在执行过程中，通过<code>panic</code>都可以直接让程序跳到结束或者有<code>recover</code>的地方。这与大多数据的高级语言的<code>Exception</code>不谋而合，举个例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSometingIntresting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"not allowed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要碰到<code>Exception</code>就一定会中断正常的执行顺序。稍显遗憾的是，这些语言中的<code>Exception</code>不完全能把程序打死，因为它们大多都提供了<code>try-catch</code>语言构造，让你可以在任何想处理的地方，或处理或加工，总之手法多样。打不死的原因也正是因为，一个简单的<code>catch (Exception ex) {}</code>就足够吃掉所有的故障。</p><p>这也是为什么在开头那部分里不用错误和异常的原因，因为：</p><blockquote><p>大多数支持<code>try-catch-exception</code>机制的语言里，可恢复和不可恢复的故障都用 Exception 来表示，这加剧了开发者的心智负担，因为这需要仔细的处理 Exception 的类型。例如，C#里的<strong>不可恢复</strong>错误往往都有特定的继承链，比如<code>SystemException</code>，使用时需要小心处理。</p></blockquote><p>更好的理解方式是，把<code>try-catch-exception</code>这种机制，主要作为处理<strong>可恢复</strong>故障的手段，而把少量<strong>不可恢复</strong>的故障，在充分思考的情况下处理或放任。换句话讲，<strong>catch 一定尽可能的按下游方法可能出现的<code>Exception</code>类型去匹配，不要随意通吃</strong>。</p><h3 id="可恢复故障"><a href="#可恢复故障" class="headerlink" title="可恢复故障"></a>可恢复故障</h3><p>与<code>panic</code>有所区别的<strong>可恢复</strong>故障，<code>Golang</code>也有约定的方式。这就是<code>error</code> 。</p><p>所谓可恢复，就是虽然无法顺利的将当前的流程执行完毕，但是不影响大局，消费方可以按自己的意愿去安排接下来的逻辑，或中断执行某个业务，或检查是否自己使用的方式有问题，或有备用的流程替换等等。</p><p>实践中经常碰到的可恢复故障有几大类：</p><ul><li><strong>前置检查失败</strong>，大多是指参数没有按约定提供，例如参数不可空校验失败的错误，参数数值范围不正确等等，这是<strong>调用方的 bug</strong></li><li><strong>程序错误</strong>，例如通过<code>req.(sometype)</code>进行类型转换，到运行时发现转不过去，这是<strong>自身的 bug</strong></li><li><strong>依赖服务调用错误</strong>，比如查询数据库时发生了异常，往往都是第三方产生运行时错误，是最经常处理的错误</li><li><strong>业务执行错误</strong>，例如一个发送验证码的函数，在执行过程中发现某个用户的发送频率超过阈值，那这是一个特定业务的失败</li></ul><p>基本所有在开发过程中碰到的错误都能归入以上 4 类。而往往需着重关注的，是后两类。前两类实属于<strong>bug</strong>，需要在上线前就清理完毕的。</p><h2 id="可恢复故障的抛出方式"><a href="#可恢复故障的抛出方式" class="headerlink" title="可恢复故障的抛出方式"></a>可恢复故障的抛出方式</h2><p>我们来做一个思考。在一门语言中，如果一个方法有可能出错，通常会通过什么途径把错误信息告诉调用者呢？换句话讲，正常的方法返回数据，不正常的方法需要有途径“带货”，把错误信息以某种方式带出去。</p><h3 id="单值函数的方式"><a href="#单值函数的方式" class="headerlink" title="单值函数的方式"></a>单值函数的方式</h3><p>如果这门语言只支持单值函数，也就是返回值只能是一个，那么就需要有一个容器来储存正常的值和出错时需要返回的错误信息，就像：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Result</span>&lt;'T&gt; </span>= &#123;</span><br><span class="line">    Data: <span class="symbol">'T</span></span><br><span class="line">    Error: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，每个使用该方法的地方，只需要简单判断一下<code>res.Error</code>就能知道有没有错误发生。</p><p>像不像是很多<code>Restful</code>接口返回数据的模样？是的，完全是一个模式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  "errmsg": "",</span><br><span class="line">  "errcode": "610100"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先忽略这个错误码，后面的内容我们会涉及到。</p><h3 id="多值函数的方式"><a href="#多值函数的方式" class="headerlink" title="多值函数的方式"></a>多值函数的方式</h3><p>那如果语言支持多值返回（其实还是单值，大多是引入<code>元组（Tuple）</code>来处理，例如<code>Python</code>），概念上和如下的方式相同：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Tuple&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt; <span class="title">Multiple</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Tuple.Create(<span class="number">0</span>, <span class="string">"something wrong"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，该<code>Golang</code>出场了，既然我支持多值返回，那么应该不用明显的包装类型就可以做到了吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiple</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="string">"something wrong"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等等，错误用<code>string</code>表示有点丑是不是，没关系，<code>Golang</code>帮你抽象出一个<code>error</code>接口来，最终就变成了<code>func multiple() (int, error) {}</code>这样子了，<br>和定义一个<code>type res struct { Data int; Err error}</code>相比，好像没进步太多？</p><h3 id="函数式的方式"><a href="#函数式的方式" class="headerlink" title="函数式的方式"></a>函数式的方式</h3><p>那还有没有更好的方式了呢？如果有接触过<code>Functional Programming</code>的东西，就会想到，通过<code>Generic</code> + <code>Discriminated Unions</code> + <code>partten matching</code>的方式更加优雅。</p><p>核心在<code>Discriminated Unions</code>上，也叫做<code>Enum</code>，<code>Union</code>，<code>Tagged Union</code>，<code>variant</code>，<code>variant record</code>，<code>choice type</code>，<code>disjoint union</code>，<code>sum type</code>，<code>coproduct</code>……它是一种可以存储多种（但是数量固定）类型值的结构，同一时间<strong>只可以</strong>使用其中的一种类型。举个例子，如下的<code>DUs</code>可以避免<code>null</code>的显式使用：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Option</span>&lt;'T&gt; </span>=</span><br><span class="line">    | None</span><br><span class="line">    | Some <span class="keyword">of</span> <span class="symbol">'T</span></span><br></pre></td></tr></table></figure><p>这个<code>Option&lt;&#39;T&gt;</code>（也有叫<code>Maybe</code>的）要么只有<code>None</code>值，要么只有一个包含<code>&#39;T</code>的<code>Some</code>值，于是，当函数返回一个<code>Option</code>类型的值时，消费方就可以不再写诸如<code>Golang</code>中的<code>if err != nil {}</code>了，而是使用更加高级的模式匹配完成：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> res = somemethod() <span class="comment">// will return an Option value</span></span><br><span class="line"><span class="keyword">match</span> res <span class="keyword">with</span></span><br><span class="line">    | None   -&gt; <span class="comment">// data is empty, like null</span></span><br><span class="line">    | Some d -&gt; <span class="comment">// d is data</span></span><br></pre></td></tr></table></figure><p>等等，这不像是在做错误处理？没关系，稍微变换一下：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Result</span>&lt;'T, 'TError&gt; </span>=</span><br><span class="line">    | Ok <span class="keyword">of</span> <span class="symbol">'T</span></span><br><span class="line">    | Error <span class="keyword">of</span> 'TError</span><br></pre></td></tr></table></figure><p>现在的使用方式变成了：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> res = somemethod() <span class="comment">// will return an Option value</span></span><br><span class="line"><span class="keyword">match</span> res <span class="keyword">with</span></span><br><span class="line">    | Ok t      -&gt; <span class="comment">// t is normal result</span></span><br><span class="line">    | Error err -&gt; <span class="comment">// err is error</span></span><br></pre></td></tr></table></figure><p>好像还是没什么用？那是因为没有接触过<code>FP</code>中的<code>Warpper</code>类型的概念，基本上有了<code>Warpper</code>类型，就可以<code>bind</code>或者<code>lift</code>等等了。<code>Rust</code>走的就是这种路子，并有配套的函数支持。由于<code>Option</code>和<code>Result</code>如此常用，以至于很多语言核心库都内置了对应的结构，有兴趣可以参考我很早之前写过的一点<a href="http://www.ituring.com.cn/article/207638" target="_blank" rel="noopener">东西</a>。</p><p>那么，<code>Golang</code>为什么不使用这种方式呢？因为，第一缺乏泛型支持，<code>Warpper</code>如果没有泛型支持的话就无法泛化，会导致很多的模板代码，进而还不如直白的处理<code>error</code>；第二没有<code>Discriminated Unions</code>，多个类型无法联合起来并在同一时间只使用其中一种，也就快速区分彼此；第三没有模式匹配，也就无法更进一步的简化代码，不如还是使用<code>if err != nil {}</code>。</p><p>上面诸多方式仍然停留在<code>调用-返回-处理</code>这个流程上，顶多也就是代码简洁与否的问题。我个人是认可<code>Golang</code>的错误处理方式的，虽然会出现很多的模板代码，但是在写代码的每一步都能清晰的并强迫性的让开发者处理潜在的错误，也是一种提高质量的不错手段。</p><p>实践中使用最多的方式，是隔空传送<code>Exception</code>，虽然有很多的文章在指导大家如何去花式处理<code>Exception</code>，但是仍然值得大家留意其中的陷阱。毕竟，异常是一种中断当前执行流程的手段，并且会穿透调用栈，所以需要格外留意捕获到的异常究竟代表了什么含义，而不是一股脑的全部捕获。这一点要赞一下<code>Java</code>，<code>Java</code>中的方法签名会强制列出有可能抛出的异常类型，以供开发者快速处理可能出现的异常。</p><p>有关<code>Exception</code>设计和使用的话题，我们将来有机会再来聊。</p><h3 id="Golang-中将来可能的方式"><a href="#Golang-中将来可能的方式" class="headerlink" title="Golang 中将来可能的方式"></a>Golang 中将来可能的方式</h3><p>在<code>Go 2</code>的草案中，我们看到了有关于<code>error</code>相关的一些提案，那就是<code>check/handle</code>函数。</p><p>我们也许在下一个大版本的<code>Golang</code>可以像下面这样处理错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">game</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    handle err &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"dependencies error: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resource := check findResource() <span class="comment">// return resource, error</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        resource.Release()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    profile := check loadProfile() <span class="comment">// return profile, error</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        profile.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有兴趣的同学请关注<a href="https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md" target="_blank" rel="noopener">这个提案</a>。题外话，还有一个<code>try</code><a href="https://go.googlesource.com/proposal/+/master/design/32437-try-builtin.md" target="_blank" rel="noopener">提案</a>正式被<a href="https://github.com/golang/go/issues/32437#issuecomment-513002788" target="_blank" rel="noopener">否了</a>。</p><p>所以，在<code>Golang</code>中我们目前可以使用的方式，就是以<code>error</code>接口为基础，通过不同的错误类型，来向消费方提供有价值的信息。</p><h2 id="可恢复故障具体该怎么抛"><a href="#可恢复故障具体该怎么抛" class="headerlink" title="可恢复故障具体该怎么抛"></a>可恢复故障具体该怎么抛</h2><p>重点来了，说了这么多，错误终归是要扔出去的，虽然都是统一的<code>error</code>接口，但是手法却应该仔细斟酌。</p><h3 id="错误应该包含的信息"><a href="#错误应该包含的信息" class="headerlink" title="错误应该包含的信息"></a>错误应该包含的信息</h3><p>错误最主要包含的，就是错误信息，是给人类阅读使用的，更确切的讲，是<strong>给开发者阅读的</strong>。所以<code>error</code>接口里的<code>Error() string</code>直接将这个信息返回。那为什么要返回<code>error</code>，而不是直接返回<code>string</code>呢？因为在开发过程中，我们往往需要一些额外的信息。</p><p>首先，如果只有错误的文本，我们很难定位到具体的出错地点。虽然通过在代码中搜索错误文本也是有可能找到出错地点的，但是信息有限。所以，在实践中，我们往往会将出错时的调用栈信息也附加上去。调用栈对消费方是没有意义的，从隔离和自治的角度来看，消费方唯一需要关心的就是错误文本和错误类型。调用栈对实现者自身才是是有价值的。所以，如果一个方法需要返回错误，我们一般会使用<code>errors.WithStack(err)</code>或者<code>errors.Wrap(err, &quot;custom message&quot;)</code>的方式，把此刻的调用栈加到<code>error</code>里去，并且在某个统一地方记录日志，方便开发者快速定位问题。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/pkg/errors"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindUser</span><span class="params">(userId <span class="keyword">string</span>)</span> <span class="params">(*User, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> userId == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"userId is required"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user, err := db.FindUserById(userId)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"query user %s failed"</span>, userId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，在记录日志的地方通过使用<code>%+v</code>格式化占位符就可以把堆栈信息完整的记录下来。</p><p>其次，如果是业务执行时的错误，只有错误消息的话，往往是不够的，因为调用方更加关心错误背后业务上的原因，例如，提交订单接口返回了<strong>提交订单失败</strong>的错误，为什么失败？这个时候就需要某种机制来告诉调用者一些业务上的原因。显然，如果通过错误消息告诉的话，调用方就不得不对错误文本进行判断，这很不优雅，所以我们往往通过其它两种方式来处理。</p><p><strong>1. 特定错误类型</strong>，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrInventoryInsufficient      = errors.New(<span class="string">"product inventory insufficient"</span>)</span><br><span class="line">    ErrProductSalesTerritoryLimit = errors.New(<span class="string">"product sales torritory limit"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ordering</span><span class="params">(userId <span class="keyword">string</span>, preOrder *PreOrder)</span> <span class="params">(*model.Order, error)</span></span> &#123;</span><br><span class="line">    order := &amp;model.Order&#123;&#125;</span><br><span class="line"></span><br><span class="line">    shippingAddress := preOrder.Shipping</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> preOrder.Items &#123;</span><br><span class="line">        <span class="keyword">if</span> findInventory(item.Product.Id) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrInventoryInsufficient</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !isValidSalesTerritory(item.Product.Id, shippingAddress) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrProductSalesTerritoryLimit</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        order.AddItem(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other processing</span></span><br><span class="line">    <span class="keyword">return</span> order, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，消费方拿到错误后，可以很简单的判断一下就能知道具体发生了什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserOrderController</span><span class="params">(ctx context.Context, preOrder *PreOrder)</span></span> &#123;</span><br><span class="line">    <span class="comment">// some preparing</span></span><br><span class="line">    user := FromContext(ctx)</span><br><span class="line">    order, err := service.Ordering(user.userId, preOrder)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> err &#123;</span><br><span class="line">            <span class="keyword">case</span> service.ErrInventoryInsufficient:      <span class="comment">// handling</span></span><br><span class="line">            <span class="keyword">case</span> service.ErrProductSalesTerritoryLimit: <span class="comment">// handling</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也是很多组件向外部提供错误的首选方式，例如，<code>mongo.ErrNoDocuments</code></p><p>但是遗憾的是，如果是跨边界的<code>RPC</code>调用的话（假如刚才的<code>Ordering</code>是个微服务），那么就不能采用这种方式了，因为错误<strong>类型</strong>是无法有效序列化的，即使序列化了也失去了类型判断的能力。所以，我们在集成有边界的服务时，往往会采用另一种方式。</p><p><strong>2. 错误标记</strong>，也就是通过某种约定好的标记，用于表示某种类型的业务错误。客户端调用远程的<code>Restful</code>服务也是边界与边界间的调用，所以我们经常可以在<code>API</code>的文档中看到这样的模式：</p><table><thead><tr><th>返回码</th><th>错误码描述</th><th>说明</th></tr></thead><tbody><tr><td>40001</td><td>invalid credential</td><td>不合法的调用凭证</td></tr><tr><td>40002</td><td>invalid grant_type</td><td>不合法的 grant_type</td></tr></tbody></table><p>这里的返回码就是一种约定好的标记，也叫<strong>业务码</strong>。所谓跨边界调用，也可以换个说法，叫做进程间通讯，如果只在进程内通讯，那使用特定错误类型就足够了，但是一旦出了进程，就需要某种标记手段了。</p><p><code>Golang</code>在实践中也可以采用这种方式，尤其是在边界间传递错误的时候：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"regexp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BusinessError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code    <span class="keyword">string</span> <span class="string">`json:"code"`</span></span><br><span class="line">    Msg     <span class="keyword">string</span> <span class="string">`json:"msg"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(be BusinessError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Printf(<span class="string">"[%s] %s"</span>, be.Code, be.Msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> codeReg = regexp.MustCompile(<span class="string">"^\\d&#123;6&#125;$"</span>)</span><br><span class="line"><span class="comment">// factory method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBusinessError</span><span class="params">(code <span class="keyword">string</span>, msg <span class="keyword">string</span>)</span> *<span class="title">BusinessError</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !codeReg.MatchString(code) &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"code can only contain 6 numbers"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"msg is required"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;BusinessError&#123; code， msg &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrInventoryInsufficient      = NewBusinessError(<span class="string">"301001"</span>, <span class="string">"product inventory insufficient"</span>)</span><br><span class="line">    ErrProductSalesTerritoryLimit = NewBusinessError(<span class="string">"301002"</span>, <span class="string">"product sales torritory limit"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注意<code>NewBusinessError</code>内部使用的是<code>panic</code>，这背后的思考是，如果程序初始化时连错误码的定义都能出现问题，我倾向于让程序跑不起来，这样便在开发阶段就能妥善处理。</p><p>消费方拿到反序列化后的错误时，里面已经包含了标记，查询文档分别做处理就好。不管是<code>Restful</code>，还是<code>GRPC</code>、<code>GraphQL</code>，都可以使用这种模式来处理。甚至更大好处是，客户端不必判断错误文本并设法解析出用户友好的提示，服务不再提供用户提示（想想看，如果要对错误文本提供<code>i18n</code>支持的话，得多难看……），一切都交给客户端去自主选择。</p><h3 id="错误信息应该暴露多少"><a href="#错误信息应该暴露多少" class="headerlink" title="错误信息应该暴露多少"></a>错误信息应该暴露多少</h3><p><strong>暴露多少错误细节，取决于对这个错误感兴趣的一方是谁。</strong><br><strong>暴露多少错误细节，取决于对这个错误感兴趣的一方是谁。</strong><br><strong>暴露多少错误细节，取决于对这个错误感兴趣的一方是谁。</strong></p><p>如果感兴趣一方是其他开发者，那么事情就会变的愉快很多，因为，开发者感兴趣的错误，一般都是<strong>bug</strong>或者<strong>缺陷</strong>，我们不必把所有的细节都解释给开发者，但是必要的信息是要提供的，比如一个简单的错误文本。</p><p>举个例子，我们正在写一个包，其中有一个用于发送（大陆）短信的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"regexp"</span></span><br><span class="line">    <span class="string">"github.com/pkg/errors"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    phoneRegexp = regexp.MustCompile(<span class="string">"^((\\+86)|(86))?\\d&#123;11&#125;$"</span>)</span><br><span class="line">    ErrPhoneSmsExceedLimit = errors.New(<span class="string">"target phone exceed send limits"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendSms</span><span class="params">(phone <span class="keyword">string</span>, content <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> phone == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"phone is required"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> content == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"content is required"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !phoneRegexp.MatchString(phone) &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"phone format incorrect"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> exceedLimits(phone) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrPhoneSmsExceedLimit</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用<code>SendSms</code>的人只可能是开发者，所以简单的将错误信息返回就可以了，无须再多做处理。</p><p>这里需要插一句，一切的错误都会影响消费方的执行（除非消费方总是忽略错误），所以总会在某个地方将我们返回的错误展示给开发者。</p><p>在上面这个例子中，我们已经要求了<code>phone</code>和<code>content</code>不应该为空字符串，那么消费方为什么还要给我空字符串呢？<strong>这是 bug</strong>。</p><p>另外，如果手机号超过了每日发送的条数限制，这<strong>不是 bug</strong>，而是业务错误，所以我们用<code>ErrPhoneSmsExceedLimit</code>提醒开发者，需要额外留意和处理一下，必要的时候用一些友好信息告诉用户。在该例子中是假定<code>SendSms</code>和消费方处于同一进程，所以只需要通过判断<code>err == sms.ErrPhoneSmsExceedLimit</code>就可以准确的捕获到业务错误。那如果这个发短信的方法在一个微服务之后呢？上面我们也提到了，这时候需要有某种标记：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">var</span> ErrPhoneSmsExceedLimit = NewBusinessError(<span class="string">"310001"</span>, <span class="string">"target phone exceed send limits"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendSms</span><span class="params">(phone <span class="keyword">string</span>, content <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> exceedLimits(phone) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrPhoneSmsExceedLimit</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是殊途同归了？当然了，这其中还涉及到一些边界上对错误的包装与转换，我们在后面会提到。</p><p>那么接下来，如果这个方法还需要调用一些别的<code>RPC</code>（这里假定是个<code>Restful</code>服务）才能完成最终的发送，并且调用有可能会有错误，该怎么处理呢？我们会包装它：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendSms</span><span class="params">(phone <span class="keyword">string</span>, content <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    provider := service.NewSmsProvider(<span class="string">"appid"</span>, <span class="string">"appsecret"</span>)</span><br><span class="line">    res, err := provider.Send(phone, content)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.Wrapf(err, <span class="string">"send sms to phone %s failed"</span>, phone)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，消费方看到的只是<code>send sms to phone xxx failed</code>（包装进去的低层<code>err</code>会在边界处切掉），不过不影响我们服务本身打印出调用栈，方便我们知道是我们使用<code>RPC</code>的姿势有问题，还是网络出现故障了，还是……总之，我们进行不下去了。我们不必告诉消费方这些低层的错误细节，但是我们需要保留这些细节方便自己。</p><p>我们继续思考，如果调用<code>RPC</code>成功返回了，就一定代表成功了吗？当然不是，没有<code>err</code>很可能只是说明整个<code>RPC</code>成功完成，但没说业务一定是成功的呀，所以我们还得对<code>res</code>进一步分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendSms</span><span class="params">(phone <span class="keyword">string</span>, content <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    res, err := provider.Send(phone, content)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> res.Code &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"0000"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"1001"</span>:</span><br><span class="line">            log.Printf(<span class="string">"sms provider report [%s] insufficient balance"</span>, res.code)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            log.Printf(<span class="string">"sms provider report [%s] %s"</span>, res.Code, res.Msg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"send sms failed"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已知的业务码只有<code>0000</code>代表成功，所以返回<code>nil</code>表示本次调用成功；<code>1001</code>代表余额不足，其它的我们可能并不关心，那么在简单的记录日志之后，返回给调用方的只有<code>send sms failed</code>。这是因为，我的错误我知道，我依赖服务的错误我也应该知道，但是，依赖我的服务如果不是使用姿势不对，或者业务不正确的话，没有理由了解这背后发生的过多细节，唯一需要让消费方知道的就是<strong>没成功</strong>。与此同时，我们记录了所有的细节，不管是显式的<code>log.Printf</code>还是在边界上打印的调用栈，都将进一步帮助我们分析和修复错误，或者改善实现细节。</p><p>那么，如果此时<code>SendSms</code>方法还需要调用并处理另一个<strong>内部</strong>的方法<code>darkMagic(phone string) error</code>返回的错误呢？没关系，仍然<code>errors.Wrap(err, &quot;cannot perform such operation&quot;)</code>就好了。这不仅仅是给调用方看，更重要的是，这说明了在<code>darkMagic</code>里<strong>可能有一个 bug</strong>，需要我们自己处理，因为，我们是最清楚这些逻辑的，如果一切检查（参数的，业务的）都没问题，还会在内部出错，那么就可能是我们的实现有问题了。好在，这一类的缺陷通过单元测试一般都可以检测出来。</p><blockquote><p>一个小问题，<code>darkMagic()</code>里如果调用<code>spellForce()</code>又得到<code>error</code>了怎么办？<br>答案是，直接<code>return err</code><br>堆栈信息在<code>spellForce()</code>扔出的<code>error</code>里就有了，错误信息也很明确，着实不用再包装一层。<br>也就是说，进程内遇到的<code>error</code>，只在离边界最近的地方才需要<code>errors.Wrap()</code>成对调用方友好（和隐藏细节）的<code>error</code>，其它的都直白的往上<code>return err</code>就好</p></blockquote><p>总结一下：</p><ul><li>你使用我的姿势不对，例如空字符串，会造成我的错误，直接返回<code>errors.New()</code>，这是<strong>bug</strong>，你去处理</li><li>你使用的姿势是对的，我定睛一看是业务上问题，给你一个让你有机会通过<strong>错误类型</strong>或者<strong>错误码</strong>知道的原因，你<strong>酌情处理</strong></li><li>你使用的姿势是对的，我检查发现业务也没毛病，但是我依赖的一些服务（例如数据库）出幺蛾子了，那么我会<code>Wrap</code>成一个既方便我调查原因，同时在不让你关注过多细节的前提下告诉你：<strong>失败了</strong>，你<strong>酌情处理</strong>，例如重试或者告诉最终用户“我们的服务开了会小差，请稍后重试”等</li><li>如果我觉得这一定是个很严重的问题，并且我也无法解决，同时认为你也不该尝试解决，那么就<code>panic</code>吧。这一点在在线业务上几乎遇不到，除了“内存满了”、“堆栈爆了”这些无法抗拒的原因，<code>panic</code>的很少会有</li></ul><h2 id="可恢复故障如何处理"><a href="#可恢复故障如何处理" class="headerlink" title="可恢复故障如何处理"></a>可恢复故障如何处理</h2><p>我们在“错误信息应该暴露多少”一节里已经展示过一些处理方式，尤其是对跨越多层边界的错误，进程内遇到错误的情形等。非边界处的错误处理很直白，上一节也做出了解释和示例，这一节我们讨论一下在边界处如何处理遇到的<code>error</code>。</p><p>所谓边界，就是离调用方最近的地方，调用方可以是某个服务，也可以是用户使用的某种客户端，总之是在消费你在边界处提供的服务。边界以内，只有进程内可见。</p><p>所以，我们可以认为，一个<strong>用户微服务的<code>GetUserById()</code></strong>在边界上，一个<code>beego.Get(&quot;/&quot;, func(ctx *context.Context){})</code> 用<code>MVC</code>实现的方法也在边界上。</p><p>通常情况下，在边界处，我们就需要对下游产生的错误做出判断，同时，对一些非业务错误进行包装，隐藏错误细节。如果边界不是面向最终用户的，那么也会提供一些开发者友好的错误文本。</p><p>我们分别来这其中处理错误的不同。</p><h3 id="面向非用户的边界"><a href="#面向非用户的边界" class="headerlink" title="面向非用户的边界"></a>面向非用户的边界</h3><p>对于一个用户<strong>微服务</strong>的<code>GetUserById()</code>，它的消费方一般不会是最终用户，而是某种<strong>聚合网关</strong>或者其它<strong>微服务</strong>，所以它藏匿在整个安全壁垒之后。我们通常会这么处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"github.com/pkg/errors"</span></span><br><span class="line">    <span class="string">"go.mongodb.org/mongo-driver/bson"</span></span><br><span class="line">    <span class="string">"go.mongodb.org/mongo-driver/bson/primitive"</span></span><br><span class="line">    <span class="string">"go.mongodb.org/mongo-driver/mongo"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> ErrUserNotValid = NewBusinessError(<span class="string">"500213"</span>, <span class="string">"user is not valid"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserById</span><span class="params">(userId <span class="keyword">string</span>)</span> <span class="params">(*model.User, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> userId == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"userId is required"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uid, err := primitive.ObjectIDFromHex(userId)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"userId format incorrect"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user := &amp;model.User&#123;&#125;</span><br><span class="line">    coll := db.Collection(<span class="string">"users"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := coll.FindOne(context.TODO(), bson.M&#123;<span class="string">"_id"</span>: uid&#125;).Decode(user); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err == mongo.ErrNoDocuments &#123;</span><br><span class="line">            <span class="comment">// maybe return nil, nil is fine</span></span><br><span class="line">            <span class="comment">// but, depends on design, be careful</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"cannot perform such operation"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// maybe do local business check</span></span><br><span class="line">    <span class="keyword">if</span> localBusinessCheck(user) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrUserNotValid</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// maybe call RPC to do business action</span></span><br><span class="line">    fine, err := rpc.BusinessAction(user)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// err usually wrapped in rpc particular message type</span></span><br><span class="line">        <span class="comment">// so we need abstract real error from wrapper type</span></span><br><span class="line">        rpcStatus := rpc.Convert(err)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rpcStatus.Type == rpc.Status_Business_Error &#123;</span><br><span class="line">            code := rpcStatus.GetMeta(<span class="string">"code"</span>)</span><br><span class="line">            msg  := rpcStatus.GetMeta(<span class="string">"msg"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, NewBusinessError(code, msg)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cause := rpcStatus.Error()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(cause, <span class="string">"service unavailable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !fine &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrUserNotValid</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段示例很有意思。首先，如何处理下游支撑服务返回的异常？支撑服务（例如数据库、缓存、中间件等等）往往没有业务，它们返回的错误就是单纯的错误，需要开发者每时每刻关注和处理。所以，在这里直接包装并返回。于此同时，<code>GetUserById()</code>的消费方得到了只应该它们关注的<code>cannot perform such operation</code>，而在用户微服务里，我们得到了完整的调用栈和错误信息。</p><p>其次，本地的业务检查如果失败，我们将直接返回一个预定义好的<code>ErrUserNotValid</code>，表示一个业务上的失败。</p><p>最后，如果涉及进一步的远程<code>RPC</code>调用，事情会变的稍微麻烦一些。远程的<code>RPC</code>调用可能有错误，但是错误类型比较复杂。通过<code>RPC</code>的方式传递错误不如进程内调用那么简单直白，为了能够顺利序列化，很多的<code>RPC</code>框架都会将错误信息打包成为某种专有的结构，所以，我们需要一些手段从这些专有结构中提取出我们需要的信息出来。</p><blockquote><p>GRPC 会将错误打包成为<code>google.golang.org/genproto/googleapis/rpc/status</code>包中的<code>status.Status</code>结构，<code>status.Status</code>里包含了<code>Code</code>、<code>Message</code>、<code>Details</code>，我们通常可以约定<code>Code</code>为<code>10</code>代表业务错误（10 代表 Aborted），同时将业务码打包进<code>Details</code>里。</p></blockquote><blockquote><p>GraphQL 也有类似的方式，在返回的数据中，除了包含正常数据的<code>data</code>字段外，还有一个<code>errors</code>数组字段。一般发生错误时，会通过<code>errors.[].message</code>提供错误信息供客户端使用，但当我们需要提供业务码信息时，这个字段显然不太适合使用。不过好在，除了<code>errors.[].message</code>，GraphQL 还提供了<code>errors.[].extensions</code>结构用于扩展错误信息。于是乎，可以和消费方约定一个业务码所使用的具体字段，例如<code>errors.[].extensions.code</code>，如此便很好的解决了问题。</p></blockquote><blockquote><p>Restful 的方式其实很像是 GraphQL 的方式，由于<code>http</code>上不提供额外的序列化通道，能用的只有<code>body</code>这一个选项（用<code>header</code>？不能够！），所以看起来只能提供<code>{ &quot;data&quot;: {}, &quot;err_code&quot;: &quot;&quot;, &quot;err_msg&quot;: &quot;&quot; }</code>这样的万能包装。其实大可不必，没有错误的情况下，正常把数据写入<code>body</code>，当出现业务错误时，只要返回<code>{ &quot;err_code&quot;: &quot;&quot;, &quot;err_msg&quot;: &quot;&quot; }</code>，<strong>同时把 status code 设置为 400</strong>即可，这样就能把万能的<code>data</code>字段解放出来了。如果是一般的错误，例如少参数、参数不允许为空等，这时候不用提供<code>err_code</code>，只提供<code>err_msg</code>，<strong>同时把 status code 设置为 400</strong>即可。一股脑的<code>200</code>真的不是什么好设计。</p></blockquote><p>通过<code>rpc.Convert()</code>类似的工具函数，我们能从<code>RPC</code>的<code>error</code>中拿到原始的结构数据，然后通过判断，确定是否为业务上的错误（所代表的类型），进而将原始的业务错误重新向外扔出，不需要做额外的处理。如果不是业务上的错误，那么就是<strong>bug</strong>、缺陷或者传输级别的故障，我们仍旧可以通过包装扔出，留下堆栈和详细信息在微服务内。</p><p>这或多或少的需要一种<strong>统一的设计和约定</strong>，例如将<code>RPC</code>错误的类型字段的某个特定 key，约定好专门用于存放业务错误码，否则的话将无法区分“业务错误”和“其它错误”。</p><p>示例中关于<code>RPC</code>错误的代码稍显啰嗦，我们其实可以稍微重构一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleRpcError</span><span class="params">(err error, wrapMsg <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rpcStatus := rpc.Convert(err)</span><br><span class="line">    <span class="keyword">if</span> rpcStatus.Type == rpc.Status_Business_Error &#123;</span><br><span class="line">        code := rpcStatus.GetMeta(<span class="string">"code"</span>)</span><br><span class="line">        msg  := rpcStatus.GetMeta(<span class="string">"msg"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, NewBusinessError(code, msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cause := rpcStatus.Error()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(cause, wrapMsg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in pratice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindUserById</span><span class="params">(userId <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    fine, err := rpc.BusinessAction(user)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, handleRpcError(err, <span class="string">"service unavailable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如果是更靠近最终用户的“边界”，又该如何处理呢？</p><h3 id="面向用户的边界"><a href="#面向用户的边界" class="headerlink" title="面向用户的边界"></a>面向用户的边界</h3><p>很明确的就是，首先用户很大程度上是关心<strong>业务码</strong>的，至少用户使用的客户端是关心的；其次，用户是不关心什么连接字符串错误、<code>userId is required</code>等等这些错误的。所以，<strong>业务错误需要明确给出，前置检查错误只给开发者，其它不可预料的错误全部简单转换为“服务当前不可用”</strong>。</p><p>有几个简单的观点：</p><ul><li>有业务码错误的才需要对用户显示信息，其它的一律可显示为视为<strong>出错了，请稍后重试</strong></li><li>有业务码的，说明是非技术的错误，其他一切要么是<strong>bug</strong>，需要开发人员在上线前处理完毕，要么是运行错误，比如数据库异常。需要告诉用户的只有<strong>出错了，请稍后重试</strong>，不会也不能再告诉更多</li><li>身份证号格式不对，电话号格式不对，这种错误在严格意义上算是<strong>bug</strong>，应该在调用<code>API</code>前就检验好的。如果设计不那么严格，可以适当的返回业务码帮助一下，但也只是友情帮助，该客户端做的验证还是得做的</li></ul><p>我们来看最后一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/pkg/errors"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> ServiceUnavailableMessage = <span class="string">"service unavailable"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LoginReq <span class="keyword">struct</span> &#123;</span><br><span class="line">    Username <span class="keyword">string</span></span><br><span class="line">    Password <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Login</span><span class="params">(ctx context.Context, req LoginReq)</span> <span class="params">(*model.Credential, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> req.Username == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"username is required"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> req.Password == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"password is required"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FindByUsername</span></span><br><span class="line">    <span class="comment">// maybe got business error: '[10011] user doesn't exists'</span></span><br><span class="line">    user, err := rpc.UserService.FindByUsername(req.Username)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, handleRpcError(err, ServiceUnavailableMessage)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SignIn</span></span><br><span class="line">    <span class="comment">// maybe got business error: '[20001] account is disabled'</span></span><br><span class="line">    <span class="comment">// maybe got business error: '[20002] password is incorrect'</span></span><br><span class="line">    <span class="comment">// maybe got business error: '[20003] login place abnormal'</span></span><br><span class="line">    cred, err := rpc.AccountService.SignIn(user.Id, req.Password)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, handleRpcError(err, ServiceUnavailableMessage)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    credential := &amp;model.Credential&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> err := credential.Load(cred); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.Wrap(err, ServiceUnavailableMessage)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> credential, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是非常常见的一种<code>API</code>服务的写法，我省去了一些不必要的细节，例如<code>Routing</code>或者<code>Response</code>相关的东西。其实和普通的微服务实现没有什么两样，除了几个小细节：</p><ul><li>对参数的校验还是必要的，不能因为微服务校验过参数，消费方就不做校验了</li><li>除了参数校验的错误，仍然需要对下游服务返回的业务错误同步的向上返回</li><li>除了参数错误和业务错误，其它的错误会包装成<code>service unavailable</code>，不向用户泄露任何的技术细节</li></ul><p>通常，在这种类型的服务中，会有一个类似中间件的东西，统一的处理一切的错误（或者，建议自己实现一个），或者叫全局的错误处理函数、生命周期钩子等等，总之在我们的<code>Login()</code>函数返回错误后，能够以统一的方式响应给用户端，那具体会是什么样呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">type</span> UserError <span class="keyword">struct</span> &#123;</span><br><span class="line">    ErrCode <span class="keyword">string</span> <span class="string">`json:"err_code"`</span></span><br><span class="line">    ErrMsg  <span class="keyword">string</span> <span class="string">`json:"err_msg"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleGlobalError</span><span class="params">(ctx HttpContext, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e, ok := err.(*BusinessError); ok &#123;</span><br><span class="line">            ue := &amp;UserError&#123;</span><br><span class="line">                ErrCode: e.Code,</span><br><span class="line">                ErrMsg:  e.Msg,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ctx.Response.WriteJson(ue)</span><br><span class="line">            ctx.Response.SetStatus(<span class="number">400</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ue := &amp;UserError&#123;</span><br><span class="line">                ErrMsg:  err.Error(),</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ctx.Response.WriteJson(ue)</span><br><span class="line">            ctx.Response.SetStatus(<span class="number">400</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这个函数只是概念上的解释，具体到每一个不同的场景会有不同的<code>API</code>和方式。实际上，如果能够支持这种全局错误处理，那么<code>credential.Load(cred)</code>产生的错误实际都不用<code>Wrap</code>，只需在处理全局错误的时候，直接将非业务错误的<code>UserError</code>的<code>ErrMsg</code>设置成<code>service unavailable</code>就可以了，这也避免了处处都<code>errors.Wrap(err, ServiceUnavailableMessage)</code>，让简洁性更进一步。</p><p>如此，世界得以清静。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何优雅的在&lt;code&gt;Golang&lt;/code&gt;中进行错误处理？&lt;/p&gt;
&lt;p&gt;答案是：没有……（本文完）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;开个玩笑，&lt;code&gt;Golang&lt;/code&gt;中的错误处理方式一直是社区热烈讨论的话题，有力挺者，有抱怨者，但不论如何，自 2009 年&lt;code&gt;Golang&lt;/code&gt;正式发布以来，关于错误处理就一直是现在这种状况。&lt;/p&gt;
&lt;p&gt;随着&lt;code&gt;Golang&lt;/code&gt;愈加的火爆，原本是&lt;code&gt;Java&lt;/code&gt;、&lt;code&gt;Node&lt;/code&gt;、&lt;code&gt;C#&lt;/code&gt;等语言擅长的应用级开发领域也逐渐出现&lt;code&gt;Golang&lt;/code&gt;的身影。&lt;code&gt;Golang&lt;/code&gt;自身其实更加擅长做基础设施级开发，例如&lt;code&gt;docker&lt;/code&gt;，例如&lt;code&gt;k8s&lt;/code&gt;，再如&lt;code&gt;etcd&lt;/code&gt;，它友好的内存管理和简单到粗暴的语法（25 个关键字），特别适合过去&lt;code&gt;C&lt;/code&gt;和&lt;code&gt;C++&lt;/code&gt;这些语言所擅长的部分场景。我们有理由相信，&lt;code&gt;Golang&lt;/code&gt;下一个大的引爆点将也许会在&lt;code&gt;IoT&lt;/code&gt;上，因为它天然的适合。&lt;/p&gt;
&lt;p&gt;当一门语言火起来，就会出现各式各样的应用，于是&lt;code&gt;MVC&lt;/code&gt;框架有了，音视频处理库有了，各种数据库驱动有了，甚至服务框架也出现了，游戏、&lt;code&gt;Machine Learning&lt;/code&gt;都不在话下，还要啥自行车？组合一下做应用级开发妥妥的没毛病。&lt;/p&gt;
&lt;p&gt;但是，成也这 25 个关键字，败也这 25 个关键字，究其根本原因，都是因为它背后&lt;strong&gt;简单&lt;/strong&gt;的哲学。&lt;/p&gt;
&lt;p&gt;做应用级开发可不是那么简单的，这涉及到很多的细节处理，例如本文将要讨论的错误处理。如果只是写一个库，那么这个话题相对比较简单，因为与&lt;code&gt;API&lt;/code&gt;打交道的都是开发者，你只管开心的往外扔&lt;code&gt;error&lt;/code&gt;就好了，总会有倒霉的程序员在使用你的代码时&lt;strong&gt;DEBUG&lt;/strong&gt;到白头，最后，以最严谨的方式，小心使用你的库；可是有人出现的地方就会有幺蛾子，一个常见的误区就是将&lt;strong&gt;业务错误&lt;/strong&gt;、&lt;strong&gt;运行时错误&lt;/strong&gt;、&lt;strong&gt;程序错误&lt;/strong&gt;一股脑的当成相同的&lt;code&gt;error&lt;/code&gt;来处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://lurongkai.github.io/tags/Golang/"/>
    
      <category term="error-handling" scheme="https://lurongkai.github.io/tags/error-handling/"/>
    
      <category term="microservice" scheme="https://lurongkai.github.io/tags/microservice/"/>
    
  </entry>
  
  <entry>
    <title>shinetech 2018 security training summary</title>
    <link href="https://lurongkai.github.io/2019/02/15/shinetech-2018-security-training-summary/"/>
    <id>https://lurongkai.github.io/2019/02/15/shinetech-2018-security-training-summary/</id>
    <published>2019-02-15T05:10:40.000Z</published>
    <updated>2019-02-15T05:22:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>「关注软件开发中的安全」</strong></p><blockquote><p>18年10月底的时候，我在Shinetech Software内部做了一场在线的培训，主要关注的是在软件开发过程中，对于安全方面的工程实践，并不算是很深入的探讨，更多的是一些极不易察觉但又很常见的疏忽，这篇博客整理出来。</p></blockquote><a id="more"></a><h2 id="一切漏洞都可以是注入漏洞"><a href="#一切漏洞都可以是注入漏洞" class="headerlink" title="一切漏洞都可以是注入漏洞"></a>一切漏洞都可以是注入漏洞</h2><h3 id="不要相信来自用户的数据"><a href="#不要相信来自用户的数据" class="headerlink" title="不要相信来自用户的数据"></a>不要相信来自用户的数据</h3><p><strong>e.g. SQL</strong></p><p>如果我们碰到了如下一段代码片断，用于实现将用户通过id从数据库中查询出来，有经验的你一定知道有什么严重的问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var id = ctx.query['id'];</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">USERS</span> <span class="keyword">WHERE</span> <span class="keyword">ID</span> = <span class="keyword">id</span>;</span><br></pre></td></tr></table></figure><p>这段代码从用户的http请求中取出id(查询字符串)，之后然后通过sql拼接生产一条合法的查询语句并执行，正常的请求可能是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /users?id=66721855</span><br><span class="line">[&#123;</span><br><span class="line">    &quot;id&quot;: 66721855,</span><br><span class="line">    &quot;name&quot;: &quot;lurongkai&quot;,</span><br><span class="line">    &quot;addr&quot;: &quot;Tian Jin&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>那么此时执行的是<code>SELECT * FROM USERS WHERE ID = 66721855</code>，这没有问题，但是如果精心构造一个特殊的query string值呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /users?id=1%20OR%201%3D1</span><br><span class="line">1%20OR%201%3D1 --(uri decode) -&gt; 1 OR 1=1</span><br></pre></td></tr></table></figure><p>这样，最后执行的sql就变成了<code>SELECT * FROM USERSWHERE ID = 1 OR 1=1</code>，不解释了，典型的sql注入，一定留意。</p><blockquote><p>想像一下<code>DELETE FROM POSTS WHERE ID = id</code>……</p></blockquote><p>解决的方法其实很简单，大部分的驱动都是支持<code>param</code>构造的，比如可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM USERS WHERE ID = @ID</span><br><span class="line">conn.execute(sql, &#123; ID: id &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>有同学会嘲笑，说这都2019年了，谁还在用sql拼接，我们都ORM甚至nosql了。别大意，有很多你想像不到的场景仍然在大量使用sql拼接，这是一块神奇土壤，而且nosql不见得一定安全，请看下一个例子。</p></blockquote><p><strong>e.g. Mongo</strong></p><p>假设我们有一个不规范的查询接口，使用了POST来查询payments数据，并在body中传递查询的条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST /payments</span><br><span class="line">&#123;</span><br><span class="line">    &quot;f1&quot;: 1</span><br><span class="line">&#125;</span><br><span class="line">=&gt;</span><br><span class="line">[&#123;</span><br><span class="line">    &quot;id&quot;: &quot;5a69b8e0817870269d5fe82c&quot;,</span><br><span class="line">    &quot;amount&quot;: &quot;100&quot;,</span><br><span class="line">    &quot;f1&quot;: 1,</span><br><span class="line">    &quot;createdAtUtc&quot;: &quot;2018-10-01T10:10:10.000&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>返回的是通过给定的条件过滤后的数据。一般此类的接口会限定只能查询自身的数据，所以除非烂到无法拯救，通常是不会查询到其他用户的数据的。后端api的实现可能会是如此：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var q = ctx.body;</span><br><span class="line">var query = &#123; uid: uid, …q &#125;;</span><br><span class="line">db.collection[&apos;payments&apos;].find(q);</span><br></pre></td></tr></table></figure><p>uid来自authentication/authorization中间件。那么最终执行的mongo查询会是<code>db.collection[&#39;payments&#39;].find({ uid: 1 f1: 1 })</code>。接下来我们来构造特殊数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/POST /payments</span><br><span class="line">&#123;</span><br><span class="line">    uid: &#123;</span><br><span class="line">        $ne: -1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行起来会是<code>db.collection[&#39;payments&#39;].find({ uid: { $ne: -1 } })</code>，查到了所有用户的数据。</p><p>这其实不算是个好例子，js的锅可能更大一些。我想在这里表达的是，mongo的<strong>操作符</strong>是存在注入风险的，要留意。</p><p><strong>e.g. XSS</strong></p><p>跨站脚本注入非常常见，假设有以下接口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /blogs</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;: &quot;my blog&quot;,</span><br><span class="line">    &quot;content&quot;: &quot;hello, shinetech&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口用来发布一篇博客，当前端开始展示该博客的时候，对应的可能是这样的代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span>…<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"blog-body"</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"template"</span> <span class="attr">type</span>=<span class="string">"x-tmpl-mustache"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">section</span>&gt;</span>&#123;&#123;&#123; body &#125;&#125;&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $.<span class="keyword">get</span>('/blogs/1', function(data) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> rendered = Mustache.render(template, data);</span></span><br><span class="line"><span class="javascript">        $(<span class="string">'#blog-body'</span>).html(rendered);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们把逻辑剥离开，那么刚才那篇博客对应的html是:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span>…<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"blog-body"</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span>&gt;</span>hello, shinetech<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来开始构造特殊数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /blogs</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;: &quot;my blog&quot;,</span><br><span class="line">    &quot;content&quot;: &quot;hello, shinetech</span><br><span class="line">      &lt;script&gt;/* DO EVIL */&lt;/script&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，渲染后的html是:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span>…<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"blog-body"</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">            hello, shinetech</span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="comment">/* DO EVIL */</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解决的办法也是比较简单，渲染的时候不要使用<code>{{{}}}</code>，而是使用<code>{{}}</code>就好了。</p><blockquote><p>这背后的逻辑其实是这样：mustache不是个例，而是所有的前端页面的渲染都不应该相信用户的输入，都必需要做encoding或者危险标签剔除(这个很有难度)，如果嫌麻烦还可以使用markdown，但不应该直接将用户的数据渲染出来。</p></blockquote><p>最终处理后的html会变成:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span>…<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"blog-body"</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">            hello, shinetech</span><br><span class="line">            %3Cscript%3E%2F%2A+DO+EVIL+%2A%2F%3C%2Fscript%3E</span><br><span class="line">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>e.g. Bounds Checking</strong></p><p>边界检查简直是重灾区，不少祸事都是因为没有做严格的边界检查造成的。</p><p>假设有一个用于转账的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /transfer</span><br><span class="line">&#123;</span><br><span class="line">    &quot;trans&quot;: [&#123;</span><br><span class="line">        &quot;toUser&quot;: &quot;5a69b8f865bdcc26a2ca32ee&quot;, // user a</span><br><span class="line">        &quot;amount&quot;: 100</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        &quot;toUser&quot;: &quot;5a69b8f865bdcc26a2ca32ef&quot;, // user b</span><br><span class="line">        &quot;amount&quot;: 200</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端的实现是这样的（假设js是一门没有溢出检查的语言）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">processTransfer</span>(<span class="params">model</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> balance = getBalance();</span><br><span class="line">    <span class="keyword">const</span> total = _.sumBy(model.trans, t =&gt; t.amount);</span><br><span class="line">    <span class="comment">//假定当前用户的余额是2000</span></span><br><span class="line">    <span class="keyword">if</span> (total &gt; balance) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'insufficient balance '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// maybe in transaction</span></span><br><span class="line">    <span class="keyword">await</span> withdraw(ctx.user.id, total);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> t <span class="keyword">of</span> model.trans) &#123;</span><br><span class="line">        <span class="keyword">await</span> deposit(t.toUser, t.amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在正常情况下，执行的结果应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Before:</span><br><span class="line">Self:                        = 2000</span><br><span class="line">User a:                      = 500</span><br><span class="line">User b:                      = 500</span><br><span class="line"></span><br><span class="line">After:</span><br><span class="line">Self: 2000 - ((100) + (200)) = 1700</span><br><span class="line">User a: 500 + (100)          = 600</span><br><span class="line">User b: 500 + (200)          = 700</span><br></pre></td></tr></table></figure><p>接下来，开始构造特殊数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /transfer</span><br><span class="line">&#123;</span><br><span class="line">    &quot;trans&quot;: [&#123;</span><br><span class="line">        &quot;toUser&quot;: &quot;5a69b8f865bdcc26a2ca32ee&quot;,</span><br><span class="line">        &quot;amount&quot;: -100</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        &quot;toUser&quot;: &quot;5a69b8f865bdcc26a2ca32ef&quot;,</span><br><span class="line">        &quot;amount&quot;: 200</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，结果变为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Before:</span><br><span class="line">Self:                         = 2000</span><br><span class="line">User a:                       = 500</span><br><span class="line">User b:                       = 500</span><br><span class="line"></span><br><span class="line">After:</span><br><span class="line">Self: 2000 - ((-100) + (200)) = 1900</span><br><span class="line">User a: 500 + (—100)          = 400</span><br><span class="line">User b: 500 + (200)           = 700</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /transfer</span><br><span class="line">&#123;</span><br><span class="line">    &quot;trans&quot;: [&#123;</span><br><span class="line">        &quot;toUser&quot;: &quot;5a69b8f865bdcc26a2ca32ee&quot;,</span><br><span class="line">        &quot;amount&quot;: 2147483647</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        &quot;toUser&quot;: &quot;5a69b8f865bdcc26a2ca32ef&quot;,</span><br><span class="line">        &quot;amount&quot;: 1</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果会变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Before:</span><br><span class="line">Self:                       = 2000</span><br><span class="line">User a:                     = 500</span><br><span class="line">User b:                     = 500</span><br><span class="line"></span><br><span class="line">After:</span><br><span class="line">Self: 2000 - ((2147483647) + (1)) = -2147481648</span><br><span class="line">User a: 500 + (2147483647)        = -2147483149</span><br><span class="line">User b: 500 + (1)                 = 501</span><br></pre></td></tr></table></figure><p>第一段数据显示，业务逻辑没有针对负值进行处理，第二段说明没有处理溢出的情况。</p><p>为什么会溢出？</p><p>32位整型的最大值为<code>2^31-1 2147483647</code>，最小值为<code>-2^31 -2147483648</code>，我们举例说明<code>Int32.MaxValue + 1</code>的计算过程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原码:</span><br><span class="line">    0_1111111111111111111111111111111</span><br><span class="line">+   0_0000000000000000000000000000001</span><br><span class="line">=   1_0000000000000000000000000000000</span><br></pre></td></tr></table></figure><p>之后对结果（补码）转换为原码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">补 -&gt; 原(后31位取反加1)</span><br><span class="line">=   1_10000000000000000000000000000000</span><br><span class="line">=   - 2^31 = -2147483648</span><br></pre></td></tr></table></figure><p>再举个<code>2147483647 + (-2147483648) = -1</code>的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运算时:</span><br><span class="line">    0_1111111111111111111111111111111</span><br><span class="line">+   1_0000000000000000000000000000000（内存中，负数都是补码表示）</span><br><span class="line">=   1_1111111111111111111111111111111</span><br><span class="line"></span><br><span class="line">补 -&gt; 原:</span><br><span class="line">    1_0000000000000000000000000000001</span><br><span class="line">    - 1</span><br></pre></td></tr></table></figure><p>所幸，现在的编程语言大多对溢出有了很好的控制，例如会抛出异常，但是针对边界检查上仍然需要留意。</p><h3 id="不要相信外部-第三方-的数据"><a href="#不要相信外部-第三方-的数据" class="headerlink" title="不要相信外部(第三方)的数据"></a>不要相信外部(第三方)的数据</h3><p><strong>e.g. 微信支付</strong></p><p>一般的流程是：</p><ol><li>web|app: GET /wx/params获取支付参数</li><li>web: (jsapi) 跳转到微信支付页面, app: (唤起微信)</li><li>用户在页面或者app完成支付并跳回web|app</li><li>服务端等待微信服务器的回调，并完成对应业务</li><li>web|app拉取最新数据</li></ol><p>通常的实现为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 微信支付回调接口</span></span><br><span class="line">router.post(<span class="string">'/wx/cb'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> rc = ctx.request.body.return_code || <span class="string">''</span> === <span class="string">'SUCCESS'</span>;</span><br><span class="line">    <span class="keyword">const</span> rm = ctx.request.body.return_msg || <span class="string">''</span> === <span class="string">'OK'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!rc || !rm) &#123;</span><br><span class="line">        <span class="comment">// 支付失败的业务逻辑，并回复微信服务器</span></span><br><span class="line">        ctx.body = xml(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;xml&gt;</span></span><br><span class="line"><span class="string">  &lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;</span></span><br><span class="line"><span class="string">  &lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;</span></span><br><span class="line"><span class="string">&lt;/xml&gt;100</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新数据状态 &amp; 更新订单或者其它业务</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>那么我们看看，发现支付的回调接口没有验证来源，其实是可以伪造支持通知请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">curl \</span><br><span class="line">  -H <span class="string">"Content-Type:application/json"</span> \</span><br><span class="line">  -X POST \</span><br><span class="line">  --data <span class="string">'&#123; \</span></span><br><span class="line"><span class="string">    "return_code": "SUCCESS", \</span></span><br><span class="line"><span class="string">    "return_msg": "OK", \</span></span><br><span class="line"><span class="string">    "appid: "", \                    // 可从params里取得</span></span><br><span class="line"><span class="string">    "mch_id: "", \                   // 可从params里取得</span></span><br><span class="line"><span class="string">    "nonce_str: "", \                // 可从params里取得</span></span><br><span class="line"><span class="string">    "sign: "", \                     // 伪造</span></span><br><span class="line"><span class="string">    "openid": "", \                  // 可从params里取得</span></span><br><span class="line"><span class="string">    "trade_type: "", \               // JSAPI、NATIVE、APP</span></span><br><span class="line"><span class="string">    "bank_type: "CMB_CREDIT", \      // 伪造</span></span><br><span class="line"><span class="string">    "total_fee: 100, \               // 可从params里取得</span></span><br><span class="line"><span class="string">    "transaction_id: "wx2018100110101082741", \ // 伪造</span></span><br><span class="line"><span class="string">    "out_trade_no: "", \             // 可从params里取得</span></span><br><span class="line"><span class="string">    "time_end: "20181001101010" \</span></span><br><span class="line"><span class="string">  &#125;'</span> \</span><br><span class="line">  http://demo.api.com/wx/cb</span><br></pre></td></tr></table></figure><p>对于回调类，尤其是第三方的数据来源，一定要做身份或合法性验证。</p><h3 id="也不要过于相信自己的数据"><a href="#也不要过于相信自己的数据" class="headerlink" title="也不要过于相信自己的数据"></a>也不要过于相信自己的数据</h3><p><strong>e.g. 运营商劫持</strong></p><p>很多只使用<code>http</code>协议的app会经常发现页面上有很多第三方的广告或<code>widget</code>这是由于运营商的动态注入造成的。</p><p><img src="/photos/2019-01-15-shinetech-2018-security-training-summary/op_hijack1.png" width="300px"><br><img src="/photos/2019-01-15-shinetech-2018-security-training-summary/op_hijack2.png" width="300px"></p><p>这些http流量在运营商看来就是透明的，所以为了防微杜渐，干脆全走<code>https</code>更加简单。</p><p><strong>e.g. 双向验证</strong></p><p>启用<code>https</code>后事情还没有结束，有可能还会涉及到中间人攻击问题，尤其是app的后端api，传统的过程是这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Browser &lt;------- HTTPS -------&gt; Server</span><br></pre></td></tr></table></figure><p>被中间人攻击后就变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Browser &lt;-------HTTPS -------&gt; (Attacker)</span><br><span class="line">                                    |</span><br><span class="line">                                    | // 证书替换?</span><br><span class="line">                                    |</span><br><span class="line">Server &lt;------- HTTPS -------&gt; (Attacker)</span><br></pre></td></tr></table></figure><p>解决的办法倒也是简单，直接将公钥打包在app中，通讯时强制检查公私钥就行，会安全许多。</p><h2 id="一切-非业务-缺陷都是缺少检查"><a href="#一切-非业务-缺陷都是缺少检查" class="headerlink" title="一切(非业务)缺陷都是缺少检查"></a>一切(非业务)缺陷都是缺少检查</h2><h3 id="前端检查"><a href="#前端检查" class="headerlink" title="前端检查"></a>前端检查</h3><p>前端页面的检查是很有必要的，除了能改善用户体验，还能部分避免后端脆弱所造成的严重问题。但是不能只依靠前端的检查，如果前端/后端的检查有个比重的话，我可能会给出<code>1:9</code>这么毫不夸张的比例：</p><ul><li>input required?</li><li>input type?</li><li>input format? email, phone, number precision/max/min</li><li>password complexity?</li><li>input dependencies?</li><li>date format?</li><li>timezone convert?</li><li>…</li></ul><p>如果忽略这些</p><h3 id="后端验证"><a href="#后端验证" class="headerlink" title="后端验证"></a>后端验证</h3><p>当数据是从用户端产生并提交到服务端时，需要做很多的合法性检查，因为你无法盲目的去相信用户数据：</p><ul><li>illegal fields cleaning</li><li>format checking</li><li>required/dependencies checking</li><li>range/bounds checking</li><li>signature/certification verifying</li><li>anti-forgery token checking(防止重放)</li><li>business logic precondition checking</li><li>…</li></ul><p>能做到这些，就能避免很大一部分的逻辑缺陷和试探。</p><p><strong>e.g. asp.net core mvc</strong></p><p>一个良好实现后端检查的例子（使用C#语言）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookInputModel</span> &#123;</span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    [<span class="meta">RegularExpression(@<span class="meta-string">"^\d&#123;3&#125;-\d-\d&#123;3,4&#125;-\d&#123;4,5&#125;-\d$"</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Isbn &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    [<span class="meta">Range(0, 1000)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"api/books"</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">AutoValidateAntiforgeryToken</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BooksController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    [<span class="meta">Route(<span class="meta-string">""</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Post</span>(<span class="params">[FromBody]BookInputModel model</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ModelState.IsValid) &#123;</span><br><span class="line">            <span class="keyword">return</span> BadRequest(<span class="string">"book data invalid"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">await</span> _bookRepository.HasByIsbn(model.Isbn)) &#123;</span><br><span class="line">            <span class="keyword">return</span> BadRequest(<span class="string">"the specified book already exists"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> serviceDto = Mapper.Map&lt;Book&gt;(model); <span class="comment">// 数据清洗</span></span><br><span class="line">        <span class="keyword">var</span> book = <span class="keyword">await</span> _bookService.Create(serviceDto);</span><br><span class="line">        <span class="keyword">var</span> bookDisplayModel = Mapper.Map&lt;BookDisplayModel&gt;(book); <span class="comment">// 数据清洗</span></span><br><span class="line">        <span class="keyword">return</span> CreatedAtAction(<span class="string">"Get"</span>, bookDisplayModel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">Route(<span class="meta-string">"&#123;id&#125;"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Get</span>(<span class="params">[FromRoute]<span class="keyword">string</span> id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> book = <span class="keyword">await</span> _bookRepository.Find(id);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == book) &#123;</span><br><span class="line">            <span class="keyword">return</span> NotFound();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Ok(Mapper.Map&lt;BookDisplayModel&gt;(book));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂的业务状态检查利器-状态机"><a href="#复杂的业务状态检查利器-状态机" class="headerlink" title="复杂的业务状态检查利器:状态机"></a>复杂的业务状态检查利器:状态机</h3><p>如果我来推荐的话，对于复杂一些的业务，推荐使用状态机建模，避免自顶向下一条龙式的实现，极易出错而且还不易排查和文档化。</p><p>一个假想的例子是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">router.put(<span class="string">'/some/business'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> input = ctx.request.body;</span><br><span class="line">    <span class="keyword">if</span> (!isValid(input)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'input invalid'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> stateInput = parseRaw(input);</span><br><span class="line">    <span class="keyword">const</span> state = <span class="keyword">await</span> loadState(stateInput);</span><br><span class="line">    <span class="keyword">const</span> expected = <span class="keyword">await</span> decideNext(input.action);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">await</span> state.canProcess(expected, input)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'business checking failed, forbidden'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> state.goNext(expected, input);</span><br><span class="line">    <span class="keyword">await</span> saveState(state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ss = state.snapshot;</span><br><span class="line">    <span class="keyword">const</span> mapper = <span class="keyword">new</span> Mapper();</span><br><span class="line">    <span class="keyword">const</span> res = mapper.mapTo(&#123; <span class="attr">ns</span>: <span class="string">'some/business'</span>, <span class="attr">data</span>: ss &#125;);</span><br><span class="line">    ctx.body = res;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然，并不存在这样一种现成的框架，但是如果有精力，我可能会去做这么一个基础模块出来，但是背后的理念是通用的。</p><h2 id="人的因素"><a href="#人的因素" class="headerlink" title="人的因素"></a>人的因素</h2><h3 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h3><p>有没有见过下面这些眼熟的密码？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">12345678</span><br><span class="line">1234567890</span><br><span class="line">111111</span><br><span class="line">aaaaaa</span><br><span class="line">1qaz2wsx#EDC</span><br><span class="line">admin</span><br><span class="line">hello2018</span><br><span class="line">[name]112233</span><br><span class="line">[phone]</span><br></pre></td></tr></table></figure><p>建议还是花一些时间，对内部使用的密码例如数据库连接密码等集中做一次审计，避免因弱口令造成的事故。如果有能力的话，同时建议定期更换密码，并限制到极少数人知道或者通过安全的硬件保存。</p><h3 id="未验证的第三库引用"><a href="#未验证的第三库引用" class="headerlink" title="未验证的第三库引用"></a>未验证的第三库引用</h3><p>一些关于引用第三库的小tips：</p><ul><li>Open Source库可能更安全一些</li><li>下载二进制包时，注意和官方的gpg签名做对比(有良心的都提供)</li><li>去官方下载，不要去xx网盘，宁肯使用有节操的镜像节点</li><li>在使用npm, maven, nuget等registry时，如果下载的是小众包，那么仍然需要慎重，你看到的代码不代表是包中使用的代码，不放心请手动build</li><li>使用互操作时，请更加留意底层的原生库，一个不留神，反手就是一个缓冲区溢出，尽量避免Interop</li><li>docker镜像请使用官方出品，小众镜像请手动docker build(这事儿爆过很严重的事件: ref-&gt; docker123321)</li></ul><h3 id="credentials及源代码管理"><a href="#credentials及源代码管理" class="headerlink" title="credentials及源代码管理"></a>credentials及源代码管理</h3><p>一些关于凭证和SCM的小tips：</p><ul><li>不要以明文存密码，使用hash，必要时还可以加salt</li><li>CI/CD上使用的凭证要注意隐藏，否则会在build日志中看到，例如使用Jenkins的凭证管理</li><li>调用第三方api的凭证不要直接放在源代码中，环境变量是一种选项，或者更好的配置管理方式</li><li>目前github会帮你扫描是否有敏感信息签入代码库，但是仍然需要留意，避免出现第二个”华住”</li><li>不要轻易把私有仓库变成公有仓库，你并不是很清楚提交历史里有什么敏感信息，有必要的话清除历史并检查后新开仓库</li><li>保护好企业的自动化工具，提升工具的安全性，例如保护好Jenkins，保护好内部npm、maven、nuget</li></ul><h3 id="一定要做环境隔离"><a href="#一定要做环境隔离" class="headerlink" title="一定要做环境隔离!"></a>一定要做环境隔离!</h3><p>一些其它的tips：</p><ul><li>生产、测试、开发，不同环境应该使用的所有凭证都不相同</li><li>JWT签发token一定留意Audience，子站A签发的token不见得是给子站B用的</li><li>不同的环境使用不同的JWT Signing Key，这是信仰</li><li>除非不得已，不同的环境间应该完全阻止互通，防止跳板攻击</li><li>生产应该只有极少数人可以操作，尽量避免开发人员操作</li><li>不要在生产环境上调试错误，除非根本没在代码中做日志</li><li>不要在生产上安装各种无用的东西，比如安个360浏览器…再比如安个不知名的根证书，脆弱就是一瞬间</li><li>必要时，连source-map都不要暴露在生产上，dbg符号文件更不能泄露，否则和泄露代码一样</li></ul><h2 id="在实践中"><a href="#在实践中" class="headerlink" title="在实践中"></a>在实践中</h2><p>一些在实践中的小tips：</p><ul><li>慎重选择加密方式，必要的话请使用高强度的非对称加密，并妥善保存私钥<br>代码中的写的日志一定要定期的梳理，不要把敏感信息(例如用户密码)写到日志中(github自己出过这问题)</li><li>定期升级依赖库，虽然有可能会有bug，但是和安全比起来，仍然值得投入<br>类似HeartBleed的漏洞不是普通开发者能避免的，我们能做的就是第一时间升级，然后做好自己的安全</li><li>开发时，时刻进行人格分裂，站在攻击者的角度，思考一下可能会如何攻击</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>需要强调两点：</p><ul><li>安全投资是很昂贵的，我们能做的只能是尽量从开发层面降低伤害</li><li>开发环节、运维环节、基础设施，任何一层都有可能会出现问题</li></ul><p>强烈建议！使用容器或虚拟化技术。</p><blockquote><p>安全遵循木桶理论，缺一块儿都会降低整体可用性</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;「关注软件开发中的安全」&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;18年10月底的时候，我在Shinetech Software内部做了一场在线的培训，主要关注的是在软件开发过程中，对于安全方面的工程实践，并不算是很深入的探讨，更多的是一些极不易察觉但又很常见的疏忽，这篇博客整理出来。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="training" scheme="https://lurongkai.github.io/categories/training/"/>
    
    
      <category term="security" scheme="https://lurongkai.github.io/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>理性沟通的团队</title>
    <link href="https://lurongkai.github.io/2017/03/02/retional-team-with-communication/"/>
    <id>https://lurongkai.github.io/2017/03/02/retional-team-with-communication/</id>
    <published>2017-03-02T13:33:00.000Z</published>
    <updated>2019-02-14T02:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>（部分整理自Shinetech 2016-10-19内部分享）</p><blockquote><p>《敏捷软件开发宣言》<br>我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：</p><p>个体和互动 高于 流程和工具<br>工作的软件 高于 详尽的文档<br>客户合作 高于 合同谈判<br>响应变化 高于 遵循计划</p><p>也就是说，尽管右项有其价值，我们更重视左项的价值。</p></blockquote><p>小而精的团队，往往更具有战斗力。我们提倡敏捷，也愿意相信它的价值，然而敏捷的实践却不仅仅是清晨站会、打打估算扑克那么简单。在我看来，其中最容易被忽视的一句便是：<code>尽管右项有其价值，我们更重视左项的价值</code>。如果一个开发者不写文档的理由是“我敏捷”，这就大错特错了，我所理解的敏捷，是关于『沟通』和『协作』的方式。<br><a id="more"></a></p><p>沟通自然重要，信息在传递中存在损失的可能，所以提倡尽可能的与客户直接沟通获取一手信息，避免经手N个人才到最终的实施者。同样的，部分信息也需要共享给团队成员或者stakeholder，由于沟通存在成本，所以方式方法亦很重要。</p><p>团队也需要协作，看板驱动带来潜在的负面影响就是每个人只关注用例，对项目整体的看法缺失，成员间的协作变少，由此在整个项目上出现了不同的视角。短期内任务是完成了，长远看分裂会逐渐积累。</p><p><strong>敏捷是关于一个团队整体的态度</strong>，那么什么样的态度对团队是有益的呢？我们不妨审视一下以<code>Github</code>为代表的开源开发方式，并引入多种可用的工具，看能不能从中受到一些启发。</p><h1 id="信息的推送与管理"><a href="#信息的推送与管理" class="headerlink" title="信息的推送与管理"></a>信息的推送与管理</h1><p>程序员不喜欢邮件，认为邮件是浪费生命。无缘无故的被加入到邮件列表中，看着大家开始扯皮，扯到最后发现和自己没有一分钱关系，尴尬的是不看又不确定和自己有没有关系。又或者突然转发给自己了一封邮件，打开里面长长的对话，读了很久才知道说了什么。</p><p>这里的问题在于，邮件并不适合归档和提取信息，并且是强干扰因素。不妨回想一下，有没有参与这样一种项目，就是全程没有文档，进入项目组的当天转给你N封邮件让你读？再或者，连看板工具也没有，大家通过一个excel文件，标成黄色背景的你做，标成绿色背景的我做，彼此通过邮件来发送这个excel文件？</p><p>换一种思路，如果没有邮件，我们如何沟通？</p><p><code>Github</code>有个非常好用的工具：<code>Issues</code>，任何人有问题、建议、计划等都会在里面建条目，然后完善<code>Issue</code>的详情并且展开讨论。上千人协作的项目用它用的不亦乐乎，这里的关键在于，信息完全是公开的，任何人都可以讨论，每个人只在必要的时候介入。同时，信息的噪音也很小。</p><p>这也是为什么<code>Github</code>被称为社交化编程。形象的打个比方，邮件好比写博客打架，你写一篇我写一篇，观点被不断放大，而<code>Issue</code>为基础的工作流则更像是<code>Twitter</code>，我说『<code>filtering()</code>方法出错了，报<code>null</code>异常』，下面有人回复『L30的<code>null</code>检查没有做，@Javis 请看一下』。</p><p>接下来，对PM来说，看来这个优先级比较高，马上打了个<code>critical</code>的标签，然后放在了<code>current-milestone</code>并分配给了<code>@Javis</code>，即刻，<code>@Javis</code>的上桌面上收到了通知，1分钟改好后提交了。</p><p>由于故事本身被限制在了一个很小的<code>Item</code>中，每个人可以更加关注于其本身。如果需要引入类似看板的功能，推荐大家试用<code>ZenHub</code>扩展。</p><p>另外，诸如<code>Teambition</code>, <code>Tower</code>, <code>Trello</code>这样的工具也可以提供灵活的任务管理，将一个大的用例切成小的部分，针对每个部分单独讨论，可以降低沟通成本，并且为归档提供了更多参考，不过，这些工具更倾向于客户与开发团队间针对需求和进度的沟通。</p><p>如果只是开发团队内的沟通，<code>Github Issues</code>, <code>Jira</code>, <code>Redmine</code>这些耳熟能详的缺陷跟踪工具一定可以帮助团队，让信息更加的透明，尽可能的减少信息干扰，<strong>降低沟通的成本</strong>。</p><h1 id="随时共享你的想法"><a href="#随时共享你的想法" class="headerlink" title="随时共享你的想法"></a>随时共享你的想法</h1><p>任务管理，或者缺陷跟踪的本质，是为了让信息便于管理和推送，同时带来一个新的挑战就是信息的归档。有很多的任务，其下对应的讨论是很有价值的，如果整个<code>Item</code>都是有限定的在讨论，那么从中提取信息就会变得容易。更进一步，可以将用例的讨论变成使用手册吗？可以将针对某个具体技术点的讨论变成团队共享的知识库吗？</p><p>知识库是全团队受益的，虽然敏捷认为文档的优先级不是最高的，但是绝不是说它不重要。对于程序员来说，有时候并不是不愿意写文档，而是写文档的工具不好用。</p><p>从<code>Github</code>得到的安利，就是好用的<code>wikis</code>工具，你值得拥有。结构化的文档体系，不需要安装任何软件就能写，每个人都能编辑完善，告别<code>word</code>和<code>excel</code>。</p><p>PM和开发人员应该对产生的<code>Issues</code>（或者叫<code>Task</code>）保持敏感，随时准备好提取和分享这些知识。而<code>Email</code>驱动的工作流养成的坏习惯，就是当需要将一些信息提供给他人时，不做任何修饰的把邮件列表转发出去。</p><p>当引入<code>Issues</code>（<code>Task</code>）驱动的工作流时，在它结束或close的时候，是最好的审视时机，回顾一遍，看有没有什么能共享的可以尝试归纳整理，分享是会上瘾的。</p><p>这件事，还有个非常著名的名词，叫做<strong>『知识传递』</strong>。</p><p>怕花钱？怕信息泄露？不妨试试<code>Gollum</code>（<code>Github</code>的<code>wikis</code>也是用它），其它的任务管理、缺陷管理工具也大部分也都提供<code>wikis</code>工具（例如<code>Redmine</code>, <code>Jira</code>），一朝架设终身受益啊。</p><h1 id="非正式的沟通"><a href="#非正式的沟通" class="headerlink" title="非正式的沟通"></a>非正式的沟通</h1><p>有时候面对面的沟通，或者电话会议是无法避免的。任务管理工具也有自身的短板，就是不适合讨论非常复杂的问题。</p><p><code>Skype</code>在语音方面的表现相当的好而且免费，但是作为一个消息工具，它的确显得不怎么好用，或许在与客户沟通时使用<code>Skype</code>已经足够了，但是对程序员来说，频繁的分享代码片断，或者在群聊中@某个人时，它的表现并不抢眼，想加粗某段话都不支持。</p><p>QQ，微信，更不用说，只聊天还行，协作并不是他们所擅长的。</p><p>程序员需要更好的交流工具，尤其是文字的。如果已经使用了<code>Github Issues</code>，就会发现，@某个人，或者链接某段代码非常方便，再者，贴出的代码带有语法高亮让人看着非常舒服，毕竟，程序员之间经常说“黑话”，一段没有高亮并且不是等宽字体的代码非常跌份儿。诚然，<code>Issues</code>作为非正式的沟通工具还是显得太不正式了……</p><p>不如，试试火爆全球的<code>Slack</code>？基于轻量级的<code>Channel</code>（可以想像成一个随意进出的微信群）可以快速拉几个人进行讨论某个<code>Subject</code>，丰富的<code>ref</code>功能可以随意的@人和链接一切，尤为重要的，就是它支持<code>Markdown</code>，而且它足够的轻量，相信试用一下就会爱上它的。</p><p>这并不是故事的全部，最有杀伤力的一点，它可以集成进任何的系统，持续集成、持续部署、运维监测、自动化机器人，比如<code>@WallE deploy production</code>，就会触发部署消息传递到你的运维系统开始部署，试试吧。</p><p>当然了，国外有的中国就早晚会有，就像twitter和微博……国内的『<code>简聊</code>』（Teambition团队做的）做的也非常不错，功能类似，推荐一试。</p><h1 id="善用VCS工具"><a href="#善用VCS工具" class="headerlink" title="善用VCS工具"></a>善用VCS工具</h1><p><code>Github</code>带来的另一个启迪，就是关于源代码管理的方式。众多的VCS工具，从<code>TFS</code>到<code>svn</code>，从<code>Mercurial</code>到<code>git</code>，无疑给了我们太多的选择，用好哪一个都会带来极大的生产力提高，然而事实并不如此。</p><p>很多的团队，仍认为VCS就是个存代码的地方，这或多或少的会给流程带来一定的影响。<code>Github</code>提供的思路很独特，在<code>git</code>的基础上创新的提供了<code>pull request</code>工作流。我们都确信<code>code review</code>带来的价值，我们也认同<code>unit testing</code>为QA带来的红利，但事实上做的人很少，有流程和其它的原因，当然也有工具不够好用的原因。</p><p>而<code>pull request</code>这种方式为我们提供了一种思路。善用工具，就得理解工具背后的文化，比如从<code>svn</code>迁移到<code>git</code>，就不应该在同一个分支上死签入到底了。从任务管理或缺陷管理工具开始一个新的任务，马上新开一个分支，不断的提交与实现，当完成时发起<code>pull request</code>让团队内的其它人来<code>review</code>是一种很好的知识传递的方式，同时，在<code>pull request</code>的窗口期内也可以不断的改善，确保最终的合并是一种完整的合并，这种一致化的体验在其它的VCS系统中是很难做到的。</p><p>相信工具的力量，架个<code>git</code>试试吧，别用<code>svn</code>了，比如试试<code>Gitlab</code>, <code>Gogs</code>，或者用在线的<code>coding.net</code>、<code>码云</code>、<code>Bitbucket</code>，都是免费的而且提供私有托管，不费事儿。</p><h1 id="一个真实的案例"><a href="#一个真实的案例" class="headerlink" title="一个真实的案例"></a>一个真实的案例</h1><p>过去的一段时间，我有幸见证并参与改善了一个团队（以下称A）从土作坊开发到敏捷主动改变的过程，权当是一种茶余饭后的消遣吧，并为大家进行敏捷导入提供一种基于工具的思路。</p><p>A开发团队差不多20人左右，移动端、前端、后端、运维，开始的时候并没有很严格的流程一说，用的是TFS来管理所有代码（所幸用的是TFS git），前端没有仓库，手机端两个仓库，后端5到8个仓库分别对应不同的服务，沟通用QQ，但是与产品团队一起使用Worktile（类似Teambition）。</p><p>初期的流程是这样的，产品团队预先一两周给出需要开发的任务，开发的任务会在Worktile上拆成单个最小需求，后端团队开始将任务分配到人（整体任务），并且是责任制度，谁负责哪个模块就分那个模块相关的任务，开发团队在一周内给出所有移动端和前端需要的接口定义，移动端紧接着开始开发。运维团队有自研的发布系统但几近瘫痪，因为大家都愿意用手动build去服务器覆盖的方式部署，并且通讯工具只有QQ。</p><p>进入团队后的第一件事，就是架设gitlab，将全线的产品从TFS迁移到gitlab，为什么呢？因为gitlab的工具生态系统很完善了，并且……免费。</p><p>之后，开始改善团队流程，引入每日站会，并严格按照敏捷站会发言不打断的原则执行，为什么呢？先培养习惯。几周后，从最初开始大家反映没什么可说，别人说的听不懂（因为只负责自己的部分），到开始限制每人的发言时间，是个极大的转变，团队成员开始对整个项目有了整体的理解了。</p><p>接下来解决后端的问题，发现几个仓库间代码重复严重，没有共享组件而是用原始的复制粘贴，于是大约花了近两个月时间，将原有的后端仓库拆分成十五个左右的独立子仓库，每个仓库安全按照<code>Githab</code>开源软件的方式管理，有问题或缺陷直接去仓库提<code>Issue</code>，也可以跨“职责”提交<code>pull request</code>，并将前端部分从后端仓库中拆出去独立管理和发布。</p><p>氛围变的明朗了许多，并且在本来时间就很紧的进度下，每周集体抽出一到两个小时分享自己“负责”的项目、心得等，虽然刚开始并没有多少人分享，但后来就多了，能明显感受到团队的信心值在增加。每次的分享结束后，我都会将整个分享整理成知识库放在<code>wikis</code>中，后来逐渐的整个团队开始参与，<code>wikis</code>数目上涨非常快。</p><p>这些流程在团队内完全厘清后，最后一个团队大动作就是每周至少2小时的交叉<code>code review</code>，并不是说这种方式有多好，在进度压力过大的情况下的一种变通吧，有总胜过无，更何况<code>code review</code>还真提供了不少新的思路。</p><p>然后就是运维团队，发布时手动去生产环境覆盖这事儿我一直不太能接受，后来和运维的伙伴们一起引入持续集成和持续部署，为此还单独写了一个基于<code>F#</code>的<code>DSL描述库</code>，用来快速配置新服务进行持续集成和发布，最终的效果是所有后端仓库从建<code>Issue</code>到修改完提交，到进行单元测试、打发布包、蓝绿发布（或者发布组件的升级包到内部源），整个过程最快5分钟完成。</p><p>后来将整个流程逐渐推广到前端和移动端团队，团队气氛很不错。</p><p>到离开A团队时，后端大约有20个子系统以及40多个仓库在分别独立的以开源软件的方式运转，团队成员基本可以在所有子项目间无障碍的交叉提交代码，并且还开源了内部开发的用于<code>Kafka</code>的<code>.NET SDK</code>，上述的工具几乎都在使用。不用PM参与，成员就可以自发的对每个系统提出改善的建议和优化。</p><p>一个敏捷理性的团队。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我们讨论一切，最终的目的是想让一个团队，尤其是一个敏捷团队变的理性和主动，要相信工具的力量，并且要变的乐于分享，这些文档、工具、流程不仅可以让团队的生产力更进一层，更重要的是积累下了宝贵的智力资产，这些是省钱省不出来的，也是买不到的。</p><blockquote><p>原分享标题：软件开发的新视野——用高效便捷的工具快速迭代和交付，我做了改动并节选了其中的一部分</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（部分整理自Shinetech 2016-10-19内部分享）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《敏捷软件开发宣言》&lt;br&gt;我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：&lt;/p&gt;
&lt;p&gt;个体和互动 高于 流程和工具&lt;br&gt;工作的软件 高于 详尽的文档&lt;br&gt;客户合作 高于 合同谈判&lt;br&gt;响应变化 高于 遵循计划&lt;/p&gt;
&lt;p&gt;也就是说，尽管右项有其价值，我们更重视左项的价值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小而精的团队，往往更具有战斗力。我们提倡敏捷，也愿意相信它的价值，然而敏捷的实践却不仅仅是清晨站会、打打估算扑克那么简单。在我看来，其中最容易被忽视的一句便是：&lt;code&gt;尽管右项有其价值，我们更重视左项的价值&lt;/code&gt;。如果一个开发者不写文档的理由是“我敏捷”，这就大错特错了，我所理解的敏捷，是关于『沟通』和『协作』的方式。&lt;br&gt;
    
    </summary>
    
    
      <category term="productivity" scheme="https://lurongkai.github.io/tags/productivity/"/>
    
      <category term="collaboration" scheme="https://lurongkai.github.io/tags/collaboration/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程中的常用技巧</title>
    <link href="https://lurongkai.github.io/2015/11/24/functional-programming-skills/"/>
    <id>https://lurongkai.github.io/2015/11/24/functional-programming-skills/</id>
    <published>2015-11-24T08:53:34.000Z</published>
    <updated>2019-04-15T06:17:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Closure、Haskell、Python、Ruby这些语言越来越流行的今天，我们撇开其在数学纯度性上的不同，单从它们都拥有<code>一类函数</code>特性来讲，讨论函数式编程也显得很有意义。</p><p>一类函数为函数式编程打下了基础，虽然这并不能表示可以完整发挥函数式编程的优势，但是如果能掌握一些基础的函数式编程技巧，那么仍将对并行编程、声明性编程以及测试等方面提供新的思路。</p><p>很多开发者都有听过函数式编程，但更多是抱怨它太难，太碾压智商。的确，函数式编程中很多的概念理解起来都有一定的难度，最著名的莫过于<a href="https://en.wikipedia.org/wiki/Monad_(functional_programming" target="_blank" rel="noopener">单子</a>，但是通过一定的学习和实践会发现，函数式编程能让你站在一个更高的角度思考问题，并在某种层面上提升效率甚至是性能。我们都知道飞机比汽车难开，但是开飞机却明显比开汽车快，高学习成本的东西解决的大部分是高回报的需求，这不敢说是定论，但从实践来看这句话基本也正确。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener">wikipedia</a>上对于函数式编程的解释是这样的：</p><blockquote><p>In computer science, functional programming is a programming paradigm—a style of building the structure and elements of computer programs—that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data. </p></blockquote><p>翻译过来是这样的：</p><blockquote><p>在计算机科学中，函数式编程是一种编程范式，一种构建计算机结构和元素的风格，它将计算看作是对数学函数的求值，并避免改变状态以及可变数据。</p></blockquote><p>关键的其实就两点：不可变数据以及函数求值（表达式求值）。由这两点引申出了一些重要的方面。</p><h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p>FP中并没有变量的概念，东西一旦创建后就不能再变化，所以在FP中经常使用“值”这一术语而非“变量”。</p><p>不变性对程序并行化有着深远的影响，因为一切不可变意味着可以就地并行，不涉及竞态，也就没有了锁的概念。</p><p>不变性还对测试有了新的启发，函数的输入和输出不改变任何状态，于是我们可以随时使用REPL工具来测试函数，测试通过即可使用，不用担心行为的异常，不变性保证了该函数在任何地方都能以同样的方式工作。事实上，在函数式编程实践中，“编写函数、使用REPL工具测试，使用”三步曲有着强大的生产力。</p><p>不变性还对重构有了新的意义，因为它使得对函数的执行有了数学意义，于是乎重构本身成了对函数的化简。FP使代码的分析变的容易，从而使重构的过程也变的轻松了许多。</p><h3 id="声明性风格"><a href="#声明性风格" class="headerlink" title="声明性风格"></a>声明性风格</h3><p>FP程序代码是一个描述期望结果的表达式，所以可以很轻松、安全的将这些表达式组合起来，在隐藏执行细节的同时隐藏复杂性。可组合性是FP程序的基本能力之一，所以要求每个组合子都有良好的语义，这和声明式风格不谋而合。</p><p>我们经常写<code>SQL</code>，它就是一种声明性的语言，声明性只提出<code>what to do</code>而不解决<code>how to do</code>的问题，例如下面：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> create_date &gt; <span class="string">'2015-11-21'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> create_date <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p>省去了具体的数据库查询细节，我们只需要告诉数据库要orders表里创建日期大于11月21号的数据，并只要id和amout两个字段，然后按创建日期降序。这是一种典型的声明性风格。</p><blockquote><p>是的，我同意靠嘴是解决不了任何问题的，what to do提出来后总得有地方或有人实现具体的细节，也就是说总是需要有how to do的部分来支持。但是换个思路，假如你每天都在写foreach语句来遍历某个集合数据，难道你没有想过你此时正在重复的how to do吗？就不能将某种通用的“思想”提取出来复用吗？假如你可以提取，那么你会发现，这个提取出来的词语（或函数名）已经是一种what to do层面的思想了。</p></blockquote><p>再比如，对于一个整型数据集合，我们要通过C#遍历并拿到所有的偶数，典型的命令式编程会这么做：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> sourceList) &#123;</span><br><span class="line">    <span class="keyword">if</span>(item % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        result.Add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>这对很多人来说都很轻松，因为就是在按照计算机的思维一步一步的指挥。那么声明性的风格呢？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">return</span> sourceList.Where(item =&gt; item %<span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// or LINQ style</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">from</span> item <span class="keyword">in</span> sourceList <span class="keyword">where</span> item % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">select</span> item;</span><br></pre></td></tr></table></figure><p>甚至更进一步，假设我们有声明性原语，可以做到更好：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="comment">// if we already defined an atom function like below:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">NumberIsEven</span>(<span class="params"><span class="keyword">int</span> number</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then we can re-use it directly.</span></span><br><span class="line"><span class="keyword">return</span> sourceList.Where(NumberIsEven);</span><br></pre></td></tr></table></figure><blockquote><p>说句题外话，我有个数据库背景很深的C#工程师同事，第一次见到LINQ时一脸不屑的说：C#的LINQ就是抄SQL的。其实我并没有告诉它C#的LINQ借鉴的是FP的高阶函数以及monad，只是和SQL长的比较像而已。当然我并不排除这可能是为了避免新的学习成本所以选用了和SQL相近的关键字，但是LINQ的启蒙却真的不是SQL。</p></blockquote><blockquote><p>我更没有说GC、闭包、高阶函数等先进的东西并不是.NET抄Java或者谁抄谁，大家都是从50多年前的LISP以及LISP系的Scheme来抄。我似乎听到了apple指着ms说：你抄我的图形界面技术…</p></blockquote><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>在FP中，每个表达式都有对应的类型，这确保了表达式组合的正确性。表达式的类型可以是某种基元类型，可以是复合类型，当然，也可以是支持泛型类型的，例如F#、ML、Haskell。类型也为编译时检查提供了基础，同时，也让屌炸天的类型推断有了根据。</p><p>F#的类型推断要比C#强太多了，一方面是受益于ML及OCamel的影响，一方面是在CLR层面上泛型的良好设计。很多人并不知道F#的历史可以追溯到.NET第一个版本的发布（2002年），而当时F#作为一个研究项目，对泛型的需求很大，遗憾的是.NET第一版并没有从CLR层面支持泛型。所以，F#团队参与设计了.NET的泛型设计并加入到.NET 2.0开始的后续版本，这也同时让所有.NET语言获益。</p><p>那么我们以不同的视角审视一下泛型。何为泛型？泛型是一种代码重用的技术，它使用类型占位符来将真正的类型延迟到运行时再决定，类似一种类型模板，当需要的时候会插入真实的类型。我们换一个角度，将泛型理解为一种包装而非模板，它打包了某种具体的类型，使用类似F#的签名表达会是这样：<code>&#39;T -&gt; M&lt;&#39;T&gt;</code>，转变这种思维很重要，尤其是在编写F#的计算表达式（即Monad）时，经常会使用<strong>包装类</strong>这个术语。在C#中也可以看到类似的方面，例如<code>int?</code>其实是指<code>Nullable&lt;T&gt;</code>对<code>int</code>类型的包装。</p><h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p>由于整个程序就是一个大的表达式，计算机在不断的求值这个表达式的同时也就意味着我们的程序正在运行。那么很有挑战的一方面就是，程序该如何组织？</p><p>FP中没有语句的概念，就连常用的绑定值操作也是一个表达式而非语句。那么这一切如何实现呢？假设我们有下面这段C#代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="number">9</span>;</span><br></pre></td></tr></table></figure><p>我们有两个赋值语句（并且有先后依赖），如何用表达式的方式来重写？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="comment">// we build this helper function for next use.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Eval</span>(<span class="params"><span class="keyword">int</span> binding, Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; continues</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> contineues(binding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then, below sample is totally one expression.</span></span><br><span class="line">Eval(<span class="number">11</span>, a =&gt; </span><br><span class="line">    <span class="comment">//now a is binding to 11</span></span><br><span class="line">    Eval(a + <span class="number">9</span>, b =&gt; b</span><br><span class="line">        <span class="comment">// now, b is binding to a + 9, </span></span><br><span class="line">        <span class="comment">// which is evaluate to 11 + 9</span></span><br><span class="line">    ));</span><br></pre></td></tr></table></figure><p>这里使用了函数闭包，我们会在接下来的柯里化部分继续谈到。通过使用continues（延续）技术以及闭包，我们成功的将赋值语句变了函数式的表达式，这也是F#中<code>let</code>的基本工作方式。</p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p><code>一类函数</code>特性使得高阶函数成为可能。何为高阶函数？高阶函数(higher-order function)就是指能函数自身能够接受函数，并可以返回函数的一种函数。我们来看下面两个例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C#</span></span><br><span class="line"><span class="keyword">var</span> filteredData = Products.Where(p =&gt; p.Price &gt; <span class="number">10.0</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello world."</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>C#中的<code>Where</code>接受了一个匿名函数（Lambda表达式），所以它是一个高阶函数，javascript的<code>SetInterval</code>函数接受一个匿名的回调函数，因而也是高阶的。</p><p>我们用一个更加有表现力的例子来说明高阶函数可以提供的强大能力：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> addBy value = <span class="keyword">fun</span> n -&gt; n + value</span><br><span class="line"><span class="keyword">let</span> add10 = addBy <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> add20 = addBy <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result11 = add10 <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> result21 = add20 <span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>addBy</code>函数接受一个值value，并返回一个匿名函数，该匿名函数对参数n和闭包值value相加后返回结果。也就是说，<code>addBy</code>函数通过传入的参数，返回了一个经过定制的函数。</p><p>高阶函数使函数定制变的容易，它可以隐藏具体的执行细节，将可定制的部分（或行为）抽象出来并传给某个高阶函数使用。</p><blockquote><p>是的，这听起来很像是OO设计模式中的模板方法，在FP中并没有模板方法的概念，使用高阶函数就可以达到目的了。</p></blockquote><p>在下节的柯里化部分将会看到，这种定制函数的能力内建在很多FP语言中，Haskell、F#中都有提供。</p><p>在FP中最常用的就是<code>map</code>、<code>filter</code>、<code>fold</code>了，我们通过检查在F#中它们的签名就可以推测它们的用途：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map:    (&apos;a -&gt; &apos;b) -&gt; &apos;a list -&gt; &apos;b list</span><br><span class="line">filter: (&apos;a -&gt; bool) -&gt; &apos;a list -&gt; &apos;a list</span><br><span class="line">fold:   (&apos;a -&gt; &apos;b -&gt; &apos;a) -&gt; &apos;a -&gt; &apos;b list -&gt; &apos;a</span><br></pre></td></tr></table></figure><p><code>map</code>通过对列表中的每个元素执行参数函数，得到相应的结果，是一种映射。C#对应的操作为<code>Select</code>。<br><code>filter</code>通过对列表中的每个元素执行参数函数，将结果为<code>true</code>的元素返回，是一种过滤。C#对应的操作为<code>Where</code>。<br><code>fold</code>相对复杂一些，我们可以理解为一种带累加器的化简函数。C#对应的操作为<code>Aggregate</code>。</p><p>之前我们提到过，泛型本身可以看做是某种类型的包装，所以如果我们面对一个<code>&#39;T list</code>，那么我们可以说这是一个<code>&#39;T</code>类型的<strong>包装</strong>，注意此处并没有说它是个范型列表。于是乎，我们对<code>map</code>有了一种更加高层次的理解，我们可以尝试一种新的签名：<code>(&#39;a -&gt; &#39;b) -&gt; M&lt;&#39;a&gt; -&gt; M&lt;&#39;b&gt;</code>，这就是说，<code>map</code>将拆开包装，对包装内类型进行转换产生某种新的类型，然后再以同样的包装将其重新打包。</p><p><code>map</code>也叫普通投影，请记住这个签名，我们在最后的延续一节将提出一个新的术语叫<strong>平展投影</strong>，到时候还会来对比<code>map</code>。</p><p>如果我们对两个甚至是三个包装类型的值进行投影呢？我们会猜想它的签名可能是这样：</p><ul><li>lift2: <code>(&#39;a -&gt; &#39;b -&gt; &#39;c) -&gt; M&lt;&#39;a&gt; -&gt; M&lt;&#39;b&gt; -&gt; M&lt;&#39;c&gt;</code></li><li>lift3: <code>(&#39;a -&gt; &#39;b -&gt; &#39;c -&gt; &#39;d) -&gt; M&lt;&#39;a&gt; -&gt; M&lt;&#39;b&gt; -&gt; M&lt;&#39;c&gt; -&gt; M&lt;&#39;d&gt;</code></li></ul><p>其实这便是FP中为人们广泛熟知的“提升”，它甚至可以称作是一种函数式设计模式。提升允许将一个对值进行处理的函数转换为一个在不同设置中完成相同任务的函数。</p><h2 id="柯里化和部分函数应用"><a href="#柯里化和部分函数应用" class="headerlink" title="柯里化和部分函数应用"></a>柯里化和部分函数应用</h2><blockquote><p>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p></blockquote><p>这段定义有些拗口，我们借助前面的一个例子，并通过javascript来解释一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addBy</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n + value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add10 = addBy(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> result11 = add10(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>javascript版本完全是F#版本的复刻，如果我们想换个方式来使用它呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result11 = addBy(<span class="number">10</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这明显是不可以的（并不是说不能调用，而是说结果并非所期望的），因为<code>addBy</code>函数只接收一个参数。但是柯里化要求我们函数只能接受一个参数，该如何处理呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result11 = addBy(<span class="number">10</span>)(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//             ~~~~~~~~~    return an anonymous fn(anonymousFn, e.g)</span></span><br></pre></td></tr></table></figure><p>如此就可以了，<code>addBy(10)</code>将被正常调用没有问题，返回的匿名函数又立即被调用<code>anonymousFn(1)</code>，结果正是我们所期望的。</p><p>假如javascript在调用函数时可以像Ruby和F#那样省略括号呢？我们会得到<code>addBy 10 1</code>，这和真实的多参数函数调用就更像了。在<code>addBy</code>函数内部，返回匿名函数时带出了<code>value</code>的值，这是一个典型的闭包应用。在<code>addBy</code>调用后，<code>value</code>值将在外部作用域中不可见，而在返回的匿名函数内部，<code>value</code>值仍然是可以采集到的。</p><blockquote><p>闭包（Closure）是词法闭包（Lexical Closure）或函数闭包（function closures）的简称，可参见<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming" target="_blank" rel="noopener">wikipedia</a>)上的详细解释。</p></blockquote><p>如此看来，是不是所有的多参数函数都能被柯里化呢？我们假想一个这样的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeAddFn</span>(<span class="params">n1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n3</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n4</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> n1 + n2 + n3 + n4;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = fakeAddFn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//           ~~~~~~~~~~~~           now is function(n2)</span></span><br><span class="line"><span class="comment">//                       ~~~        now is function(n3)</span></span><br><span class="line"><span class="comment">//                          ~~~     now is function(n4)</span></span><br><span class="line"><span class="comment">//                             ~~~  return n1 + n2 + n3 + n4</span></span><br></pre></td></tr></table></figure><p>但是这样又显得非常麻烦并且经常会出现智商不够用的情况，如果语言能够内建支持currying，那么情况将乐观许多，例如F#可以这样做：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fakeAddFn n1 n2 n3 n4 = n1 + n2 + n3 + n4</span><br></pre></td></tr></table></figure><p>编译器将自动进行柯里化，完全展开形式如下：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fakeAddFn n1 = <span class="keyword">fun</span> n2 -&gt; <span class="keyword">fun</span> n3 -&gt; <span class="keyword">fun</span> n4 -&gt; n1 + n2 + n3 + n4</span><br></pre></td></tr></table></figure><p>并且F#调用函数时可以省略括号，所以对<code>fakeAddFn</code>的调用看上去就像是对多参数函数的调用：<code>let result = fakeAddFn 1 2 3 4</code>。到这里你也许会问，currying到底有什么用呢？答案是：部分函数应用。</p><p>由于编译器自动进行currying，所以每一个函数本身是可以部分调用的，举个例子，F#中的<code>+</code>运算符其实是一个函数，定义如下：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (+) a b = a + b</span><br></pre></td></tr></table></figure><p>利用前面的知识我们知道它的完全形式是这样：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (+) a = <span class="keyword">fun</span> b -&gt; a + b</span><br></pre></td></tr></table></figure><p>所以我们自然可以编写一个表达式只给<code>+</code>运算符一个参数，这样返回的结果是另一个接受一个参数的函数，之后，再传入剩余一个参数。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add10partial = (+) <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> result = add10partial <span class="number">1</span></span><br></pre></td></tr></table></figure><p>同时，由于<code>add10partial</code>函数的签名是<code>int -&gt; int</code>，所以可以直接用于<code>List.map</code>函数，如下：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add10partial = (+) <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> result = someIntList |&gt; List.map add10partial</span><br><span class="line"></span><br><span class="line"><span class="comment">// upon expression equals below </span></span><br><span class="line"><span class="comment">// let result = List.map add10partial someIntList</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or, more magic, make List.map partially:</span></span><br><span class="line"><span class="keyword">let</span> mapper = (+) <span class="number">10</span> |&gt; List.map</span><br><span class="line"><span class="keyword">let</span> sameResult = someIntList |&gt; mapper</span><br></pre></td></tr></table></figure><blockquote><p><code>|&gt;</code>运算符本身也是一个函数，简单的定义就是<code>let (|&gt;) p f = f p</code>，这种类似管道的表达式为FP提供了更高级的表达。</p></blockquote><p>我们知道FP是以<code>Alonzo Church</code>的lambda演算为理论基础的，lambda演算的函数都是接受一个参数，后来<code>Haskell Curry</code>提出的currying概念为lambda演算补充了表示多参数函数的能力。</p><h2 id="递归及优化"><a href="#递归及优化" class="headerlink" title="递归及优化"></a>递归及优化</h2><p>由于FP没有可变状态的概念，所以当我们以OO的思维来思考时会觉得无从下手，在这个时候，递归就是强有力的武器。</p><blockquote><p>其实并不是说现代的FP语言没有可变状态，其实几乎所有的FP语言都做了一定程度的妥协，诸如F#构建在.NET平台之上，那么在与BCL提供的类库互操作时避免不了要涉及状态的改变，而且如果全部使用递归的方式来处理可变状态，在性能上也是一个严峻的考验。所以F#其实提供了可变操作，但是需要明确的使用<code>mutable</code>关键字来声明或者使用<code>引用单元格</code>。</p></blockquote><p>以一个典型的例子为开始，我们实现一个Factorial阶乘函数，如果以命令式的方式来实现是这样的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Factorial</span>(<span class="params"><span class="keyword">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">2</span>; index &lt;= n; index++) &#123;</span><br><span class="line">        result = result * index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是典型的how to do，我们开始尝试用递归并且尽可能的用表达式来解决问题：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Factorial</span>(<span class="params"><span class="keyword">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span></span><br><span class="line">        ? <span class="number">1</span></span><br><span class="line">        : n * Factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是可以正常工作的，但是如果n的值为10,000呢？会栈溢出。此时便出现了本节要解决的第二个问题：递归优化。</p><p>那么这段递归代码为什么会溢出？我们展开它的调用过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n               (n-1)       ...      3         2       1  // state</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">n*f(n-1) -&gt; (n-1)*f(n-2) -&gt; ... -&gt; 3*f(2) -&gt; 2*f(1) -&gt; 1  // stack in</span><br><span class="line">                                                       |  </span><br><span class="line">n*r      &lt;-  (n-1)*(r-1) &lt;- ... &lt;-   3*2  &lt;-   2*1  &lt;- 1  // stack out</span><br></pre></td></tr></table></figure><p>简单来说，因为当<code>n</code>大于1时，每次递归都卡在了<code>n * _</code>上，必须等后面的结果返回后，当前的函数调用栈才能返回，久而久之就会爆栈。那可以做点什么呢？如果我们在递归调用的时候不需要做任何工作（例如不去乘以n），那么就可以从当前的调用栈直接跳到下一次的调用栈上去。这称为尾递归优化。</p><p>我们考虑，当前调用时的n，如果以某种形式直接带到下一次的递归调用中，那么是不是就达到了目的？没错，这就是累加器技术，来尝试一下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">FactorialHelper</span>(<span class="params">acc, n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span></span><br><span class="line">        ? acc</span><br><span class="line">        : FactorialHelper(acc * n, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Factorial</span>(<span class="params"><span class="keyword">int</span> n</span>)</span> &#123; <span class="keyword">return</span> FactorialHelper(<span class="number">1</span>, n); &#125;</span><br></pre></td></tr></table></figure><p>C#毕竟没有F#那么方便的内嵌函数支持，所以我们声明了一个Helper函数用来达到目的，对应的F#实现如下：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> factorial n =</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> helper acc n' =</span><br><span class="line">        <span class="keyword">if</span> n' &lt;= <span class="number">1</span> <span class="keyword">then</span> acc</span><br><span class="line">        <span class="keyword">else</span> helper (acc * n') (n' - <span class="number">1</span>)</span><br><span class="line">    helper <span class="number">1</span> n</span><br></pre></td></tr></table></figure><p>下面的示意表达了我们想达到的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">init        f(1, n)             // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">n           f(n, n-1)           // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">n-1         f(n*(n-1), n-2)     // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">...         ...                 // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">3           f((k-2), 2)         // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">2           f((k-1), 1)         // stack in</span><br><span class="line">                |               // stack pop, jump to next</span><br><span class="line">1           k                   // return result</span><br></pre></td></tr></table></figure><p>可以看到，调用展开成尾递归的形式，从而避免了栈溢出。尾递归是一项基本的递归优化技术，其中关键的就是对累加器的使用。几乎所有的递归函数都可以优化成尾递归的形式，所以掌握这项技能对编写FP程序是有重要的意义的。</p><p>假如我们遇到的是一个非常庞大的列表需要处理，例如找到最大数或者列表求和，那么尾递归技术也将会让我们避免在深度的遍历时发生栈溢出的情形。</p><p>在前面我们说过<code>fold</code>是一种自带累加器的化简函数，那么列表求和以及最大数查找是不是可以直接用<code>fold</code>来实现呢？我们来尝试一下。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> sum l = l |&gt; List.fold (+) <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> times l = l |&gt; List.fold <span class="comment">(*) 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">let max l = </span></span><br><span class="line"><span class="comment">    let compare s e = if s &gt; e then s else e</span></span><br><span class="line"><span class="comment">    l |&gt; List.fold compare 0</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>fold</code>抽取了遍历并化简的核心步骤，仅将需要自定义的部分以参数的形式开放出来。这也是高阶函数组合的威力。</p><blockquote><p>还有一个和<code>fold</code>很类型的术语叫<code>reduce</code>，它和<code>fold</code>的唯一区别在于，<code>fold</code>的累加器需要一个初始值需要指定，而<code>reduce</code>的初始累加器使用列表的第一个元素的值。</p></blockquote><h2 id="记忆化"><a href="#记忆化" class="headerlink" title="记忆化"></a>记忆化</h2><p>我们知道大多数的FP函数是没有副作用的，这意味着以相同的参数调用同一函数将会返回相同的结果，那么如果有一个函数会被调用很多次，为什么不把对应参数的求值结果缓存起来，当参数匹配时直接返回缓存结果呢？这个过程就是记忆化，也是FP编程中常用的技巧。</p><p>我们以一个简单的加法函数为例：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add (a, b) = a + b</span><br></pre></td></tr></table></figure><p>注意这里我们使用了非currying化的参数，它是一个元组。接下来我们尝试使用记忆化来缓存结果：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> memoizedAdd = </span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> Dictionary&lt;_, _&gt;()</span><br><span class="line">    <span class="keyword">fun</span> p -&gt;</span><br><span class="line">        <span class="keyword">match</span> cache.TryGetValue(p) <span class="keyword">with</span></span><br><span class="line">        | <span class="keyword">true</span>, result -&gt; result</span><br><span class="line">        | _ -&gt;</span><br><span class="line">            <span class="keyword">let</span> result = add p</span><br><span class="line">            cache.Add(p, result)</span><br><span class="line">            result</span><br></pre></td></tr></table></figure><p>借助一个字典，将已经求值的结果缓存起来，下次以同样的参数调用时就可以直接从字典中检索出值，避免了重新计算。</p><p>我们甚至可以设计一个通用的记忆化函数，用于将任意函数记忆化：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> memorize f =</span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> Dictionary&lt;_, _&gt;()</span><br><span class="line">    <span class="keyword">fun</span> p -&gt;</span><br><span class="line">        <span class="keyword">match</span> cache.TryGetValue(p) <span class="keyword">with</span></span><br><span class="line">        | <span class="keyword">true</span>, result -&gt; result</span><br><span class="line">        | _ -&gt;</span><br><span class="line">            <span class="keyword">let</span> result = f p</span><br><span class="line">            cache.Add(p, result)</span><br><span class="line">            result</span><br></pre></td></tr></table></figure><p>那么前面的<code>memorizedAdd</code>函数可以写为<code>let memorizedAdd = memorize add</code>。这也是一个高阶函数应用的好例子。</p><h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><p>Haskell是一种纯函数语言，它不允许存在任何的副作用，并且在Haskell中，当表达式不必立即求值时是不会主动求值的，换句话说，是延迟计算的。而在大多数主流语言中，计算策略却是即时计算的（eager evaluation），这在某种极端情况下会不经意的浪费计算资源。有没有什么方法能够模拟类似Haskell中的延迟计算？</p><p>假如我们需要将表达式<code>n % 2 == 0 ? &quot;right&quot; : &quot;wrong&quot;</code>绑定到标识（即变量名）<code>isEven</code>上，例如<code>var isEven = n % 2 == 0 ? &quot;right&quot; : &quot;wrong&quot;;</code>，那么整个表达式是立即求值的，但是<code>isEven</code>可能在某种状况下不会被使用，有没有什么办法能在我们确定需要<code>isEven</code>时再计算表达式的值呢？</p><p>假如我们将<code>isEven</code>绑定到某种结构上，这个结构知道如何求值，并且是按需求值的，那么我们的目的就达到了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">var</span> isEven = <span class="keyword">new</span> Lazy&lt;<span class="keyword">string</span>&gt; (() =&gt; n % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">"right"</span> : <span class="string">"wrong"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> isEven = <span class="keyword">lazy</span> (<span class="keyword">if</span> n % <span class="number">2</span> = <span class="number">0</span> <span class="keyword">then</span> <span class="string">"right"</span> <span class="keyword">else</span> <span class="string">"wrong"</span>)</span><br></pre></td></tr></table></figure><p>当使用<code>isEven</code>时，C#可以直接使用<code>isEven.Value</code>来即时求值并返回结果，而F#的使用方式也是一样的<code>isEven.Value</code>。</p><p>还有一种更加通用的方式来实现惰性求值，就是通过函数，函数表达了某种可以得到值的方式，但是需要调用才能得到，这和惰性求值的思想不谋而合。我们可以改写上面的例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">var</span> isEven = (Func&lt;<span class="keyword">string</span>&gt;)(() =&gt; n % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">"right"</span> : <span class="string">"wrong"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> isEven = <span class="keyword">fun</span> () -&gt; <span class="keyword">if</span> n % <span class="number">2</span> = <span class="number">0</span> <span class="keyword">then</span> <span class="string">"right"</span> <span class="keyword">else</span> <span class="string">"wrong"</span></span><br></pre></td></tr></table></figure><p>这样，在需要使用<code>isEven</code>的值时就是一个简单的函数调用，C#和F#都是<code>isEven()</code>。</p><h2 id="延续"><a href="#延续" class="headerlink" title="延续"></a>延续</h2><p>如果你之前使用过jQuery，那么在某种程度上已经接触过延续的概念了。<br>通过jQuery发起ajax调用其实就是一种延续：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('http://test.com/data.json', function(data) &#123;</span><br><span class="line">    <span class="comment">// processing.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>ajax调用成功后会调用匿名回调函数，而此函数表达了我们希望ajax调用成功后继续执行的行为，这就是延续。</p><p>现在，我们回顾一下，在概述-表达式求值一节，我们为了将两个C#赋值语句改写成表达式的方式，新增了一个<code>Eval</code>函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Eval</span>(<span class="params"><span class="keyword">int</span> binding, Action&lt;<span class="keyword">int</span>&gt; continues</span>)</span> &#123;</span><br><span class="line">    contineues(binding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它也是一种延续，指定了在<code>binding</code>求值后继续执行延续的行为，我们将它稍做修改：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">public</span> TOutput binding&lt;TEvalValue, TOutput&gt;(</span><br><span class="line">    TEvalValue evaluation, </span><br><span class="line">    Func&lt;TEvalValue, TOutput&gt; continues) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> continues(evaluation());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> binding v cont = cont v</span><br><span class="line"><span class="comment">// binding: 'a -&gt; cont:('a -&gt; 'b) -&gt; 'b</span></span><br></pre></td></tr></table></figure><p>于是我们可以模拟<code>let</code>的工作方式：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line">binding <span class="number">11</span> (<span class="keyword">fun</span> a -&gt; printfn <span class="string">"%d"</span> a)</span><br></pre></td></tr></table></figure><p>那么延续这种技术在实践中有什么用途呢？你可以说它就是个回调函数，这没有问题。深层次的理解在于，它延后了某种<strong>行为</strong>且该行为对上下文有依赖。</p><p>我们考虑这样一个场景，假设我们有一颗树需要遍历并求和，例如：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">NumberTree</span> </span>=</span><br><span class="line">    | Leaf <span class="keyword">of</span> int</span><br><span class="line">    | Node <span class="keyword">of</span> NumberTree * NumberTree</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> sumTree tree =</span><br><span class="line">    <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">    | Leaf(n)           -&gt; n</span><br><span class="line">    | Node(left, right) -&gt; sumTree(left) + sumTree(right)</span><br></pre></td></tr></table></figure><p>那么问题来了，我们显然可以发现当树的层级太深时<code>sumTree</code>函数会发生栈溢出，我们也自然而然的想到了使用尾递归来优化，但是当我们在尝试做优化时会发现，然并卵。这就是一个无法使用尾递归的场景。</p><p>核心的诉求在于，我们希望进行尾递归调用（<code>sumTree(left)</code>），但在尾递归调用完成之后，还有需要执行的代码（<code>sumTree(right)</code>）。延续为我们提供了一种手段，在函数调用结束后自动调用指定的行为（函数），于是当前正在编写的函数便仅包含一次递归调用了。我们仍然可以将它看作是一种累加器技术，区别在于，之前是累加值，而延续是累加行为。</p><p>我们尝试为<code>sumTree</code>递归函数加上延续功能：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> sumTree tree continues =</span><br><span class="line">    <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">    | Leaf(n) -&gt; continues n</span><br><span class="line">    | Node(left, right) -&gt;</span><br><span class="line">        sumTree left (<span class="keyword">fun</span> leftSum -&gt; </span><br><span class="line">            sumTree right (<span class="keyword">fun</span> rightSum -&gt; </span><br><span class="line">                continues(leftSum + rightSum)))</span><br></pre></td></tr></table></figure><p>此时，<code>sumTree</code>的签名从<code>NumberTree -&gt; int</code>变成了<code>NumberTree -&gt; (int -&gt; &#39;a) -&gt; &#39;a</code>。<code>Node(left, right)</code>分支现在变成了单个函数的调用，所以它是尾递归优化的，每次计算时都会将结束后需要继续执行的行为以函数的方式指定，直到整个递归完成。</p><p>使用时，可以以延续的方式来调用<code>sumTree</code>函数，也可以像往常一样从返回值获取结果：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsharp</span></span><br><span class="line"><span class="comment">// continues way:</span></span><br><span class="line">sumTree sampleTree (<span class="keyword">fun</span> result -&gt; printfn <span class="string">"result: %d"</span> result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// normal way:</span></span><br><span class="line"><span class="keyword">let</span> result = sumTree sampleTree (<span class="keyword">fun</span> r -&gt; r)</span><br></pre></td></tr></table></figure><p>我们甚至可以从延续的思想逐渐推导出类似<code>bind</code>的函数，我们将它与<code>map</code>的签名对比：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bind</span><br><span class="line">(&apos;a -&gt; M&lt;&apos;b&gt;) -&gt; M&lt;&apos;a&gt; -&gt; M&lt;&apos;b&gt;</span><br><span class="line">// map</span><br><span class="line">(&apos;a -&gt; &apos;b)    -&gt; M&lt;&apos;a&gt; -&gt; M&lt;&apos;b&gt;</span><br></pre></td></tr></table></figure><p>在高阶函数一节我们说过，<code>map</code>叫普通投影，而新的<code>bind</code>叫做平展投影，它是一种外层匹配模式，在C#中对应的操作是<code>SelectMany</code>，在F#中就是<code>bind</code>，是一种通用函数。</p><p>在前面我们定义了一个<code>binding</code>函数，我们稍微调整一下参数顺序，并把它和<code>bind</code>对比：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// binding:</span><br><span class="line">(&apos;a -&gt; &apos;b)    -&gt; &apos;a -&gt; &apos;b</span><br><span class="line">// map:</span><br><span class="line">(&apos;a -&gt; &apos;b)    -&gt; M&lt;&apos;a&gt; -&gt; M&lt;&apos;b&gt;</span><br><span class="line">// bind:</span><br><span class="line">(&apos;a -&gt; M&lt;&apos;b&gt;) -&gt; M&lt;&apos;a&gt; -&gt; M&lt;&apos;b&gt;</span><br></pre></td></tr></table></figure><p>也就是说，如果我们为<code>&#39;a</code>加上某种包装，然后在bind里再做一些转换，那么我们就可以推导出<code>bind</code>函数。</p><p>C#的LINQ里<code>SelectMany</code>对应的就是<code>from</code>语句，比如下面：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> a <span class="keyword">in</span> l1</span><br><span class="line">             <span class="keyword">from</span> b <span class="keyword">in</span> l2</span><br><span class="line">             <span class="keyword">from</span> c <span class="keyword">in</span> l3</span><br><span class="line">             <span class="keyword">select</span> &#123; a, b &#125;</span><br></pre></td></tr></table></figure><p>这将转换成一系统嵌套的<code>SelectMany</code>调用，而<code>select</code>将转换为某种类似于<code>Return&lt;T&gt;()</code>的操作。对于F#来说，类似的代码可以用计算表达式（或者更加具体的序列表达式）：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = seq &#123;</span><br><span class="line">    <span class="keyword">let!</span> a = l1</span><br><span class="line">    <span class="keyword">let!</span> b = l2</span><br><span class="line">    <span class="keyword">let!</span> c = l3</span><br><span class="line">    <span class="keyword">return</span> (a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，似乎差不多该结束了，我们不打算继续深究<code>bind</code>，因为再往下走就到了<code>monad</code>了。事实上，大家已经看到了<code>monad</code>，F#的序列表达式以及C#中LINQ的一部分操作，就是<code>monad</code>。</p><hr><p>希望本文讲述的一些浅显的函数式编程概念可以在实践中对你有所帮助。最重要的是通过对思维的训练，可以从更加抽象的角度思考问题，提取问题最核心的部分以复用，将可变部分提出，从而使问题可组合，并且获得更好的表达性。</p><p>有关<code>monad</code>，推荐大家看看<a href="https://en.wikipedia.org/wiki/Erik_Meijer_%28computer_scientist%29" target="_blank" rel="noopener">Erik Meijer</a>大大在Channel9上的课程<a href="https://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals" target="_blank" rel="noopener">Functional Programming Fundamentals</a>，它同时也是<a href="https://github.com/Reactive-Extensions" target="_blank" rel="noopener">Rx</a>库的作者之一，以及LINQ的作者。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Closure、Haskell、Python、Ruby这些语言越来越流行的今天，我们撇开其在数学纯度性上的不同，单从它们都拥有&lt;code&gt;一类函数&lt;/code&gt;特性来讲，讨论函数式编程也显得很有意义。&lt;/p&gt;
&lt;p&gt;一类函数为函数式编程打下了基础，虽然这并不能表示可以完整
      
    
    </summary>
    
      <category term="productivity" scheme="https://lurongkai.github.io/categories/productivity/"/>
    
    
      <category term="C#" scheme="https://lurongkai.github.io/tags/C/"/>
    
      <category term="F#" scheme="https://lurongkai.github.io/tags/F/"/>
    
      <category term="Functional-Programming" scheme="https://lurongkai.github.io/tags/Functional-Programming/"/>
    
  </entry>
  
  <entry>
    <title>提高工作效率与幸福度-工具篇</title>
    <link href="https://lurongkai.github.io/2015/10/14/improve-work-efficiency-and-happiness-2/"/>
    <id>https://lurongkai.github.io/2015/10/14/improve-work-efficiency-and-happiness-2/</id>
    <published>2015-10-14T05:35:42.000Z</published>
    <updated>2019-02-14T02:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章略难产，事实上距离”基本篇”的发布已然过去了小半年了，生孩子生到这份儿上也真是够够的了。那时天还是辣么蓝，微风徐徐鸟语花香，我独自抚摸着猫在键盘上激情的写作……后来，把下篇给忘了。据说刨坑不填的都得拉去烧死，我想了想觉得挺疼的，所以抓紧补上吧。</p><p>先回顾一下基本篇阐述的基本事实：</p><ul><li>邮件 is bitch</li><li>电话有时让对方不爽</li><li>信息的组织与提取不是容易的事情</li></ul><p>对于这几个bitch上篇给出了简单的建议，不妨作为一种过渡手段，但是身为现代人类，有辣么多好用而且几乎都是免费的工具可以使用，why not?</p><blockquote><p>不过说到底，再牛逼的工具也不能解决人懒惰的问题，工具只能让你更好的做事，不能帮你做事，躺着就把钱赚了的事不多，要想清楚。</p></blockquote><a id="more"></a><h2 id="改善沟通"><a href="#改善沟通" class="headerlink" title="改善沟通"></a>改善沟通</h2><h3 id="Teambition"><a href="#Teambition" class="headerlink" title="Teambition"></a>Teambition</h3><p>如果你的团队或当前项目是10-30人左右，我建议尝试一下免费好用的Teambition，类似的产品还有Worktile和RedBooth。</p><p>Teambition基于任务板来分割任务，并且可以设置任务分组，当项目的构成需要复杂的人力协作时，将其分割成不同的小任务（或子任务）并分配给相应的责任人，然后同时设定任务阶段，所有的进展情况与信息一目了然，对于建立团队信心也有着积极的作用。</p><p>如果你使用微博或者Twitter，可以使用@符号来提醒相应的人介入讨论，这里的好处在于：</p><ul><li>所有的讨论都在一个任务下，不会出现信息分裂</li><li>信息可检索，包括讨论的内容、附件等</li><li>只有需要某个同事介入时他才会得到通知</li></ul><p>对比邮件：</p><ul><li>一件事或任务往往分散在各个不同邮件内容里，东拉一句西扯一句，谁知道扯的什么蛋</li><li>要找到有关某件事的信息，需要查找所有的邮件内容，有时还需要人工阅读整封邮件</li><li>跟我有没有关系都CC我，我特么真的会看么？不看真特么可以么？</li></ul><p>基于任务的管理，可以一目了然的看到项目反馈，为项目计划提供数据参考。</p><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>Outlook有一项极其好用的武器叫Calendar，我知道很多成熟的企业其实是高度使用Calendar的，但是如果你的团队没有使用过，我建议你尝试一下。</p><p>Calendar可以定制团队日历，不要把它单纯的当做预定会议室的工具，它能做的还有很多。设置团队Deadline，Meeting计划等等。</p><p>将个人的事宜纳入Calendar也可以收获良多，比如”15:00 - 17:00 处理A任务”，”Jun 23 联系客户X确认数据”。不要把自己逼太累，有工具不用当自己是闹钟啊？</p><p>当然，如果你已经采用了Teambition，还是建议使用它自带的Calendar，毕竟和Teambition集成度更高，使用起来也更为方便，你可以得到所有Outlook Calendar提供的有用功能。</p><h2 id="提高信息利用率"><a href="#提高信息利用率" class="headerlink" title="提高信息利用率"></a>提高信息利用率</h2><p>可以肯定的是，大部分的企业并没有定期整理信息的企业文化。在软件开发领域，定期整理文档是一项<strong>历史悠久然而并没多少人践行</strong>的神话。</p><p>企业虽不强求，但是如果你是一个PM，推荐你建立这种团队文化，这会让你受益良多。</p><p>下面两个工具，evernote是个人知识整理工具，wiki是团队知识整理工具。</p><h3 id="evernote"><a href="#evernote" class="headerlink" title="evernote"></a>evernote</h3><p>这个在线工具的中文名字叫印象笔记，类似的产品还有有道云笔记。</p><p>就像在上篇所说的，可以把它当做一个在线版本的working-dir，所有的碎片信息及时的整理到这里，并定期的归档。由于它是在线的，你基本不用担心数据丢失的问题，工作电脑随便换，硬盘随便换，只要你有可以记住自己密码的能力就可以！</p><p>我知道很多朋友是有一个小本本的，上面记了更种零碎信息，比如：x总需要的资源数量，小明的电话，某个网站的地址，客户s的地址等等，为什么不用电子版的呢？还环保…</p><p>当你需要的时候，直接搜索关键字，所有的信息一目了然，你的小本本显然不能这么高级…</p><h3 id="wiki"><a href="#wiki" class="headerlink" title="wiki"></a>wiki</h3><p>企业wiki并没有太优秀的独立产品，大多数都集成在一个大产品中，例如Teambition、Worktile，当有些信息需要共享到团队中去时，wiki是一种非常优秀的手段，它可以作为知识整理和传递的工具。</p><p>作为知识整理工具，每条对团队都有用的信息可以清晰的记录在wiki里，团队内所有人可见，比如：”千万不要跟王老板提大保健”，”2015年度软件采购统计说明”等等，需要这些信息的同事会自己去查找，同时也会将一些有用的信息分享出来。注意wiki是(当前时间点的)最终知识，需要不断的整理和归纳，而中间过程的信息往往会组织在类似Teambition任务板的工具中。</p><blockquote><p>项目中间知识(在Teambition任务板中)经过提取和精化产生团队知识(在类似wiki的工具中)</p></blockquote><h2 id="数据整理"><a href="#数据整理" class="headerlink" title="数据整理"></a>数据整理</h2><p>再不济，企业也应该建立一个公共文件夹来存放共享数据吧？如果你的企业连这个都没有，每个同事都是：”姐，给我拷一下上一年的财务表”，这简直low一地。</p><p>有个最好用的工具叫DropBox，显然在我大中华用不了的，那么我们来尝试一些其它的工具。以下两个工具都提供全全台的同步功能，也就是说，当一个文件发生了变化，会自动同步到云端，然后其它客户端也会自动同步最新的文件，这对于企业是有意义的，谁也不想拿着合同去见客户，最后发现是v0.9的版本而并非最新的v1.0。</p><h3 id="OneDrive"><a href="#OneDrive" class="headerlink" title="OneDrive"></a>OneDrive</h3><p>大微软提供，付费扩容量，速度杠杠的，自动同步文件，妈妈再也不用担心我司的数据。</p><h3 id="百度网盘"><a href="#百度网盘" class="headerlink" title="百度网盘"></a>百度网盘</h3><p>免费版本可获3T空间，中小企业基本够用，再充个会员，速度也杠杠的，还提供文件版本历史记录，工作电脑随便换，硬盘随便换，妈妈也不用担心我司的数据。</p><blockquote><p>如果企业对数据安全性相当的看重，那么还是自己架设文件服务器吧，这个我们以后再说。</p></blockquote><hr><p>最后，还是那句话，再牛逼的工具也解决不了人懒的问题，工具可以提高人类的工作效率，但是也得你去用才行，成天说自己快忙死了哪儿还有时间用这些花哨的东西的人，你就该一辈子在原地转圈，谁叫你不去动脑筋非要动蛮力呢对吧？</p><p>再最后，改变别人我们也许做不到，但是改变自己是可以做到的，正确的打开方式是：我提高了效率我轻松，而不是你降低了效率显得我轻松。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章略难产，事实上距离”基本篇”的发布已然过去了小半年了，生孩子生到这份儿上也真是够够的了。那时天还是辣么蓝，微风徐徐鸟语花香，我独自抚摸着猫在键盘上激情的写作……后来，把下篇给忘了。据说刨坑不填的都得拉去烧死，我想了想觉得挺疼的，所以抓紧补上吧。&lt;/p&gt;
&lt;p&gt;先回顾一下基本篇阐述的基本事实：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邮件 is bitch&lt;/li&gt;
&lt;li&gt;电话有时让对方不爽&lt;/li&gt;
&lt;li&gt;信息的组织与提取不是容易的事情&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于这几个bitch上篇给出了简单的建议，不妨作为一种过渡手段，但是身为现代人类，有辣么多好用而且几乎都是免费的工具可以使用，why not?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不过说到底，再牛逼的工具也不能解决人懒惰的问题，工具只能让你更好的做事，不能帮你做事，躺着就把钱赚了的事不多，要想清楚。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="productivity" scheme="https://lurongkai.github.io/categories/productivity/"/>
    
    
  </entry>
  
  <entry>
    <title>提高工作效率与幸福度-基本篇</title>
    <link href="https://lurongkai.github.io/2015/04/28/improve-work-efficiency-and-happiness-1/"/>
    <id>https://lurongkai.github.io/2015/04/28/improve-work-efficiency-and-happiness-1/</id>
    <published>2015-04-28T11:12:46.000Z</published>
    <updated>2019-02-14T02:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>现代企业有着复杂的协作，人与人间的信息交流、资源间的协调分配，各种碎片信息的整理，这还不包含人际关系处理等等狗血剧情，每天的工作被打散成七零八落，看似忙成狗，其实就是狗一般的活着，仰望天空，噢shit一天又特么过去了，好多事儿还没做完……</p><p>有没有办法通过改善自身来提高生产力？不妨看看这些行之有效的建议能否帮到你。要知道，这些建议来自于脑力协作最为密集的软件开发行业，对其实生产制造或者创造性工作也有着不错的借鉴意义。毕竟，自身的生产力提高了，才能从容的面对复杂的工作，从而让自己的竞争力更上一层台阶。</p><p>本文共分两部分：</p><ul><li>《提高工作效率与幸福度-基本篇》，讲述老百姓自己的故事</li><li>《提高工作效率与幸福度-工具篇》，讲述新人类的工作方式<a id="more"></a></li></ul><h2 id="关于邮件"><a href="#关于邮件" class="headerlink" title="关于邮件"></a>关于邮件</h2><p>邮件是讨厌的。这和小雨伞有着相似之处，不想用但却不得不用。究其深层原因，是因为从邮件中提取有效信息是需要脑力成本的，你不能指望所有的合作者都有着清晰明了的思路。当然有改善这种情况的方式，但从历史角度来看，邮件还会继续存在下去，所以你需要做的，就是如何利用有限的资源来将邮件的生产能力提高。</p><p>首先，邮件应该尽量保持一致的阅读体验，从签名到字体，从颜色到排版。如何可能的话，在公司内部使用统一的邮件格式，这样能让信息的提取容易很多。例如，使用纯黑色或蓝黑色字体，中文字体设置成微软雅黑（已假定所有人使用Win7+以上操作系统），英文字体使用Calibri，字号统一设置成14号字体，大家阅读起来一目了然没有脑力负担。</p><p>其次，使用明确的人类可辨识的语言来说明，如果一件事情的关联性很多，不妨使用<strong>列表</strong>，用明确的短语来描述，人人为我我为人人，例如：</p><ul><li>这件事情需要A来提交票据</li><li>审核任务需要在25号前完成</li><li>与第三方供应商的沟通还没有结果</li></ul><p>这种做法可以行之有效的使信息表述的更为精准，尤其是当你收到一封说的不知所云的邮件时，用列表的方式向对方提问，一般来回不超过两封邮件就能使事情明确。</p><p>再次，邮件中或许提到了可能需要你参与的时间点，所以你需要借助日程工具来提醒自己在未来的时间点再介入。此时不妨点击Outlook上的Meeting按钮，为自己创建一个Appointment，之后可以转做别的事情而不用时该记着还有事情没有做完。</p><p>最后，避免在一封邮件里讨论过多的信息。一封邮件只<strong>讨论</strong>一件事，除非这是封总结性的信息，无需要他们再介入讨论。当然，你需要一个明确的标题，比如“关于库存合并的时间”，必要时，你可以加入简单的标点符号来辅助说明，例如“[确认]一季度销售计划安排”，只有你不对他人造成困扰，才能让他们提供更加有用的信息。</p><p>另外，你需要养成定期整理邮件的习惯，一般建议是一天一整理。Outlook中可以对邮件设置颜色标签，你可以按重要程度设置不同的颜色，如果手里有优先级更高的事情需要处理但是又不能忽略当前的邮件，那么完全可以设置邮件的Follow Up提醒，让机器代替人类记忆更加靠谱的。讨论结束后，可以对邮件进行归档，放置在不同的目录以供今后参考，不造成记忆负担，例如“Projects\2015\Da-Dou-Dou”。</p><h2 id="关于电话"><a href="#关于电话" class="headerlink" title="关于电话"></a>关于电话</h2><p>电话是强势介入，一般比邮件更具侵入性，如果不是特别要紧的事情，不要使用电话来直接Call别人，因为这样可能会打断他人正在进行的事情。放在软件开发者身上，接完电话可能需要30-60分钟才能恢复到原有的工作。</p><p>你需要想明白对方是否真的可以被你打断，比如对方正在上厕所……当然，这种打断在现代企业基本是不可避免的，所以这里提供两条建议以供参考：</p><ol><li>如果正在进行一项优先级很高的任务不希望被中断，那么OK直接挂掉电话（看清谁来的电话），然后马上通过短信、邮件或其实方式回复一条简短的讯息：“我这会儿有重要的事情需要马上处理，30分钟后马上与你联系，如果很紧急请再次联系我”。这样的反馈明确而有力度，确保你能保持高效。当然，如果对方再次call来，你就需要权衡利弊了，这不是演习。</li><li>如果你需要对方协助你处理一项事情，而且不是非常紧急，那么可以先通过其它非实时手段来询问一下时间，比如：“Jack, 我需要和你讨论一下x客户的合同问题，如果方便的话我会在5分钟内call你”，然后没响应的话5分钟call过去。当然，真的是要死要活的事情的话，也没必要有礼貌了，赶紧打电话吧。</li></ol><p>相似的事情还有起身直接喊话，倒也不是什么大的问题，喊之前先说一句：“Tom，你有3分钟时间和我讨论一下xxx吗？”。如果别人是在问你而你很忙碌，你可以说：“稍等一下，我10分钟后再找你”（美剧中经常这么说：I’ll go back to you in ten mins.）。</p><h2 id="关于碎片信息"><a href="#关于碎片信息" class="headerlink" title="关于碎片信息"></a>关于碎片信息</h2><p>各种邮件横飞，电话说完又记了一大堆东西，还有各种文档放在这个U盘那个硬盘，你有没有疯掉的时候？你有没有发现文件丢失了，还有很多“新建文件夹”和“文档1”？有没有发现一些文件貌似丢失了？这些都是碎片信息，如果不定期的整理，很快就翱翔在信息的海洋里然后淹没。</p><p>这个时候，你可以尝试使用一些简单的手段让你的工作更高效。</p><p>对于文件来说，建立有意义的目录体系是很有必要的，简单的可以按年月来建里，然后结合具体的项目或工作内容建立子目录，并且将相关的文件全部放置在同一文件夹便于查找。对于该项目或工作内容中的一些有用信息，可以使用一个简单的information.txt文件来保存，里面记录在邮件中或电话中或其它协作工作中出现的有用信息。最后，定期的将整个目录打包压缩，放置在固定的地方作为备份。</p><p>如果需要保存某个文件的历史版本，不要起个类似“合同新.docx”、“合同111.docx”这种糟糕透了的名字，最佳的方式是使用名字+日期后缀，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx经销商合同-2015-04-20.docx</span><br><span class="line">xxx经销商合同-2015-04-21.docx</span><br><span class="line">xxx经销商合同-2015-04-28.docx</span><br></pre></td></tr></table></figure><p>如果当天就会变动很多个版本，那么不妨再在最后加入自然数字来区分，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx经销商合同-2015-04-28-v1.docx</span><br><span class="line">xxx经销商合同-2015-04-28-v2.docx</span><br><span class="line">xxx经销商合同-2015-04-28-v2.1.docx</span><br></pre></td></tr></table></figure><p>另外一个实践的建议是，建立一个唯一的working-dir，用来保存当天正在工作的内容，可以放各种乱七八糟的文件，然后在下班的前5分钟进行整理，移入前面建立的文件夹，长期如此你会发现，天都变蓝了。</p><p>我们将会在《提高工作效率与幸福度-工具篇》中推荐更好的工具以供尝试，事实上，还真有……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代企业有着复杂的协作，人与人间的信息交流、资源间的协调分配，各种碎片信息的整理，这还不包含人际关系处理等等狗血剧情，每天的工作被打散成七零八落，看似忙成狗，其实就是狗一般的活着，仰望天空，噢shit一天又特么过去了，好多事儿还没做完……&lt;/p&gt;
&lt;p&gt;有没有办法通过改善自身来提高生产力？不妨看看这些行之有效的建议能否帮到你。要知道，这些建议来自于脑力协作最为密集的软件开发行业，对其实生产制造或者创造性工作也有着不错的借鉴意义。毕竟，自身的生产力提高了，才能从容的面对复杂的工作，从而让自己的竞争力更上一层台阶。&lt;/p&gt;
&lt;p&gt;本文共分两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《提高工作效率与幸福度-基本篇》，讲述老百姓自己的故事&lt;/li&gt;
&lt;li&gt;《提高工作效率与幸福度-工具篇》，讲述新人类的工作方式
    
    </summary>
    
      <category term="productivity" scheme="https://lurongkai.github.io/categories/productivity/"/>
    
    
  </entry>
  
  <entry>
    <title>使用异步编程</title>
    <link href="https://lurongkai.github.io/2014/12/03/async-programming/"/>
    <id>https://lurongkai.github.io/2014/12/03/async-programming/</id>
    <published>2014-12-03T03:50:18.000Z</published>
    <updated>2019-04-15T02:05:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>现代的应用程序面临着诸多的挑战，如何构建具有可伸缩性和高性能的应用成为越来越多软件开发者思考的问题。随着应用规模的不断增大，业务复杂性的增长以及实时处理需求的增加，开发者不断尝试榨取硬件资源、优化。</p><p>在不断的探索中，出现了很多简化场景的工具，比如提供可伸缩计算资源的<a href="http://aws.amazon.com/cn/s3/" target="_blank" rel="noopener">Amazon S3</a>、<a href="http://azure.microsoft.com/" target="_blank" rel="noopener">Windows Azure</a>，针对大数据的数据挖掘工具<a href="http://research.google.com/archive/mapreduce.html" target="_blank" rel="noopener">MapReduce</a>，各种CDN服务，云存储服务等等。还有很多的工程实践例如<a href="http://agilemanifesto.org/" target="_blank" rel="noopener">敏捷</a>、<a href="http://www.domaindrivendesign.org/" target="_blank" rel="noopener">DDD</a>等提供了指导。可以看到，将每个关注层面以服务的方式提供，成为了越来越流行的一种模式，或许我们可以激进的认为，这就是<a href="http://en.wikipedia.org/wiki/Service-oriented_architecture/" target="_blank" rel="noopener">SOA</a>。</p><p>开发者需要将不同的资源粘合在一起来提供最终的应用，这就需要协调不同的资源。</p><p>我们可以设想一个大的场景，开发者正在开发的一个用例会从用户的浏览器接收到请求，该请求会先从一个开放主机服务(OHS)获取必要的资源res1，然后调用本机的服务s1对资源res1进行适应的转换产生资源res2，接着以res2为参数调用远程的数据仓库服务rs1获取业务数据bs1，最后以bs1为参数调用本机的计算服务calc并经过10s产生最终的数据。</p><p>简单的用ASP.NET MVC 5表示就是这样的（这些代码是我瞎掰的）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// notes: ASP.NET vNext changed MVC 5 usage, </span></span><br><span class="line"><span class="comment">// ActionResult now became IActionResult</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">CrazyCase</span>(<span class="params">UserData userData</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ticket = CrazyApplication.Ticket;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> ohsFactory = <span class="keyword">new</span> OpenHostServiceFactory(ticket);</span><br><span class="line">    <span class="keyword">var</span> ohs = ohsFactory.CreateService();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> ohsAdapter = <span class="keyword">new</span> OhsAdapter(userData);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> rs1 = ohs.RetrieveResource(ohsAdapter);</span><br><span class="line">    <span class="keyword">var</span> rs2 = _localConvertingService.Unitize(rs1);</span><br><span class="line">    <span class="keyword">var</span> bs1 = _remoteRepository.LoadBusinessData(rs2);</span><br><span class="line">    <span class="keyword">var</span> result = _calculationService.DoCalculation(bs1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> View(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可能是中等复杂度的一个场景，但是相信开发者已经意识到了这其中所涉及的复杂度。我们看到每一步都是依赖于前者所产生的数据，在这样一种场景之下，传统的多线程技术将极度受限，并且最顶层的协调服务将始终占用一个线程来协调每一步。</p><p>线程是要增加开销的，尤其是上下文的转换，别扯什么线程池了，创建线程的开销是节省了，上下文切换的开销才是要命的。</p><blockquote><p>经济不景气，能省点儿资源就省点儿吧。</p></blockquote><hr><p>所以我们该怎么办？纵向扩展给服务器加多点内存？横向扩展上负载均衡？别闹了我们又不是民工，想问题不要太简单粗暴。解决的办法就是，异步，而且我们这篇也只讨论异步这一种技术。</p><h2 id="为什么使用异步"><a href="#为什么使用异步" class="headerlink" title="为什么使用异步"></a>为什么使用异步</h2><p>那么，异步的优势在哪里？这首先要和同步做一个对比。</p><p>还是开头那个场景，示例代码所展示的是使用同步阻塞的方式来一步一步的执行，如下示意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main) +++$----$------$--------$----------$+++</span><br><span class="line">         |   /|     /|       /|         /</span><br><span class="line">ohs )    $++$ |    / |      / |        /</span><br><span class="line">              |   /  |     /  |       /</span><br><span class="line">rs1 )         $++$   |    /   |      /</span><br><span class="line">                     |   /    |     /</span><br><span class="line">s1  )                $++$     |    /</span><br><span class="line">                              |   /</span><br><span class="line">calc)                         $++$</span><br><span class="line"></span><br><span class="line">notes:</span><br><span class="line">$ code point</span><br><span class="line">+ thread busy</span><br><span class="line">- thread blocked(means, wasted)</span><br></pre></td></tr></table></figure><p>可以明显的看到，当主线程发起各个service请求后，完全处于闲置占用的状态，所做的无非是协调任务间的依赖顺序。这里所说的占用，其实就是CPU的时间片。</p><p>我们为什么要等所有的子任务结束？因为任务间有先后顺序依赖。有没有更好的方式来规避等待所带来的损耗呢？考虑一个场景，正上着班呢，突然想起要在网上买个东西，那么打开京东你就顺利的下单了，事情并没有结束，你不会等快递的小哥给你送来东西以后再接着今天的工作吧？你会给快递留下你的联系方式，让他<strong>到了给你打电话</strong>(耗时的I/O任务)，然后你继续今天烧脑的编程任务(CPU密集型)。从人类的角度来看，这一定是最正常不过的，也就是要讨论的异步的方式。</p><blockquote><p>一定有人会提议单开一个线程做收快递的任务，我同意这是一种解决方案，但是如果用等效的人类角度的语言来说，就是你将大脑的资源分成了两半，一半在烧脑编程，一半在盯着手机发呆，脑利用率下降太明显。而用异步的方式，你不需要关注手机，因为手机响了你就自然得到了通知。<br>当然，你也可以任性的说，我就喜欢等快递来了再干活。if so，我们就不要做朋友了。</p></blockquote><p>所以我们可以有一个推论：异步所解决的，就是节省低速的IO所阻塞的CPU计算时间。</p><p>转换一下思路，我们使用异步非阻塞的方式来构建这段业务，并借助异步思想早已深入人心的<code>javascript</code>语言来解释，可以是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ohs = <span class="built_in">require</span>(<span class="string">'./anticorruption/OpenHostService'</span>);</span><br><span class="line"><span class="keyword">var</span> localConvertingService = <span class="built_in">require</span>(<span class="string">'./services/LocalConverting'</span>);</span><br><span class="line"><span class="keyword">var</span> remoteRepository = <span class="built_in">require</span>(<span class="string">'./repositories/BusinessData'</span>);</span><br><span class="line"><span class="keyword">var</span> calculationService = <span class="built_in">require</span>(<span class="string">'./services/Calculation'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userData = req.body;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// level1 nest</span></span><br><span class="line">    ohs.retrieveResource(userData, <span class="function"><span class="keyword">function</span>(<span class="params">err, rs1</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// level2 nest</span></span><br><span class="line">        localConvertingService.unitize(rs1, <span class="function"><span class="keyword">function</span>(<span class="params">err, rs2</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                <span class="comment">// error handling</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//level3 nest</span></span><br><span class="line">            remoteRepository.loadBusinessData(rs2, <span class="function"><span class="keyword">function</span>(<span class="params">err, bs1</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                    <span class="comment">// error handling</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//level4 nest</span></span><br><span class="line">                calculationService.doCalculation(bs1, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                        <span class="comment">// error handling</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    res.view(result);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看着一层又一层的花括号也是醉了，我们之后会讨论如何解嵌套。那么这段代码所反应的是怎样的事实呢？如下示意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main) +++$                           $+++</span><br><span class="line">          \                         /</span><br><span class="line">ohs )      $++$                    /</span><br><span class="line">               \                  /</span><br><span class="line">rs1 )           $++$             /</span><br><span class="line">                    \           /</span><br><span class="line">s1  )                $++$      /</span><br><span class="line">                         \    /</span><br><span class="line">calc)                     $++$</span><br><span class="line"></span><br><span class="line">notes:</span><br><span class="line">$ code point</span><br><span class="line">+ thread busy</span><br><span class="line">- thread blocked(means, wasted)</span><br></pre></td></tr></table></figure><p>由于异步解放了原始的工作线程，使CPU资源可以不被线程的阻塞而被浪费，从而可以有效的提高吞吐率。</p><h2 id="异步的使用场景"><a href="#异步的使用场景" class="headerlink" title="异步的使用场景"></a>异步的使用场景</h2><blockquote><p>技术和选择和使用场景有着很大的关系，每项技术不都是银弹，使用对的工具/技术解决对的问题是开发者的义务。</p></blockquote><p>开发者最多关注的是计算密集和I/O密集这两个维度，对于这两个维度往往有着不同的技术选型。</p><h3 id="计算密集型应用"><a href="#计算密集型应用" class="headerlink" title="计算密集型应用"></a>计算密集型应用</h3><p>何为计算密集型应用？下面两个人畜皆知的函数都是计算密集型的。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F#</span></span><br><span class="line"><span class="keyword">let</span> fibonacci n =</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> f a b n =</span><br><span class="line">        <span class="keyword">match</span> n <span class="keyword">with</span></span><br><span class="line">        | <span class="number">0</span> -&gt; a</span><br><span class="line">        | <span class="number">1</span> -&gt; b</span><br><span class="line">        | n -&gt; (f b (a + b) (n - <span class="number">1</span>))</span><br><span class="line">    f <span class="number">0</span> <span class="number">1</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> factorial n = </span><br><span class="line">    <span class="keyword">match</span> n <span class="keyword">with</span></span><br><span class="line">    | <span class="number">0</span> -&gt; <span class="number">1</span></span><br><span class="line">    | n -&gt; n * factorial (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>尤其是第二个阶乘函数，如果在调用的时候不小心手抖多加了几个0，基本上可以出去喝个咖啡谈谈理想聊聊人生玩一天再回来看看有没有算完了。</p><p>简而言之，计算密集型的任务是典型的重度依赖CPU/GPU，不涉及磁盘、网络、输入输出的任务。游戏中场景渲染是计算密集的，MapReduce中的<code>Reduce</code>部分是计算密集的，视频处理软件的实时渲染是计算密集的，等等。</p><p>在这样的场景之下，异步是没有太大的优势的，因为计算资源就那么多，不增不减，用多线程也好用异步流也好，CPU永远处于高负荷状态，这病不能治，解决方案只能是：</p><ul><li>横向的集群方案</li><li>纵向的升级主机CPU或采用更快的GPU</li><li>优化算法，使之空间/时间成本降低</li></ul><p>但是有一种场景是可以考虑使用异步的，考虑一个分布式的计算场，一个计算任务发起后，协调者需要等待所有的计算节点子结果集返回后者能做最后的结果化简。那么此时，虽然场景是计算密集的，但是由于涉及到任务的依赖协调，采用异步的方式，可以避免等待节点返回结果时的阻塞，也可以避免多线程方式的上下文切换开销，要知道在这样的场景下，上下文切换的开销是可以大的惊人的。</p><p>相似的场景还有，一个桌面应用，假设点击界面上一个按钮之后会进行大量的计算，如果采用同步阻塞的方式，那么当计算完成之前UI是完全阻塞的跟假死一样，但是如何使用异步的方式，则不会发生UI阻塞，计算在结束后会以异步的方式来更新界面。还记得WinForm编程中的<code>BeginInvoke</code>和<code>EndInvoke</code>吗？虽然它们的实现方式是以单独线程的方式来实现异步操作的，但是这仍然属于异步流控制的范畴。</p><blockquote><p>异步的实现方式有很多，可以使用已有的线程技术(Rx和C#的async/await就是使用这种方式)，也可以使用类似于libuv之类的I/O异步封装配合事件驱动(node就是使用这种方式)。并于异步流控制的部分我们之后会讨论。</p></blockquote><p>所以如果你的应用是计算密集型的，在充分分析场景的前提下可以适当的采用异步的方式。大部分的计算密集型场景是不用介入异步控制技术的，除非它可以显著改善应用的流程控制能力。</p><h3 id="I-O密集型应用"><a href="#I-O密集型应用" class="headerlink" title="I/O密集型应用"></a>I/O密集型应用</h3><p>何为I/O密集型应用？Web服务器天然就是I/O密集型的，因为有着高并发量与网络吞吐。文件服务器和CDN是I/O密集型的，因为高网络吞吐高磁盘访问量。数据库是I/O密集型的，涉及磁盘的访问及网络访问。说到底，一切和输入输出相关的场景都是I/O密集型的。</p><p>I/O囊括的方面主要是两方面：</p><ul><li>网络访问</li><li>磁盘读写</li></ul><p>简单粗暴的解释，就是接在主板南桥上的设备的访问都属于I/O。多提一句，内存是直接接在北桥上的，这货，快。</p><p>开发者遇到最多的场景便是Web应用和数据库的高并发访问。其它的服务调用都属于网络I/O，可归为一类。</p><p>典型的就是Web服务器接收到了HTTP请求，然后具体的Web框架会单开一个线程服务这个请求。因为HTTP是构建在TCP之上的，所以在请求结束返回结果之前，socket并没有关闭，在windows系统上这就是一个句柄，在*nix之类的posix系统上这就是一个文件描述符，都是系统资源紧张的很。这是硬性的限制，能打开多少取决与内存与操作系统，我们暂且不关注这部分。该线程如果采用同步的方式，那么它程的生命周期会吻合socket的生命周期，期间不管是访问文件系统花了10s导致cpu空闲10s的时间片，还是访问数据库有3s的时间片空隙，这个线程都不会释放，就是说，这个线程是专属的，即便是使用线程池技术，该占还得占。</p><p>这有点像是银行的VIP专线，服务人员就那么多，如果每人服务一个VIP且甭管人家在聊人生聊理想还是默默注视，后面人就算是VIP也得等着，因为没人可以服务你了。</p><p>那么我们继续深入，线程也是一种相对昂贵的资源，虽然比创建进程快了太多，但是仍然有限制。windows的32位操作系统默认每进程可使用2GB用户态内存（64bit是8Tb用户态内存, LoL），每个线程有1Mb的栈空间（能改，但不建议。）；*nix下是8Mb栈空间，32位的进程空间是4Gb，64位则大到几近没有用户态内存限制。我们可以假定32位系统下一个合理的单进程线程数量：1500。那么一个进程最大的并发量就是1500请求了，抛开多核不谈，这1500个线程就算轮班倒，并发量不会再上去了，因为一个socket一个线程。如果每个请求都是web服务器处理1s加访问数据库服务器3s，那么时钟浪费率则大的惊人。况且，1500个线程的上下文切换想想都是<a href="http://www.zhihu.com/question/23544144" target="_blank" rel="noopener">开心，开了又开</a>。</p><p>不幸的是，之前的web服务器都是这么干的。此时我们思考，如果采用异步的方式，那3s的阻塞完全可以规避，从而使线程轮转的更快，因为1s的处理时间结束后线程返回线程池然后服务于另一个请求，从而整体提高服务器的吞率。</p><blockquote><p>事实上，node压根就没有多线程的概念，使用事件循环配合异步I/O，一个线程总够你甩传统的Web服务器吞吐量几条街。没错，请叫我node雷锋。</p></blockquote><p>再继续深入异步编程前，我们先理一理几个经常混淆的概念。</p><h2 id="一些概念的区别"><a href="#一些概念的区别" class="headerlink" title="一些概念的区别"></a>一些概念的区别</h2><h3 id="多核与多线程"><a href="#多核与多线程" class="headerlink" title="多核与多线程"></a>多核与多线程</h3><p>多核是一种物理上的概念，即指主机所拥有的物理CPU核心数量，<code>总核心数 = CPU个数 * 每个CPU的核心数</code>。每个核心是独立的，可以同时服务于不同的进程/线程。</p><p>多线程是一种操作系统上的概念，单个进程可能创建多个线程来达到细粒度进行流程控制的目的。操作系统的核心态调度进程与线程，在用户态之下其实还可以对单个线程有更细粒度的控制，这称之为<code>协程（coroutine）</code>或<code>纤程（fibers）</code>。</p><p>多线程是指在单个进程空间内通过操作系统的调度来达到多流程同时执行的一种机制，当然，单个CPU核心在单位时间内永远都只是执行一个线程的指令，所以需要以小的时间片段雨露均沾的执行每个线程的部分指令。在切换线程时是有上下文的切换的，包括寄存器的保存/还原，线程堆栈的保存/还原，这就是开销。</p><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p>关于并行，真相只有一个，单个CPU核心在单位时间内只能执行一个线程的指令，所以如果总核心数为20，那么我们可以认为该主机的并行能力为20，但是用户态的并行能力是要比这个低的，因为操作系统服务和其它软件也是要用cpu的，因此这个数值是达不到的。</p><p>一个题外话，如果并行能力为20，那么我们可以粗略的认为，该主机一次可以同时执行20个线程，如果程序的线程使用率健康的话，保持线程池为20左右的大小可以做到完全的线程并行执行没有上下文切换。</p><p>那么并发则关注于应用的处理能力。这是一个更加侧重网络请求/服务响应能力的概念，可以理解为单位时间内可以同时接纳并处理用户请求的能力。它和多少CPU没有必然的关系，单纯的考量了服务器的响应回复能力。</p><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞/非阻塞与同步/异步是经常被混淆的。同步/异步其实在说事件的执行顺序，阻塞/非阻塞是指做一件事能不能立即返回。</p><p>我们举个去KFC点餐的例子。点完餐交完钱了，会有这么几种情况：</p><ul><li>服务人员直接把东西给我，因为之前已经做好了，所以能马上给我，这叫做非阻塞，我不需要等，结果立即返回。这整个过程是同步完成的。</li><li>服务人员一看没有现成的东西了，跑去现做，那么我就在这儿一直等，没刷微信没做别的干等，等到做出来拿走，这叫阻塞，因为我傻到等结果返回再离开点餐台。这整个过程是同步完成的。</li><li>服务人员一看没有现成的东西了，跑去现做，并告诉我说：先去做别的，做好了我叫你的号。于是我开心的找了个座位刷微信，等叫到了我的号了取回来。这叫做非阻塞，整个过程是异步的，因为我还刷了微信思考了人生。</li></ul><p>异步是非阻塞的，但是同步可以是阻塞的也可以是非阻塞的，取决于消费的资源。</p><h2 id="异步编程的挑战"><a href="#异步编程的挑战" class="headerlink" title="异步编程的挑战"></a>异步编程的挑战</h2><p>异步编程的主要困难在于，构建程序的执行逻辑时是非线性的，这需要将任务流分解成很多小的步骤，再通过异步回调函数的形式组合起来。在异步大行其道的<code>javascript</code>界经常可以看到很多层的<code>});</code>，简单酸爽到妙不可言。这一节将讨论一些常用的处理异步的技术手段。</p><h3 id="回调函数地狱"><a href="#回调函数地狱" class="headerlink" title="回调函数地狱"></a>回调函数地狱</h3><p>开头的那个例子使用了4层的嵌套回调函数，如果流程更加复杂的话，还需要嵌套更多，这不是一个好的实践。而且以回调的方式组织流程，在视觉上并不是很直白，我们需要更加优雅的方式来解耦和组织异步流。</p><p>使用传统的<code>javascript</code>技术，可以展平回调层次，例如我们可以改写之前的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ohs = <span class="built_in">require</span>(<span class="string">'./anticorruption/OpenHostService'</span>);</span><br><span class="line"><span class="keyword">var</span> localConvertingService = <span class="built_in">require</span>(<span class="string">'./services/LocalConverting'</span>);</span><br><span class="line"><span class="keyword">var</span> remoteRepository = <span class="built_in">require</span>(<span class="string">'./repositories/BusinessData'</span>);</span><br><span class="line"><span class="keyword">var</span> calculationService = <span class="built_in">require</span>(<span class="string">'./services/Calculation'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userData = req.body;</span><br><span class="line"></span><br><span class="line">    ohs.retrieveResource(userData, ohsCb);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ohsCb</span>(<span class="params">err, rs1</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        localConvertingService.unitize(rs1, convertingCb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">convertingCb</span>(<span class="params">err, rs2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        remoteRepository.loadBusinessData(rs2, loadDataCb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">loadDataCb</span>(<span class="params">err, bs1</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        calculationService.doCalculation(bs1 , calclationCb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">calclationCb</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.view(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解嵌套的关键在于如何处理函数作用域，之后金字塔厄运迎刃而解。</p><p>还有一种更为优雅的<code>javascript</code>回调函数处理方式，可以参考后面的<code>Promise</code>部分。</p><p>而对于像<code>C#</code>之类的内建异步支持的语言，那么上述问题更加的不是问题，例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> IActionResult <span class="title">CrazyCase</span>(<span class="params">UserData userData</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ticket = CrazyApplication.Ticket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ohsFactory = <span class="keyword">new</span> OpenHostServiceFactory(ticket);</span><br><span class="line">    <span class="keyword">var</span> ohs = ohsFactory.CreateService();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ohsAdapter = <span class="keyword">new</span> OhsAdapter(userData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rs1 = <span class="keyword">await</span> ohs.RetrieveResource(ohsAdapter);</span><br><span class="line">    <span class="keyword">var</span> rs2 = <span class="keyword">await</span> _localConvertingService.Unitize(rs1);</span><br><span class="line">    <span class="keyword">var</span> bs1 = <span class="keyword">await</span> _remoteRepository.LoadBusinessData(rs2);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> _calculationService.DoCalculation(bs1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> View(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>async/await</code>这糖简直不能更甜了，其它<code>C#</code>的编译器还是生成了使用<code>TPL</code>特性的代码来做异步，说白了就是一些<code>Task&lt;T&gt;</code>在做后台的任务，当遇到<code>async/await</code>关键字后，编译器将该方法编译为状态机，所以该方法就可以在<code>await</code>的地方挂起和恢复了。整个的开发体验几乎完全是同步式的思维在做异步的事儿。后面有关于<code>TPL</code>的简单介绍。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>由于异步执行采用非阻塞的方式，所以当前的执行线程在调用后捕获不到异步执行栈，因此传统的异步处理将不再适用。举两个例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Task.Factory.StartNew(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"diablo coming."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InvalidOperationException e) &#123;</span><br><span class="line">    <span class="comment">// nothing captured.</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'diablo coming.'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// nothing captured.</span></span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这两个例子中，<code>try</code>语句块中的调用会立即返回，不会触发<code>catch</code>语句。那么如何在异步中处理异常呢？我们考虑异步执行结束后会触发回调函数，那么这便是处理异常的最佳地点。<code>node</code>的回调函数几乎总是接受一个错误作为其首个参数，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'file.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123; &#125;);</span><br></pre></td></tr></table></figure><p>其中的<code>err</code>是由异步任务本身产生的，这是一种自然的处理异步异常的方式。那么回到<code>C#</code>中，因为有了好用的<code>async/await</code>，我们可以使用同步式的思维来处理异常：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Factory.StartNew(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"diablo coming."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InvalidOperationException e) &#123;</span><br><span class="line">    <span class="comment">// exception handling.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器所构建的状态机可以支持异常的处理，简直是强大到无与伦比。当然，对于<code>TPL</code>的处理也有其专属的支持，类似于<code>node</code>的处理方式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Task.Factory.StartNew(() =&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"diablo coming."</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.ContinueWith(parent =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> parentException = parent.Exception;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意这里访问到的<code>parent.Exception</code>是一个<code>AggregateException</code>类型，对应的处理方式也较传统的异常处理也稍有不同：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parentException.Handle(e =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(e <span class="keyword">is</span> InvalidOperationException) &#123;</span><br><span class="line">        <span class="comment">// exception handling.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="异步流程控制"><a href="#异步流程控制" class="headerlink" title="异步流程控制"></a>异步流程控制</h3><p>异步的技术也许明白了，但是遇到更复杂的异步场景呢？假设我们需要异步并行的将目录下的3个文件读出，全部完成后进行内容拼接，那么就需要更细粒度的流程控制。</p><p>我们可以借鉴<a href="https://github.com/caolan/async" target="_blank" rel="noopener">async.js</a>这款优秀的异步流程控制库所带来的便捷。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.parallel([</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            fs.readFile(<span class="string">'f1.txt'</span>, <span class="string">'utf-8'</span>, callback)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            fs.readFile(<span class="string">'f2.txt'</span>, <span class="string">'utf-8'</span>, callback)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            fs.readFile(<span class="string">'f3.txt'</span>, <span class="string">'utf-8'</span>, callback)</span><br><span class="line">    &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, fileResults</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// concat the content of each files</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果使用<code>C#</code>并配合<code>TPL</code>，那么这个场景可以这么实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">AsyncDemo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> files = <span class="keyword">new</span> []&#123;</span><br><span class="line">        <span class="string">"f1.txt"</span>,</span><br><span class="line">        <span class="string">"f2.txt"</span>,</span><br><span class="line">        <span class="string">"f3.txt"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tasks = files.Select(file =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> Task.Factory.StartNew(() =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> File.ReadAllText(file);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> Task.WhenAll(tasks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fileContents = tasks.Select(t =&gt; t.Result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// concat the content of each files</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再回到我们开头遇到到的那个场景，可以使用<code>async.js</code>的<code>waterfall</code>来简化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ohs = <span class="built_in">require</span>(<span class="string">'./anticorruption/OpenHostService'</span>);</span><br><span class="line"><span class="keyword">var</span> localConvertingService = <span class="built_in">require</span>(<span class="string">'./services/LocalConverting'</span>);</span><br><span class="line"><span class="keyword">var</span> remoteRepository = <span class="built_in">require</span>(<span class="string">'./repositories/BusinessData'</span>);</span><br><span class="line"><span class="keyword">var</span> calculationService = <span class="built_in">require</span>(<span class="string">'./services/Calculation'</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userData = req.body;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span>.waterfall([</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            ohs.retrieveResource(userData, <span class="function"><span class="keyword">function</span>(<span class="params">err, rs1</span>) </span>&#123;</span><br><span class="line">                callback(err, rs1);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">rs1, callback</span>) </span>&#123;</span><br><span class="line">            localConvertingService.unitize(rs1, <span class="function"><span class="keyword">function</span>(<span class="params">err, rs2</span>) </span>&#123;</span><br><span class="line">                callback(err, rs2);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">rs2, callback</span>) </span>&#123;</span><br><span class="line">            remoteRepository.loadBusinessData(rs2, <span class="function"><span class="keyword">function</span>(<span class="params">err, bs1</span>) </span>&#123;</span><br><span class="line">                callback(err, bs1);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">bs1, callback</span>) </span>&#123;</span><br><span class="line">            calculationService.doCalculation(bs1, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">                callback(err, result);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.view(result);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要处理前后无依赖的异步任务流可以使用<code>async.series()</code>来串行异步任务，例如先开电源再开热水器电源最后亮起红灯，并没有数据的依赖，但有先后的顺序。用法和之前的<code>parallel()</code>及<code>waterfall()</code>大同小异。另外还有优秀的轻量级方案<a href="https://github.com/creationix/step" target="_blank" rel="noopener">step</a>，以及为<code>javascript</code>提供monadic扩展的<a href="https://github.com/JeffreyZhao/wind" target="_blank" rel="noopener">wind.js</a>（特别像<code>C#</code>提供的方案），有兴趣可以深入了解。</p><h3 id="反人类的编程思维"><a href="#反人类的编程思维" class="headerlink" title="反人类的编程思维"></a>反人类的编程思维</h3><blockquote><p>异步是反人类的</p></blockquote><p>人类生活在一个充满异步事件的世界，但是开发者在构建应用时却遵循同步式思维，究其原因就是因为同步符合直觉，并且可以简化应用程序的构建。</p><p>究其深层原因，就是因为现实生活中我们是在演绎，并通过不同的<code>口头回调</code>来完成一系列的异步任务，我们会说你要是有空了来找我聊人生，货到了给我打电话，小红你写完文案了交给小明，小丽等所有的钱都到了通知小强……而在做开发时，我们是在列清单，我们的说法就是：我等着你有空然后开始聊人生，我等着货到了然后我就知道了，我等着小红文案写完了然后开始让她交给小明，我等着小丽确认所有的钱到了然后开始让她通知小强……</p><p>同步的思维可以简化编程的关注点，但是没有将流程进行现实化的切分，我们总是倾向于用同步阻塞的方式来将开发变成简单的步骤程序化，却忽视了用动态的视角以及消息/事件驱动的方式构建任务流程。</p><p>异步在编程看来是反人类的，但是从业务角度看却是再合理不过的了。通过当的工具及技术，使用异步并不是难以企及的，它可以使应用的资源利用更加的高效，让应用的响应性更上一个台阶。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="Promise-Deferred"><a href="#Promise-Deferred" class="headerlink" title="Promise/Deferred"></a>Promise/Deferred</h3><blockquote><p>在一般情况下，Promise、Deferred、Future这些词可以当做是同义词，描述的是同一件事情。</p></blockquote><p>在<code>jQuery 1.5+</code>之后出现了一种新的API调用方式，相比于旧的API，新的方式更好的解耦了关注点，并带来了更好的组合能力。</p><p>我们看一个传统的使用<code>ajax</code>的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/api/service1', &#123;</span><br><span class="line">    success: onSuccess,</span><br><span class="line">    failure: onFailure,</span><br><span class="line">    always:  onAlways</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用新的API后，调用的方式变成了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/api/service1')</span><br><span class="line">    .done(onSussess)</span><br><span class="line">    .fail(onFailure)</span><br><span class="line">    .always(onAlways);</span><br></pre></td></tr></table></figure><p><code>get</code>方法返回的是一个<code>promise</code>对象，表示这个方法会在未来某个时刻执行完毕。</p><p><code>Promise</code>是<a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="noopener">CommonJS</a>提出的规范，而<code>jQuery</code>的实现在其基础上有所扩展，旗舰级的实现可以参考<a href="https://github.com/kriskowal" target="_blank" rel="noopener">Kris Kowal</a>的<a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">Q.js</a>。</p><p>我们使用<code>jQuery</code>来构建一个<code>promise</code>对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longTimeOperation = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deferred = $.Deferred();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// taste like setTimeout()</span></span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// do operation.</span></span><br><span class="line">        deferred.resolve();</span><br><span class="line">        <span class="comment">// if need error handling, use deferred.reject();</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> deferred.promise();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.when(longTimeOperation())</span><br><span class="line">    .done(success)</span><br><span class="line">    .fail(failure);</span><br></pre></td></tr></table></figure><p>由于<code>jQuery</code>生成的<code>Deferred</code>可以自由的进行<code>resolve()</code>和<code>reject()</code>，所以在返回时我们使用<code>.promise()</code>生成不含这个两方法的对象，从而更好的封装逻辑。</p><p>那么<code>Promise</code>究竟带给我们的便利是什么？<code>Promise</code>表示在未来这个任务会成功或失败，可以使用1和0来表示，那么开发者马上就开始欢呼了，给我布尔运算我能撬动地球！于是，我们可以写出如下的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.when(uploadPromise, downloadPromise)</span><br><span class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// do animation.</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>对于开头的那个例子我们说过有着更优雅的解回调函数嵌套的方案，那就是使用<code>promise</code>，我们来尝试改写开头的那个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ohs = <span class="built_in">require</span>(<span class="string">'./anticorruption/OpenHostService'</span>);</span><br><span class="line"><span class="keyword">var</span> localConvertingService = <span class="built_in">require</span>(<span class="string">'./services/LocalConverting'</span>);</span><br><span class="line"><span class="keyword">var</span> remoteRepository = <span class="built_in">require</span>(<span class="string">'./repositories/BusinessData'</span>);</span><br><span class="line"><span class="keyword">var</span> calculationService = <span class="built_in">require</span>(<span class="string">'./services/Calculation'</span>);</span><br><span class="line"><span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userData = req.body;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">deferredCallback</span>(<span class="params">deferred</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                deferred.reject(err);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">                deferred.resolve(args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">makeDeferred</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> deferred = $.Deferred();</span><br><span class="line">        <span class="keyword">var</span> callback = deferredCallback(deferred);</span><br><span class="line">        fn(callback);</span><br><span class="line">        <span class="keyword">return</span> deferred.promise();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> retrieveResourcePromise = makeDeferred(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        ohs.retrieveResource(userData, callback);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> convertingPromise = makeDeferred(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        localConvertingService.unitize(rs1, callback);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> loadBusinessDataPromise = makeDeferred(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        remoteRepository.loadBusinessData(rs2, callback);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> calculationPromise = makeDeferred(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        calculationService.doCalculation(bs1 , callback);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pipedPromise = retrieveResourcePromise</span><br><span class="line">        .pipe(convertingPromise)</span><br><span class="line">        .pipe(loadBusinessDataPromise)</span><br><span class="line">        .pipe(calculationPromise);</span><br><span class="line"></span><br><span class="line">    pipedPromise</span><br><span class="line">        .done(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            res.view(result);</span><br><span class="line">        &#125;)</span><br><span class="line">        .fail(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用了一个高阶函数来生成可以兼容<code>deferred</code>构造的回调函数，进而使用<code>jQuery</code>的<code>pipe</code>特性(在<code>Q.js</code>里可以使用<code>then()</code>组合每个<code>promise</code>)，使解决方案优雅了很多，而这个工具函数在<code>Q.js</code>里直接提供，于是新的解决方案可以如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ohs = <span class="built_in">require</span>(<span class="string">'./anticorruption/OpenHostService'</span>);</span><br><span class="line"><span class="keyword">var</span> localConvertingService = <span class="built_in">require</span>(<span class="string">'./services/LocalConverting'</span>);</span><br><span class="line"><span class="keyword">var</span> remoteRepository = <span class="built_in">require</span>(<span class="string">'./repositories/BusinessData'</span>);</span><br><span class="line"><span class="keyword">var</span> calculationService = <span class="built_in">require</span>(<span class="string">'./services/Calculation'</span>);</span><br><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userData = req.body;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> retrieveResourceFn = Q.denodeify(ohs.retrieveResource)</span><br><span class="line">    <span class="keyword">var</span> convertingFn = Q.denodeify(localConvertingService.unitize);</span><br><span class="line">    <span class="keyword">var</span> loadBusinessDataFn = Q.denodeify(remoteRepository.loadBusinessData);</span><br><span class="line">    <span class="keyword">var</span> calculationFn = Q.denodeify(calculationService.doCalculation);</span><br><span class="line"></span><br><span class="line">    retrieveResourceFn(userData)</span><br><span class="line">        .then(convertingFn)</span><br><span class="line">        .then(loadBusinessDataFn)</span><br><span class="line">        .then(calculationFn)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            res.view(result);</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// error handling</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们如何看待<code>TPL</code>特性呢？我们看看<code>TPL</code>可以做什么：</p><ul><li>以<code>Task</code>为基本构造单位，执行时不阻塞调用线程</li><li>每个<code>Task</code>是独立的，<code>Task</code>有不同的状态，可以使用<code>Task.Status</code>获取</li><li><code>Task</code>可以组合，使用类似<code>.ContinueWith(Task))</code>以及<code>.WhenAll(Task[])</code>、<code>.WhenAny(Task[])</code>的方式自由组合。</li></ul><p>对比一下<code>Promise</code>：</p><ul><li>以<code>Promise</code>为基本构造单位，表示一个将来完成的任务，调用时立即返回</li><li>每个<code>Promise</code>是独立的，<code>Promise</code>有不同的状态，可以使用<code>.state</code>获取</li><li><code>Promise</code>可以组合，使用<code>.then()</code>、<code>.pipe()</code>以及<code>.when()</code>来组合执行流程</li></ul><p>可以看到，不论是<code>Promise</code>还是<code>TPL</code>，在设计上都有着惊人的相似性。我们有理由猜想在其它的的语言或平台都存在着类似的构造，因为异步说白了，就是让未来完成的事情自己触发后续的步骤。</p><h3 id="Pull-vs-Push"><a href="#Pull-vs-Push" class="headerlink" title="Pull vs. Push"></a>Pull vs. Push</h3><p>在<a href="http://en.wikipedia.org/wiki/Design_Patterns" target="_blank" rel="noopener">GoF32</a>中没有提到迭代器模式(Iterator)与观察者模式(Observer)的区别和联系，其实这两个模式有着千丝万缕的联系。</p><p>Iterator反映的是一种Pull模型，数据通过同步的方式从生产者那里拉过来，我们通过它的定义便可看到这一事实：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IEnumerator&lt;out T&gt;: IDisposable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>;</span><br><span class="line">    T Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阻塞的方式调用<code>MoveNext()</code>，数据一个一个的拉取到本地。</p><p>而Observer反映的是一种Push模型，通过注册一个观察者（类似于回调函数），当生产者有数据时，主动的推送到观察者手里。观察者注册结束后，本地代码没有阻塞，推送数据的整个过程是异步执行的。我们通过它的定义来对比Iterator：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IObserver&lt;in T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnCompleted</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnError</span>(<span class="params">Exception exception</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnNext</span>(<span class="params">T <span class="keyword">value</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，其实这两个接口是完全对偶的（参见<a href="http://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)" target="_blank" rel="noopener">Erik Meijer</a>大大的论文<a href="http://csl.stanford.edu/~christos/pldi2010.fit/meijer.duality.pdf" target="_blank" rel="noopener">Subject/Observer is Dual to Iterator</a>）：</p><ul><li><code>MoveNext()</code>拉取下一个数据，<code>OnNext(T)</code>推送下一个数据</li><li><code>MoveNext()</code>返回值指示了有无剩余数据（完成与否），<code>OnCompleted()</code>指示了数据已完成（推送数据完成的消息）</li><li>Iterator是同步的，所以出现了异常直接在当前运行栈上，Observer是异步的，所以需要另一种方式来通知发生了异常（参见上文中的异步处理一节），于是有了<code>OnError(Exception)</code>。</li></ul><p>那么事情就变的有意思了，我们知道<code>Enumerable</code>的数据可以任意的方式组合，于是产生了像<code>LINQ</code>之类的库可供我们使用，但是这是一种阻塞的方式，因为Iterator本身就是一种Pull模型，这造就了同步等待的结果。</p><blockquote><p>没错你是对的，如果使用EF之类的框架来查询数据库，大部分的操作是延迟执行的，表明操作并没有发生而是像占位符一样在那里。但是别忘了，你最终需要去查询数据库的，在查询的一刹那，世界还是阻塞的，等结果吧亲。</p></blockquote><p>而Observer是异步Push的，有点像是事件驱动，有事件了触发，没事件了也不干扰订阅者的执行。</p><blockquote><p>你是不是也隐隐的觉得事件也可以和Push模式一样有统一的模型？而且不只一次？</p></blockquote><p>好，我们重复一遍：事件，非阻塞触发（并带有事件数据）。Push，非阻塞通知订阅者。</p><p>其实，这是同一种模式，语言中对事件（就是<code>event</code>关键字）的支持其实就是对Observer模式的支持，而<code>foreach</code>则实现了对Iterator模式的语言内建支持。所谓设计模式，就是因为语言的内建支持不够而出现的，说白了，是语言的补丁。</p><p>那么我们来看一看异常强大的<a href="https://github.com/Reactive-Extensions/" target="_blank" rel="noopener">Rx</a>如何改变事件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unitized event</span></span><br><span class="line"><span class="keyword">var</span> mouseDown = Observable</span><br><span class="line">    .FromEventPattern&lt;MouseEventArgs&gt;(<span class="keyword">this</span>.myPictureBox, <span class="string">"MouseDown"</span>)</span><br><span class="line">    .Select(x =&gt;x.EventArgs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// unitized APM model</span></span><br><span class="line"><span class="keyword">var</span> request = WebRequest.Create(<span class="string">"https://www.shinetechchina.org"</span>);</span><br><span class="line"><span class="keyword">var</span> webRequest = Observable</span><br><span class="line">    .FromAsyncPattern&lt;WebResponse&gt;(request.BeginGetResponse, request.EndGetResponse);</span><br></pre></td></tr></table></figure><p>最后我们看一个更加复杂的组合事件的例子，也就是之前一直讨论的异步流组合问题。Drag and Drop这个场景做<code>Winform</code>的同学不会陌生，需要多少代码冷暖自知，如果借助<code>Rx</code>，那么事情就简单很多：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mouseDown = Observable</span><br><span class="line">    .FromEventPattern&lt;MouseEventArgs&gt;(<span class="keyword">this</span>.controlSource, <span class="string">"MouseDown"</span>)</span><br><span class="line">    .Select(x =&gt; x.EventArgs.GetPosition(<span class="keyword">this</span>));</span><br><span class="line"><span class="keyword">var</span> mouseUp = Observable</span><br><span class="line">    .FromEventPattern&lt;MouseEventArgs&gt;(<span class="keyword">this</span>.controlSource, <span class="string">"MouseUp"</span>)</span><br><span class="line">    .Select(x =&gt; x.EventArgs.GetPosition(<span class="keyword">this</span>));</span><br><span class="line"><span class="keyword">var</span> mouseMove = Observable</span><br><span class="line">    .FromEventPattern&lt;MouseEventArgs&gt;(<span class="keyword">this</span>.controlSource, <span class="string">"MouseMove"</span>)</span><br><span class="line">    .Select(x =&gt; x.EventArgs.GetPosition(<span class="keyword">this</span>));</span><br><span class="line"><span class="keyword">var</span> dragandDrop = </span><br><span class="line">    <span class="keyword">from</span> down <span class="keyword">in</span> mouseDown</span><br><span class="line">    <span class="keyword">from</span> move <span class="keyword">in</span> mouseMove.StartWith(down).TakeUntil(mouseUp)</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span> &#123;</span><br><span class="line">        X = move.X - down.X,</span><br><span class="line">        Y = move.Y - down.Y</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">dragandDrop.Subscribe(<span class="keyword">value</span> =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    DesktopCanvas.SetLeft(<span class="keyword">this</span>.controlSource, <span class="keyword">value</span>.X);</span><br><span class="line">    DesktopCanvas.SetTop(<span class="keyword">this</span>.controlSource, <span class="keyword">value</span>.Y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Rx</code>也提供了<code>javascript</code>扩展，有兴趣可以深入研究。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;导言&quot;&gt;&lt;a href=&quot;#导言&quot; class=&quot;headerlink&quot; title=&quot;导言&quot;&gt;&lt;/a&gt;导言&lt;/h2&gt;&lt;p&gt;现代的应用程序面临着诸多的挑战，如何构建具有可伸缩性和高性能的应用成为越来越多软件开发者思考的问题。随着应用规模的不断增大，业务复杂性的增长
      
    
    </summary>
    
      <category term="productivity" scheme="https://lurongkai.github.io/categories/productivity/"/>
    
    
      <category term="productivity" scheme="https://lurongkai.github.io/tags/productivity/"/>
    
      <category term="asynchronous" scheme="https://lurongkai.github.io/tags/asynchronous/"/>
    
      <category term="javascript" scheme="https://lurongkai.github.io/tags/javascript/"/>
    
      <category term="C#" scheme="https://lurongkai.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>coolshell puzzle guides</title>
    <link href="https://lurongkai.github.io/2014/08/05/coolshell-puzzle-guides/"/>
    <id>https://lurongkai.github.io/2014/08/05/coolshell-puzzle-guides/</id>
    <published>2014-08-05T02:14:41.000Z</published>
    <updated>2019-02-14T02:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.coolshell.cn" target="_blank" rel="noopener">CoolShell</a>博主<a href="http://weibo.com/haoel" target="_blank" rel="noopener">陈皓</a>做了一个在线的puzzle很有意思，链接在<a href="http://fun.coolshell.cn" target="_blank" rel="noopener">这里</a>，这里记录一下解题的一些步骤。</p><h2 id="Puzzle-0"><a href="#Puzzle-0" class="headerlink" title="Puzzle 0"></a>Puzzle 0</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++++++++[&gt;+&gt;++&gt;+++&gt;++++&gt;+++++&gt;++++++&gt;+++++++&gt;++++++++&gt;+++++++++&gt;++++++++++&gt;+++++++++++&gt;++++++++++++&gt;+++++++++++++&gt;++++++++++++++&gt;+++++++++++++++&gt;++++++++++++++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+++.---&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;--.++&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;.&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.</span><br></pre></td></tr></table></figure><p>如果之前没有听说过变态的编程语言，就让你见识一下。<a href="http://www.muppetlabs.com/~breadbox/bf/" target="_blank" rel="noopener">BrainFuck</a>也称BF，是一门只有8个指令构成的图灵完备的语言。<a href="http://www.coolshell.cn" target="_blank" rel="noopener">CoolShell</a>博主<a href="http://weibo.com/haoel" target="_blank" rel="noopener">陈皓</a>写过一篇简单的介绍在<a href="http://coolshell.cn/articles/1142.html" target="_blank" rel="noopener">这里</a><br>具体的指令解释不多说了，直接打长<a href="http://esoteric.sange.fi/brainfuck/impl/interp/i.html" target="_blank" rel="noopener">这里</a>，把上面的指令粘进去，运行得到下一关的地址：<code>welcome.html</code>。</p><h2 id="Puzzle-welcome-html"><a href="#Puzzle-welcome-html" class="headerlink" title="Puzzle welcome.html"></a>Puzzle welcome.html</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X * Y</span><br><span class="line">2, 3, 6, 18, 108, ?</span><br><span class="line">What is the meaning of life, the universe and everything?</span><br><span class="line">生命、宇宙以及任何事情的终极答案</span><br></pre></td></tr></table></figure><a id="more"></a><p>这题有两个线索，首先是这串数字，其次是<code>生命、宇宙以及任何事情的终极答案</code>。数字序列找规律并不复杂，每个数字是前两个数字之积，那么直接用<code>18 * 108</code>的结果<code>1944</code>尝试进入下一关，发现只找到了一个答案。第二个答案很有意思，或者说很<code>极客</code>很<code>宅</code>，直接google发现和《银河系漫游指南》有关，wiki地址在<a href="http://en.wikipedia.org/wiki/Answer_to_Life,_the_Universe,_and_Everything" target="_blank" rel="noopener">这里</a>。</p><p>用<code>1944 * 42</code>的答案<code>81648</code>进入下一关。</p><h2 id="Puzzle-81648-html"><a href="#Puzzle-81648-html" class="headerlink" title="Puzzle 81648.html"></a>Puzzle 81648.html</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">macb() ? lpcbyu(&amp;gbcq/_\021%ocq\012\0_=w(gbcq)/_dak._=&#125;_ugb_[0q60)s+</span><br></pre></td></tr></table></figure><p>放眼忘去是<code>Dvorak</code>键盘，点图片可以看到详细信息。那么意图很明显了，<code>Dvorak</code>和<code>QWERTY</code>键盘转换一下看看会怎么样？这里有个在线的<a href="http://wbic16.xedoloh.com/dvorak.html" target="_blank" rel="noopener">转换工具</a>，然后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main() &#123; <span class="built_in">printf</span>(&amp;unix[<span class="string">"\021%six\012\0"</span>],(unix)[<span class="string">"have"</span>]+<span class="string">"fun"</span><span class="number">-0x60</span>);&#125;</span><br></pre></td></tr></table></figure><p>WTF……搜了一下，这是87年国际C语言混乱大赛的一段代码。C语言了解不多，趁这个机会了解了解戳<a href="http://blog.csdn.net/jishu360/article/details/8104499" target="_blank" rel="noopener">这里</a>，还有<a href="http://blog.itpub.net/12443821/viewspace-671745" target="_blank" rel="noopener">这里</a>，列一些解此题的关键知识点。</p><ul><li>unix关键字相当于<code>#define unix 1</code></li><li>数组的引用，array[num]和num[array]效果相同，所以(unix)[“have”] 等于”have”[unix]，结果是<code>a</code>，ASCII是0x61</li><li><code>0x61 + &quot;fun&quot; - 0x60</code>相当于对<code>fun</code>右移<code>0x61</code>指针再左移<code>0x60</code>指针，也就是说<code>fun</code>右称一位，结果是<code>un</code></li><li>\021是换页，于是<code>&amp;unix[&quot;\021%six\012\0&quot;]</code>约为<code>&amp;unix[&quot;\n%six\n\0&quot;]</code>，<code>%s</code>被替为前面的<code>un</code>，<code>&amp;unix</code>再跳过了第一个<code>\n</code>，所以结果是<code>unix</code></li></ul><p>使用<code>unix</code>，进入下一题。</p><h2 id="Puzzle-unix-html"><a href="#Puzzle-unix-html" class="headerlink" title="Puzzle unix.html"></a>Puzzle unix.html</h2><p>微信扫码，得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[abcdefghijklmnopqrstuvwxyz] &lt;=&gt; [pvwdgazxubqfsnrhocitlkeymj]</span><br></pre></td></tr></table></figure><p>看来是一个简单的替代，请出大shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo Wxgcg txgcg ui p ixgff, txgcg ui p epm. I gyhgwt mrl lig txg ixgff wrsspnd tr irfkg txui hcrvfgs, nre, hfgpig tcm liunz txg crt13 ra &quot;ixgff&quot; tr gntgc ngyt fgkgf. | tr &quot;pvwdgazxubqfsnrhocitlkeymj&quot; &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br></pre></td></tr></table></figure><p>得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Where there is a shell, there is a way. I expect you use the shell command to solve this problem, now, please try using the rot13 of shell to enter next level.</span><br></pre></td></tr></table></figure><p>这里我脑抽了一下，没看仔细以为是用shell命令，尝试各种<code>tr</code>以及<code>tr xxx xxx</code>都不行，后来出去跑了个步，回来再读一遍发现是用<code>rot13</code>转换一下<code>shell</code>这个字符串，wtf……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;shell&quot; | tr &quot;[A-Za-z]&quot; &quot;[N-ZA-Mn-za-m]&quot;</span><br></pre></td></tr></table></figure><p>顺利得到下一关地址：<code>furyy</code></p><h2 id="Puzzle-furyy-html"><a href="#Puzzle-furyy-html" class="headerlink" title="Puzzle furyy.html"></a>Puzzle furyy.html</h2><p>啊回文，差点一口老血死在这里……</p><p>刚开始思路有点歪，总以为是用<code>cat</code>再加上什么关键字得出一个单词，<code>cat</code>的规律其实已经注意到了，只是在纠结于怎么找到后续字母的规律……妈的走的有点远扯着蛋了。</p><p>后来又是认真读了下揭示语<code>The answer has been lost in the source</code>，咦……</p><p><code>Ctrl + Shift + I</code>打开Chrome的源代码查看工具（IE F12），看见一坨乱码躺在那里，就是它了，很明确，正则表达式。把乱码扔到一个文本文件里，然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt | grep -E &quot;([A-Z])(\d&#123;1&#125;)[a-z](\2)(\1)|(\d&#123;1&#125;)([A-Z])[a-z](\6)(\5)&quot; -o</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E1v1E</span><br><span class="line">4FaF4</span><br><span class="line">9XrX9</span><br><span class="line">O3i3O</span><br><span class="line">0MaM0</span><br><span class="line">4GbG4</span><br><span class="line">M5l5M</span><br><span class="line">0WeW0</span><br><span class="line">Y0s0Y</span><br></pre></td></tr></table></figure></p><p>使用所有中间的字母<code>variables</code>过关。</p><h2 id="Puzzle-variables-html"><a href="#Puzzle-variables-html" class="headerlink" title="Puzzle variables.html"></a>Puzzle variables.html</h2><p>点图片，进入<code>http://fun.coolshell.cn/n/2014</code>，显示了一个数字，这时候我脑残的用显示的数据作为answer，显然不行。<br>看到url里的<code>2014</code>了吗？用网页里的数字替换<code>2014</code>，然后又出现一个新数据，哦原来是这样……接下来就简单多了，上bash脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">baseUrl=<span class="string">"http://fun.coolshell.cn/n"</span></span><br><span class="line">result=<span class="string">"2014"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$result</span> -ne <span class="string">""</span> ]]; <span class="keyword">do</span></span><br><span class="line">    result=$(curl -s <span class="variable">$baseUrl</span>/<span class="variable">$result</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"=&gt; <span class="variable">$result</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>输出片断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 32722</span><br><span class="line">=&gt; 13310</span><br><span class="line">...</span><br><span class="line">=&gt; 16626</span><br><span class="line">=&gt; 20446</span><br><span class="line">=&gt; Cool! the next level is &quot;tree&quot;</span><br><span class="line">run.sh: line 6: [[: Cool! the next level is &quot;tree&quot;: syntax error in expression (error token is &quot;! the next level is &quot;tree&quot;&quot;)</span><br></pre></td></tr></table></figure></p><p>虽然脚本不完美，但是没办法，因为不知道最后会输出什么，这样看来搞出error也是不错的选择……使用<code>tree</code>过关。</p><h2 id="Puzzle-tree-html"><a href="#Puzzle-tree-html" class="headerlink" title="Puzzle tree.html"></a>Puzzle tree.html</h2><p>这道题很直白，纯考功底。先还原二叉树，然后找出最深路径，使用此关键字解密字符串<code>U2FsdGVkX1+gxunKbemS2193vhGGQ1Y8pc5gPegMAcg=</code>。</p><p>由于只有中序的后序的遍历序列，所以需要先从后序序列倒着取出根节点，然后再通过中序序列和后序序列来确立左子树和右子树，此过程递归完成。用js写了一段代码来还原二叉树：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inOrderSeq   = [<span class="string">"T"</span>, <span class="string">"b"</span>, <span class="string">"H"</span>, <span class="string">"V"</span>, <span class="string">"h"</span>, <span class="string">"3"</span>, <span class="string">"o"</span>, <span class="string">"g"</span>, <span class="string">"P"</span>, <span class="string">"W"</span>, <span class="string">"F"</span>, <span class="string">"L"</span>, <span class="string">"u"</span>, <span class="string">"A"</span>, <span class="string">"f"</span>, <span class="string">"G"</span>, <span class="string">"r"</span>, <span class="string">"m"</span>, <span class="string">"1"</span>, <span class="string">"x"</span>, <span class="string">"J"</span>, <span class="string">"7"</span>, <span class="string">"w"</span>, <span class="string">"e"</span>, <span class="string">"0"</span>, <span class="string">"i"</span>, <span class="string">"Q"</span>, <span class="string">"Y"</span>, <span class="string">"n"</span>, <span class="string">"Z"</span>, <span class="string">"8"</span>, <span class="string">"K"</span>, <span class="string">"v"</span>, <span class="string">"q"</span>, <span class="string">"k"</span>, <span class="string">"9"</span>, <span class="string">"y"</span>, <span class="string">"5"</span>, <span class="string">"C"</span>, <span class="string">"N"</span>, <span class="string">"B"</span>, <span class="string">"D"</span>, <span class="string">"2"</span>, <span class="string">"4"</span>, <span class="string">"U"</span>, <span class="string">"l"</span>, <span class="string">"c"</span>, <span class="string">"p"</span>, <span class="string">"I"</span>, <span class="string">"E"</span>, <span class="string">"M"</span>, <span class="string">"a"</span>, <span class="string">"j"</span>, <span class="string">"6"</span>, <span class="string">"S"</span>, <span class="string">"R"</span>, <span class="string">"O"</span>, <span class="string">"X"</span>, <span class="string">"s"</span>, <span class="string">"d"</span>, <span class="string">"z"</span>, <span class="string">"t"</span>];</span><br><span class="line"><span class="keyword">var</span> postOrderSeq = [<span class="string">"T"</span>, <span class="string">"V"</span>, <span class="string">"H"</span>, <span class="string">"o"</span>, <span class="string">"3"</span>, <span class="string">"h"</span>, <span class="string">"P"</span>, <span class="string">"g"</span>, <span class="string">"b"</span>, <span class="string">"F"</span>, <span class="string">"f"</span>, <span class="string">"A"</span>, <span class="string">"u"</span>, <span class="string">"m"</span>, <span class="string">"r"</span>, <span class="string">"7"</span>, <span class="string">"J"</span>, <span class="string">"x"</span>, <span class="string">"e"</span>, <span class="string">"w"</span>, <span class="string">"1"</span>, <span class="string">"Y"</span>, <span class="string">"Q"</span>, <span class="string">"i"</span>, <span class="string">"0"</span>, <span class="string">"Z"</span>, <span class="string">"n"</span>, <span class="string">"G"</span>, <span class="string">"L"</span>, <span class="string">"K"</span>, <span class="string">"y"</span>, <span class="string">"9"</span>, <span class="string">"k"</span>, <span class="string">"q"</span>, <span class="string">"v"</span>, <span class="string">"N"</span>, <span class="string">"D"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"5"</span>, <span class="string">"4"</span>, <span class="string">"c"</span>, <span class="string">"l"</span>, <span class="string">"U"</span>, <span class="string">"2"</span>, <span class="string">"8"</span>, <span class="string">"E"</span>, <span class="string">"I"</span>, <span class="string">"R"</span>, <span class="string">"S"</span>, <span class="string">"6"</span>, <span class="string">"j"</span>, <span class="string">"d"</span>, <span class="string">"s"</span>, <span class="string">"X"</span>, <span class="string">"O"</span>, <span class="string">"a"</span>, <span class="string">"M"</span>, <span class="string">"p"</span>, <span class="string">"W"</span>, <span class="string">"t"</span>, <span class="string">"z"</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseTree</span>(<span class="params">inOrder, postOrder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inOrder.length == <span class="number">0</span> || postOrder.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> root = postOrder[postOrder.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> inOrderIndex = inOrder.indexOf(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> leftTreeInOrder = inOrder.slice(<span class="number">0</span>, inOrderIndex);</span><br><span class="line">    <span class="keyword">var</span> leftTreePostOrder = postOrder.slice(<span class="number">0</span>, inOrderIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rightTreeInOrder = inOrder.slice(inOrderIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> rightTreePostOrder = postOrder.slice(inOrderIndex, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> node = &#123;</span><br><span class="line">        node: root,</span><br><span class="line">        left: parseTree(leftTreeInOrder, leftTreePostOrder),</span><br><span class="line">        right: parseTree(rightTreeInOrder, rightTreePostOrder)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tree = parseTree(inOrderSeq, postOrderSeq);</span><br></pre></td></tr></table></figure><p>OK，树还原出来了，还需要进行最深路径查找脑中瞬间闪出DFS，完全由于<code>深度优先</code>四个字。</p><p>，这个和深度优先搜索有点像但并不是搜索，通过递归的方式得到最长的路径。顺便提一嘴，BFS(广度优先)借助队列实现，DFS(深度优先)借助栈实现。好了，大学课程回忆完毕，上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findDeepestPath</span>(<span class="params">selfNode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (selfNode == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selfNode.left == <span class="literal">null</span> || selfNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [selfNode];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> leftPathSeq  = findDeepestPath(selfNode.left);</span><br><span class="line">    <span class="keyword">var</span> rightPathSeq = findDeepestPath(selfNode.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftPathSeq.length &gt; rightPathSeq.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> [selfNode].concat(leftPathSeq);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [selfNode].concat(rightPathSeq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果<code>zWp8LGn01wxJ7</code>，保留这个结果，因为下道题还用的到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo U2FsdGVkX1+gxunKbemS2193vhGGQ1Y8pc5gPegMAcg= | openssl enc -aes-128-cbc -a -d -pass pass:zWp8LGn01wxJ7</span><br></pre></td></tr></table></figure><p><code>nqueens</code>，进入下一题。</p><h2 id="Puzzle-nqueens-html"><a href="#Puzzle-nqueens-html" class="headerlink" title="Puzzle nqueens.html"></a>Puzzle nqueens.html</h2><p>这个倒是简单粗暴，考回溯算法，求解n后，然后暴力穷举出答案。写求n后解。本想用C#写个小程序，然后生成一个带有所有解txt文件，后来想想何必呢，还是继续用js吧，有node呢……</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="keyword">var</span> passwd = <span class="string">"zWp8LGn01wxJ7"</span>;</span><br><span class="line"><span class="keyword">var</span> target = <span class="string">"e48d316ed573d3273931e19f9ac9f9e6039a4242"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeResult</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resultStr = results.map(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v + <span class="number">1</span>;</span><br><span class="line">    &#125;).join(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hashString = passwd + resultStr + <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">var</span> sha1 = crypto.createHash(<span class="string">'sha1'</span>);</span><br><span class="line">    sha1.update(hashString)</span><br><span class="line">    <span class="keyword">var</span> digest = sha1.digest(<span class="string">'hex'</span>) ;</span><br><span class="line">    <span class="keyword">if</span>(digest == target) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(resultStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">conflict</span>(<span class="params">results, theLocation</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> row = <span class="number">0</span>; row &lt; results.length; row++) &#123;</span><br><span class="line">        <span class="keyword">var</span> queenLoction = results[row];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queenLoction == theLocation) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> rowDiff = results.length - row;</span><br><span class="line">        <span class="keyword">var</span> locationDiff = <span class="built_in">Math</span>.abs(theLocation - queenLoction);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rowDiff == locationDiff) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solveQueens</span>(<span class="params">size, results</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> results === <span class="string">"undefined"</span>) &#123; results = []; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> pos = <span class="number">0</span>; pos &lt; size; pos++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (conflict(results, pos)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pos is good.</span></span><br><span class="line">        <span class="keyword">var</span> newResults = results.slice(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (newResults.length == size - <span class="number">1</span>) &#123;</span><br><span class="line">            newResults.push(pos);</span><br><span class="line">            writeResult(newResults);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newResults.push(pos);</span><br><span class="line">            solveQueens(size, newResults);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>solveQueens(9)</code>并在node下运行即可。<br>最终的代码合并了计算sha1的部分，注意sha1字符串的最后一定要加<code>\n</code>，否则是算不出结果的。<br>顺利拿到下一关入口<code>953172864</code>。</p><h2 id="Puzzle-953172864-html"><a href="#Puzzle-953172864-html" class="headerlink" title="Puzzle 953172864.html"></a>Puzzle 953172864.html</h2><p>通过对第一列的观察，发现这是一个26进制/10进制的对应表。那么接下来的总是就是如果将<code>COOLSHELL / SHELL</code>转化为10进制并转换回26进制对应的字母的问题。</p><p>首先COOLSHELL对应的10进制数字分别为<code>3 15 15 12 19 8 5 12 12</code>，计算公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3*26^8+15*26^7+15*26^6+12*26^5+19*26^4+8*26^3+5*26^2+12*26^1+12*26^0</span><br></pre></td></tr></table></figure><p>使用Excel或Google计算结果为<code>751743486376</code>。同理，<code>SHELL</code>结果为<code>8826856</code>。<br>接下来将两个数相除的结果<code>85165</code>（这个数是带小数，但是因为除数和被除数都是整数所以结果也是整数）转回26进制，即<code>辗转相除法</code>，重复<code>模</code>26并取余数，得到<code>15 25 21 4</code>，对应的字母为<code>DUYO</code>，Bingo进入最后一题。</p><h2 id="Puzzle-DUYO-html"><a href="#Puzzle-DUYO-html" class="headerlink" title="Puzzle DUYO.html"></a>Puzzle DUYO.html</h2><p>最后一关是最轻松的一关，从图片得出线索是<a href="http://en.wikipedia.org/wiki/Pigpen_cipher" target="_blank" rel="noopener">猪圈密码</a>，然后通过一幅简单的图可轻松逆向出答案：<code>helloworld</code>.<br>ps: 通过图形的形状找图中该图形所对应的字母。</p><img src="/photos/2014-08/pigpen_cipher_key.png" width="800"><p>pps: 昨天答完的时候通过<a href="http://fun.coolshell.cn/top100.html" target="_blank" rel="noopener">Top100</a>看到是六十多名，今天再打开发现自己的成绩不见了很奇怪，耗子叔叔我没作弊啊……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.coolshell.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CoolShell&lt;/a&gt;博主&lt;a href=&quot;http://weibo.com/haoel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;陈皓&lt;/a&gt;做了一个在线的puzzle很有意思，链接在&lt;a href=&quot;http://fun.coolshell.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;，这里记录一下解题的一些步骤。&lt;/p&gt;
&lt;h2 id=&quot;Puzzle-0&quot;&gt;&lt;a href=&quot;#Puzzle-0&quot; class=&quot;headerlink&quot; title=&quot;Puzzle 0&quot;&gt;&lt;/a&gt;Puzzle 0&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;++++++++[&amp;gt;+&amp;gt;++&amp;gt;+++&amp;gt;++++&amp;gt;+++++&amp;gt;++++++&amp;gt;+++++++&amp;gt;++++++++&amp;gt;+++++++++&amp;gt;++++++++++&amp;gt;+++++++++++&amp;gt;++++++++++++&amp;gt;+++++++++++++&amp;gt;++++++++++++++&amp;gt;+++++++++++++++&amp;gt;++++++++++++++++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;-]&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;-.+&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;---.+++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;----.++++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;+++.---&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;-.+&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;---.+++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;---.+++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;--.++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;.&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;----.++++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;---.+++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;----.++++&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果之前没有听说过变态的编程语言，就让你见识一下。&lt;a href=&quot;http://www.muppetlabs.com/~breadbox/bf/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BrainFuck&lt;/a&gt;也称BF，是一门只有8个指令构成的图灵完备的语言。&lt;a href=&quot;http://www.coolshell.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CoolShell&lt;/a&gt;博主&lt;a href=&quot;http://weibo.com/haoel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;陈皓&lt;/a&gt;写过一篇简单的介绍在&lt;a href=&quot;http://coolshell.cn/articles/1142.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;br&gt;具体的指令解释不多说了，直接打长&lt;a href=&quot;http://esoteric.sange.fi/brainfuck/impl/interp/i.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;，把上面的指令粘进去，运行得到下一关的地址：&lt;code&gt;welcome.html&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Puzzle-welcome-html&quot;&gt;&lt;a href=&quot;#Puzzle-welcome-html&quot; class=&quot;headerlink&quot; title=&quot;Puzzle welcome.html&quot;&gt;&lt;/a&gt;Puzzle welcome.html&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;X * Y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2, 3, 6, 18, 108, ?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;What is the meaning of life, the universe and everything?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;生命、宇宙以及任何事情的终极答案&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="other" scheme="https://lurongkai.github.io/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>MacOS密码恢复</title>
    <link href="https://lurongkai.github.io/2013/02/22/how-to-recovery-macos-password-without-installation-cd/"/>
    <id>https://lurongkai.github.io/2013/02/22/how-to-recovery-macos-password-without-installation-cd/</id>
    <published>2013-02-22T07:22:00.000Z</published>
    <updated>2019-02-14T02:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>官方解决方法。找出电脑原配的系统盘，找不到就借一张或者刻录一张，重启电脑，启动的时候按C键，选好语言后进入安装的时候，点击“常用工具”，里面有一项是“重设密码”，这时就可以重新设定Mac OS系统的管理员密码了。</p><a id="more"></a><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>黑客解决方法。开机， 启动时按“cmd+S”。这时进入单一用户模式（Single user model）。Mac OS的单一用户模式有准入特权（Root access privilege）而不要求根密码（root password）。出现像DOS一样的提示符 #root&gt;。在#root&gt;下逐步输入以下命令，注意空格，大小写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//执行硬盘检测（只读）, 这一步可以省略</span><br><span class="line">/sbin/fsck -y</span><br><span class="line"></span><br><span class="line">//加载文件系统（读/写）</span><br><span class="line">/sbin/mount -uaw</span><br><span class="line"></span><br><span class="line">//删除初始化设置时的OSX生成的隐藏文件”.applesetupdone”</span><br><span class="line">rm /var/db/.AppleSetupDone</span><br><span class="line"></span><br><span class="line">//重启</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>重启开机后出现类似装机时的欢迎界面。别担心，东西没丢。就像第一次安装一样， 重新建立一个新的Mac OS管理员账号。然后在新的管理员下打开系统预制 － 账户，打开最下面的锁，询问密码时，用新的管理员密码登录。会看到至少两个账号，新的管理员的帐号和原来的帐号，点中原来的账号，选 密码 － 更改密码……（一切，从此改变） 你不必有原先的Mac OS密码就直接可以设新密码了。<br>点下面的登陆选项 (小房子)，选中 自动以右边的身份登陆， 同时在下拉菜单中选你原先的账号。<br>重启， 大功告成。至此破解Mac OS开机密码工作完成。<br>如果不喜欢多出一个账号， 删除它。 系统预制 － 账户，选新的管理员帐号， 点一下锁上面的减号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h2&gt;&lt;p&gt;官方解决方法。找出电脑原配的系统盘，找不到就借一张或者刻录一张，重启电脑，启动的时候按C键，选好语言后进入安装的时候，点击“常用工具”，里面有一项是“重设密码”，这时就可以重新设定Mac OS系统的管理员密码了。&lt;/p&gt;
    
    </summary>
    
      <category term="tips" scheme="https://lurongkai.github.io/categories/tips/"/>
    
    
  </entry>
  
  <entry>
    <title>初探Razor视图引擎</title>
    <link href="https://lurongkai.github.io/2010/07/21/razor-quick-glance/"/>
    <id>https://lurongkai.github.io/2010/07/21/razor-quick-glance/</id>
    <published>2010-07-21T09:18:00.000Z</published>
    <updated>2019-02-14T02:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间，ScottGu在博客上发表了一些有关WebMatrix的文章，其中提到了一个新的ASP.NET视图引擎——Razor。</p><p>Razor有着非常简单和干净的语法，但是不管怎么样，它毕竟只是一个表现层面的东西，其底层仍然使用ASP.NET，与平时的开发没有什么大的区别，唯一的区别在于：视图的简洁。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用Razor需要安装 Microsoft ASP.NET Web Pages，当然，官方的做法是：直接用Web Plamform安装WebMatrix，不过WebMatrix现在还处于Beta阶段，估计以后会增加更多支持Razor的功能。</p><p>安装完毕后打开WebMatrix，然后就可以通过Site Form Template来新建一个站点测试了。</p><p><img src="/photos/2010-07-21-razor-quick-glance/1.png" alt="WebMatrix"></p><p>默认生成的站点在“我的文档”My Web Sites下以站点名命名。</p><h2 id="初窥"><a href="#初窥" class="headerlink" title="初窥"></a>初窥</h2><p>Razor的语言简单之极，只需记住一个字符就可以：<code>@</code>。</p><p>在传统的ASP.NET视图引擎中，如果我们要进行一些数据绑定或者逻辑判断就会使用类似下面的做法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">var testStr1 = &quot;Hello&quot;;</span><br><span class="line">var testStr2 = &quot;lurongkai&quot;;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>我们先搞了两个变量，当然，这些变量可以从任意的地方获得，然后，我们将这两个变量绑定到页面中去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= testStr1 %&gt;,Your name:&lt;%= testStr2 %&gt;</span><br></pre></td></tr></table></figure><p>不知道您看的如何，总之我感觉是够乱的。</p><p>同样的东西，我们用Razor的语法来重写，会是怎么样的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@&#123;</span><br><span class="line">var testStr1 = &quot;Hello&quot;;</span><br><span class="line">var testStr2 = &quot;lurongkai&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@testStr1,Your name:@testStr2</span><br></pre></td></tr></table></figure><p>当然了，结果是一样的，不过在表现力上显然Razor更胜一筹，因为来回的<code>&lt;% %&gt;</code>看的人眼花，例如下面这个MVC中登陆部分的用户控件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (Request.IsAuthenticated) &#123; %&gt;</span><br><span class="line">欢迎您，&lt;b&gt;&lt;%: Page.User.Identity.Name %&gt;&lt;/b&gt;!</span><br><span class="line">[ &lt;%: Html.ActionLink(&quot;注销&quot;, &quot;LogOff&quot;, &quot;Account&quot;) %&gt; ]</span><br><span class="line">&lt;%  &#125; else &#123; %&gt;</span><br><span class="line">[ &lt;%: Html.ActionLink(&quot;登录&quot;, &quot;LogOn&quot;, &quot;Account&quot;) %&gt; ]</span><br><span class="line">&lt;%  &#125; %&gt;</span><br></pre></td></tr></table></figure><p>我唯一的感觉：晕！用Razor后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@&#123;</span><br><span class="line">if(WebSecurity.IsAuthenticated) &#123;</span><br><span class="line">@:欢迎您,&lt;b&gt;@WebSecurity.CurrentUserName&lt;/b&gt;!</span><br><span class="line">@Html.ActionLink(&quot;注销&quot;, &quot;LogOff&quot;, &quot;Account&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">@Html.ActionLink(&quot;登录&quot;, &quot;LogOn&quot;, &quot;Account&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是更加的人性一些呢？唯一需要说的就是@:，这是说它后面的内容是混合内容，即有纯文本又有服务器端代码。不过上面的代码我没有做过测试，这是改成了Razor的样式，所以大家谨慎参考。</p><h2 id="Helper"><a href="#Helper" class="headerlink" title="Helper"></a>Helper</h2><p>严格的讲这部分不能算语法层面上的特性，只能算是支持Razor的辅助类库。因为Razor实在过于简单了，说白了就一个@，只要会C#或才VB.NET就行，以前的知识全部能用，所以为了使内容不那么水，我将这部分也加了进来。完整的文档请到<a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=b7937c34-3b53-47b7-ae17-5a72fa700472&amp;displaylang=en" target="_blank" rel="noopener">这里</a>下载PDF文档，上面详细说明了Razor的细节（还有前面提到的Microsoft ASP.NET Web Pages安装包）。</p><h2 id="类似于传统ASP-NET的母版页、用户控件机制"><a href="#类似于传统ASP-NET的母版页、用户控件机制" class="headerlink" title="类似于传统ASP.NET的母版页、用户控件机制"></a>类似于传统ASP.NET的母版页、用户控件机制</h2><p>在呈现类似用户控件的内容时（说白了就是用户控件），可以使用<code>RenderPage</code>辅助类，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@RenderPage(&quot;/Shared/_Header.cshtml&quot;)</span><br><span class="line">@RenderPage(&quot;/Shared/_Footer.cshtml&quot;)</span><br></pre></td></tr></table></figure><p>而所谓的“用户控件”其实就是一个没有<code>&lt;html&gt;`</code><head><meta name="generator" content="Hexo 3.8.0"><code></code></head><body>`的裸页，将经常会使用的一部分逻辑或者内容分离出来以达到复用。</body></p><p>母版页可以提供统一的外观，按照原来的思路，一般会在母版页中插入<code>ContentPlaceHolder</code>控件来指明哪部分是要被使用页来替换内容的，在Razor中，它不叫<code>ContentPlaceHodler</code>，叫<code>RenderBody</code>。</p><p>不同的时，传统ASP.NET可以在母版页中插入多个<code>ContentPlaceHolder</code>，而<code>RenderBody</code>只能有一个。其实，类似<code>ContentPlaceHolder</code>，Razor中也提供<code>RenderSection</code>来实现。</p><p>先说<code>RenderBody</code>。当我们在母版页中的某个位置写了<code>@RenderBody()</code>后，接下来在使用母版页时，只需在页面的顶部写入：<code>@{ LayoutPage = &quot;MasterPageLocation&quot;; }</code>，这样，接下来的内容会自动填充到母版页<code>RenderBody()</code>对应的位置：</p><p>MasterPage:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RenderBody()</span><br></pre></td></tr></table></figure><p>Page:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@&#123;</span><br><span class="line">LayoutPage = &quot;/Shared/_MasterPage.cshtml&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>RenderSection</code>时需要指定Section片断的名字，<br> 我们可以在母版页中的相关位置上写上<code>@RenderSection(&quot;name&quot;)</code>，然后在使用母版页的页面中声明类似的Section，即：<code>@section header {/*HTML or other*/}</code>，具体如下：</p><p>MasterPage:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RenderSection(&quot;someSection&quot;)</span><br></pre></td></tr></table></figure><p>Page:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@sectionsomeSection &#123;</span><br><span class="line">&lt;div id=&quot;someSection&quot;&gt;</span><br><span class="line">someSection</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对Microsoft-SQL-Server-Compact-Edition数据库的辅助类"><a href="#对Microsoft-SQL-Server-Compact-Edition数据库的辅助类" class="headerlink" title="对Microsoft SQL Server Compact Edition数据库的辅助类"></a>对Microsoft SQL Server Compact Edition数据库的辅助类</h2><p>这个比较简单，就是通过<code>Database</code>类来操作数据。例如最常用的“查”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@&#123;</span><br><span class="line">var db = Database.OpenFile(&quot;database.sdf&quot;);</span><br><span class="line">var selectQueryString = &quot;SELECT * FROM Table1&quot;;</span><br><span class="line">var data = db.Query(selectQueryString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查出来的数据想怎么着就怎么着吧，管不着了……</p><p>很简单不是么？至于“增”，“改”，“删”都用<code>Database.Execute()</code>方法来完成。</p><h2 id="文件上传与Image处理"><a href="#文件上传与Image处理" class="headerlink" title="文件上传与Image处理"></a>文件上传与Image处理</h2><p>对于常用的文件上传功能，Razor做了封装，让我们使用更加的方便，只需简单的在页面上使用FileUpload类的相关方法即可，配合Razor的清爽语法，可读性非常高：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@FileUpload.GetHtml(</span><br><span class="line">initialNumberOfFiles: 1,</span><br><span class="line">allowMoreFilesToBeAdded: false,</span><br><span class="line">includeFromTag: true,</span><br><span class="line">uploadText: &quot;Upload&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>配合C#4.0的默认参数，一个文件传的功能就实现了（其实我觉得更像是一种使用控件）生成的HTML如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"file-upload-all-files"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"fileUpload"</span> <span class="attr">type</span>=<span class="string">"file"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"file-upload-buttons"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Upload"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于更加常见的Image，Razor也做了相应的封装：<code>WebImage</code>，常用的一些方法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WebImage.Resize(); <span class="comment">//改变图像大小</span></span><br><span class="line">WebImage.FlipXXXX(); <span class="comment">//图像旋转，XXXX对就旋转方向，例如Vertical垂直翻转，Horizontal水平翻转，Left,Right……</span></span><br><span class="line">WebImage.AddTextWatermark(); <span class="comment">//在图像上加入文字水印</span></span><br><span class="line">WebImage.AddImageWatermark(); <span class="comment">//在图像上加入图像水印</span></span><br></pre></td></tr></table></figure><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>对于常见的视频需求，Razor提供了简化手动配置视频标签的辅助类：<code>Video</code>。当下最为流行的网页视频播放无非3种：Flash，Windows Media<br> Player，Silverlight，至于HTML5的先天支持那是后话。Video充分利用C#4.0默认参数的威力，使得生成一个视频标签也是手到擒来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Video.Flash(</span><br><span class="line">path: &quot;testFlash.swf&quot;,</span><br><span class="line">width: &quot;400&quot;,</span><br><span class="line">height: &quot;600&quot;,</span><br><span class="line">play: true,</span><br><span class="line">loop: true,</span><br><span class="line">menu: false,</span><br><span class="line">bgColor: &quot;red&quot;,</span><br><span class="line">quality: &quot;medium&quot;,</span><br><span class="line">scale: &quot;exactfit&quot;,</span><br><span class="line">windowMode: &quot;transparent&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>至于Windows Media Player和Silverlight就不多说了，大同小异，有兴趣可以研究<code>Video.MediaPlayer()</code>，<code>Video.Silverlight()</code>。</p><h2 id="社交网络操作的简化"><a href="#社交网络操作的简化" class="headerlink" title="社交网络操作的简化"></a>社交网络操作的简化</h2><p>天朝上不了Twitter，但是世界处处却留下了Twitter的影子……作为时下最火的社交网站，我等暴民经常爬出去上推，扯远了……Razor提供了对诸如Twitter，Facebook，Gravator，ReCaptcha等一些社交网络经常提及的网站的简化，使得跨站点的资源调用更加方便，用Reflector看了一下<code>C:\Program Files\Microsoft ASP.NET\ASP.NET Web Pagesv1.0\Assemblies</code>下的<code>Microsoft.WebPages.Helpers.Toolkit.dll</code>，我们发现：</p><p><img src="/photos/2010-07-21-razor-quick-glance/2.png" alt="WebPage Helper"></p><p>其中提供了很多有用的封装，不过，可惜，可惜……</p><p>看一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Twitter.Profile(&quot;haacked&quot;)</span><br></pre></td></tr></table></figure><p>运行如下：</p><p><img src="/photos/2010-07-21-razor-quick-glance/2.png" alt="Haacked Twitter"></p><p>小梯子一搭，走您的…………</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Razor作为传统ASP.NET视图引擎外的新选择，使得Web开发中“视图”部分更加的清爽。在这里我并不是在鼓吹新技术、新特性，或者是抱着new features抚摸来抚摸去，大家仁者见仁智者见智吧，毕竟这个新东西实在很简单，只是一个新的视图引擎。</p><p>在下一版本的ASP.NET MVC中，Razor也会被加入可选的视图引擎之一，而我在下面给出的链接中已经<a href="http://www.cnblogs.com/chsword/archive/2010/07/10/razor_in_aspnet_mvc_2.html" target="_blank" rel="noopener">有人</a>将这一想法提前实现了，我想MVC的表现力再加上Razor的简洁定会使开发更加的愉快。</p><ol><li><p><a href="http://www.cnblogs.com/chsword/archive/2010/07/10/razor_in_aspnet_mvc_2.html" target="_blank" rel="noopener">为ASP.NET MVC 2.0添加Razor模板引擎 (on .NET4)</a> -<a href="http://www.cnblogs.com/chsword" target="_blank" rel="noopener">重典</a></p></li><li><p><a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=b7937c34-3b53-47b7-ae17-5a72fa700472&amp;displaylang=en" target="_blank" rel="noopener">ASP.NET Web Pages with Razor Syntax</a></p></li><li><p><a href="http://www.hanselman.com/blog/MicrosoftWebMatrixInContextAndDeployingYourFirstSite.aspx" target="_blank" rel="noopener">Microsoft  WebMatrix in Context and Deploying Your First Site</a> –<a href="http://www.hanselman.com/blog" target="_blank" rel="noopener">Scott Hanselman</a></p></li><li><p><a href="http://www.microsoft.com/web/webmatrix/" target="_blank" rel="noopener">WebMatrix</a></p></li><li><p><a href="http://weblogs.asp.net/scottgu/archive/2010/07/02/introducing-razor.aspx" target="_blank" rel="noopener">Introducing “Razor” – a new view engine for ASP.NET</a> –<a href="http://weblogs.asp.net/scottgu" target="_blank" rel="noopener">Scott Guthrie</a></p></li><li><p><a href="http://weblogs.asp.net/scottgu/archive/2010/07/06/introducing-webmatrix.aspx" target="_blank" rel="noopener">Introducing WebMatrix</a> –<a href="http://weblogs.asp.net/scottgu" target="_blank" rel="noopener">Scott Guthrie</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一段时间，ScottGu在博客上发表了一些有关WebMatrix的文章，其中提到了一个新的ASP.NET视图引擎——Razor。&lt;/p&gt;
&lt;p&gt;Razor有着非常简单和干净的语法，但是不管怎么样，它毕竟只是一个表现层面的东西，其底层仍然使用ASP.NET，与平时的开发没有什么大的区别，唯一的区别在于：视图的简洁。&lt;br&gt;
    
    </summary>
    
      <category term="asp-net" scheme="https://lurongkai.github.io/categories/asp-net/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET 4中的并行编程(下)</title>
    <link href="https://lurongkai.github.io/2010/04/20/dotnet-parallel-programming-2/"/>
    <id>https://lurongkai.github.io/2010/04/20/dotnet-parallel-programming-2/</id>
    <published>2010-04-20T00:12:00.000Z</published>
    <updated>2019-02-14T02:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>接<a href="/blog/2010/04/19/dotnet-parallel-programming-1/">上篇</a>。上一次主要讨论了在.NET 4中如何编写并行程序，这次继续上次的话题。<br><a id="more"></a></p><p>当我们有能力使用前面所介绍的一些结构来构建我们的应用程序时，一个需要考虑的场景是：假如一个并行过程已经开始，在它没有完成前想取消它的话应该怎么做呢？其实这个问题很现实，在多线程程序中也会遇到，当然了，多线程编程时我们可以用<code>Thread.Abort()</code>来终结它，那么在并行中该如何实现呢？老规矩，上Demo：</p><pre><code>CancellationTokenSource tokenSource = new CancellationTokenSource();CancellationToken token = tokenSource.Token;Task task1 = Task.Factory.StartNew(() =&gt; {    int i = 0;    while (!token.IsCancellationRequested) {        Thread.Sleep(500);        Console.WriteLine(&quot;Task1,{0}&quot;, i++);    }}, token);token.Register(() =&gt; {    Console.WriteLine(&quot;Task1 has been canceled&quot;);});Console.ReadLine();tokenSource.Cancel();</code></pre><p>首先实例化一个<code>CancellationTokenSource</code>对象，这个对象用于管理并行过程中的取消动作。当创建一个Task的时候，传入一个<code>CancellationToken</code>对象，而这个对象可以由<code>CancellationTokenSource.Token</code>属性来获得。当Task开开始执行时，如果想取消这个Task，那么就可以调用<code>CancellationTokenSource.Cancel()</code>来取消与之相关的Task了。</p><p>其实，我们可以将<code>CancellationTokenSource</code>理解为一个犯罪团伙的头目，然后这个头目管理着<code>CancellationToken</code>小兵，然后当一个Task创建时将这个小兵安插在其中(无间道？)，当头目发指令Cancel()时，小兵在Task内部上演无间道，嗯……</p><p>然而，出来混，迟早要还的。Task能不能无异常的执行完毕还是个未知数。在.NET 4中，现在可以用<code>AggregateException</code>来处理这些异常了，它提供一种异常汇总机制，可以对未知的异常进行处理，上一个Demo：</p><pre><code>Task task1 = Task.Factory.StartNew(() =&gt; {    Console.WriteLine(&quot;Task1 completed.&quot;);});Task task2 = Task.Factory.StartNew(() =&gt; {    Console.WriteLine(&quot;Task2 processing.&quot;);    throw new ArgumentOutOfRangeException(&quot;task2&quot;);});try {    Task.WaitAll(task1, task2);}catch (AggregateException aggex) {    aggex.Handle(ex =&gt; {        Console.WriteLine(ex);        return true;    });}</code></pre><p>可以将具体的异常处理写在<code>AggregateException.Handle</code>方法内，Handle方法传入一个Func委托，用于处理具体的异常，例如上面，我们只是在Task内简单的抛出了一个<code>ArgumentOutOfRangeException</code>异常，当调用<code>Task.WaitAll</code>时异常被捕获，然后在aggex.Handle中具体处理。当然，可以将上述中传入的ex进行is判断来确定具体的异常，例如：<code>if (ex is ArgumentOutOfRangeException) {…}</code>。</p><p>聊完异常处理，接着聊访问安全。</p><p>访问安全的问题其实很显然，在多线程环境下要注意的问题无疑都是要在并行环境下考虑。这里，其实可以用线程安全来讲，因为不管是多线程还是并行，CPU调度的最小单位都是线程，所以，以下都用线程安全来说明。</p><p>要求线程安全，首先想到的肯定就是上锁。过去的一些手段就不说了，我们着重说一下.NET 4中的SpinLock互斥锁。</p><pre><code>SpinLock spinLock = new SpinLock();bool locked = false;try {    spinLock.Enter(ref locked);    // Do something.}finally {    if (locked) {        spinLock.Exit();    }}</code></pre><p>其实不用解释也看的懂了。线程安全操作多用于对资源的访问控制上，例如<code>IO</code>，<code>Stream</code>等，而我们往往需要面对的其实是内存中的数据，例如集合，例如队列等。.NET 4为了并行，引入了一个新的命名空间：<code>System.Collections.Concurrent</code>;在这个空间之下有很多经过处理的基础结构，例如<code>ConcurrentDictionary</code>、<code>ConcurrentQueue</code>等，它们都是线程安全的，或者说是并行安全的，而且在使用方法上和见的<code>System.Collections.Generic</code>下的结构无异。接下来演示一个<code>BlockingCollection</code>结构的使用Demo：</p><pre><code>BlockingCollection&lt;string&gt; blockCollection = new BlockingCollection&lt;string&gt;();ThreadPool.QueueUserWorkItem(o =&gt; {    for (int i = 0; i &lt; 200; i++) {        blockCollection.Add(&quot;String&quot; + i);        Thread.Sleep(1000);    }});ThreadPool.QueueUserWorkItem(o =&gt; {    foreach (var i in blockCollection.GetConsumingEnumerable()) {        Console.WriteLine(&quot;Read:{0}&quot;, i);    }});</code></pre><p>我们用的是线程池的做法，当然，在并行编程中的做法也是一样的(有做法么？好像没有耶……)。可以看的出，Concurrent相关的结构可以大大简化并行编程中需要考虑的线程安全问题。</p><p>最后要讨论的是.NET 4中很NB的一个东西：PLINQ。并行并行，就是要多CPU协作同时执行，其实有理由相信多CPU可以提高查询的效率(没有说一定是DB查询，不涉及IO性能)，尤其是在内存中集合的查询，PLINQ就是Parallel化的LINQ，使我们的查询可以在多个CPU上同时执行，藉此提高查询效率。</p><p>要想在一个自定义的集合中实现LINQ功能，常用的做法就是实现IEnumerable<t>，这样就可以使用LINQ的查询语法来实现类似SQL的“漂漂”代码，在.NET 4中要想实现一个能并行查询(PLINQ)的自定义集合，可以实现IParallelEnumerable<t>，IParallelEnumerable<t>继承于IEnumerable<t>，实现起来其实也不困难。</t></t></t></t></p><p>怎样去用PLINQ呢？上一个Demo看看：</p><pre><code>var dataSet = new string[] { &quot;data1&quot;, &quot;data2&quot;, &quot;data3&quot;, &quot;data4&quot; };var results = from d in dataSet.AsParallel&lt;string&gt;()                let result = d.ToUpper()                select result;foreach (var r in results) {    Console.WriteLine(r);}</code></pre><p>只是简单的.AsParallel即可，很好很强大。我们可以使用.AsOrdered来实现在排序前进行缓存。</p><pre><code>var queryByOrder = from d in dataSet.AsParallel&lt;string&gt;().AsOrdered&lt;string&gt;()                    orderby d descending                    let result = d.ToUpper()                    select result;</code></pre><p>这次我们换个方面来将queryByOrder输出：</p><pre><code>queryByOrder.ForAll&lt;string&gt;(q =&gt; {    Console.WriteLine(q);});</code></pre><p>看来扩展方法这块糖的确很好吃……</p><p>其实在普通的开发中，.AsParallel一下就OK了，我们来猜一下上面代码的结果是怎么样的？答案是不一定有顺序(即使在第二个示例中排序过)，详情请参见<a href="/blog/2010/04/19/dotnet-parallel-programming-1/">上篇</a>中的解释。</p><p>通过两篇文章，我们讨论了一些.NET 4中并于并行开发的基础，在实际的开发中，是否选择并行仍然是一个有待商榷的问题，我们往往关心的是，并行究竟能为开发带来多大的复杂度，能为效率带来多大的提升，下一次我将对并行的效率进行讨论，欢迎大家一起加入。</p><p>相关链接： <a href="/blog/2010/04/19/dotnet-parallel-programming-1/">.NET 4中的并行编程(上)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接&lt;a href=&quot;/blog/2010/04/19/dotnet-parallel-programming-1/&quot;&gt;上篇&lt;/a&gt;。上一次主要讨论了在.NET 4中如何编写并行程序，这次继续上次的话题。&lt;br&gt;
    
    </summary>
    
      <category term="dot-net" scheme="https://lurongkai.github.io/categories/dot-net/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET 4中的并行编程(上)</title>
    <link href="https://lurongkai.github.io/2010/04/19/dotnet-parallel-programming-1/"/>
    <id>https://lurongkai.github.io/2010/04/19/dotnet-parallel-programming-1/</id>
    <published>2010-04-18T22:46:00.000Z</published>
    <updated>2019-02-14T02:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>并行是.NET 4中新加入的特性，为了使程序在多核心多CPU环境运行的更好、更快、更强大。</p><p><a href="/blog/2010/04/11/dotnet-4-changes-on-clr-and-bcl-1/">前面</a>已经说过了，并发和并行是不一样的，并发最多可以算做是多线程，而所谓并行是将任务分散到不同的CPU上同时执行。尤其值得我们关注的是，在Web环境下的先天并行特性，使得并行编程成为解决性能瓶颈的又一武器。<br><a id="more"></a></p><p>.NET 4中的并行编程主要是Parallel和Task，微软强势构建了TPL(Task Parallel Library)，使开发过程变得简洁。</p><p>接下来，先看一个简单的Demo：</p><pre><code>using System.Threading.Tasks;Parallel.Invoke(    () =&gt; {        Thread.Sleep(1000);        Console.WriteLine(&quot;1&quot;);    },    () =&gt; {        Thread.Sleep(1000);        Console.WriteLine(&quot;2&quot;);    },    () =&gt; {        Thread.Sleep(1000);        Console.WriteLine(&quot;3&quot;);    });</code></pre><p><code>Parallel.Invoke()</code>方法可以接收一个Action委托的params数组。我们来猜一下上段代码的执行结果是什么？123的顺序还是132？213？231？这个，不一定，得看人品……呵呵，开个玩笑，并行执行时，将上面三个Lambda表达式传递的方法分别看做一个“任务”，将其分配至空闲CPU，然后执行，由于CPU的情况是不一定的，所以执行完毕的顺序也就有了差异。</p><p>由于很多需要并行执行的任务都有一定的相似性，所以一般情况下我们可以用一种类似for循环的方式对这些任务进行并行的处理，例如在.NET 4中可以这么做：</p><pre><code>Parallel.For(0, 10, i =&gt; {    Console.WriteLine(i);});</code></pre><p>但样做有时却不方便，例如我们要处理一个集合中的数据，既然集合实现了IEnumerable接口，为什么还要用索引来遍历呢？</p><p>其实我们是可以方便并行的处理一个数据集合的，以在多CPU环境下获得更高的性能。具体的，我们可以这么做：</p><pre><code>var dataList = new string[] { &quot;data1&quot;, &quot;data2&quot;, &quot;data3&quot; };//IEnumerable interface.Parallel.ForEach(dataList, taskOptions, data =&gt; {    Console.WriteLine(data + &quot; processing&quot;);});</code></pre><p><code>taskOptions</code>是一个可选的参数，用于指定并行任务执行的方式，可以这样设置它：</p><pre><code>ParallelOptions taskOptions = new ParallelOptions();taskOptions.MaxDegreeOfParallelism = 2;</code></pre><p>这里只是简单的设置了一下并行执行的程序，可以理解为使用的CPU核心数，-1表示由CLR来决定，因为我的本本是两核的，那就指定为2吧……</p><p>当然了，processing的顺序也不一定的顺序了，原因看上面。</p><p>Parallel为我们提供了一种最原始的控制并行任务的过程，但这在实际的使用中是远不够的，我们需要更加细腻的控制并行执行中的阶段和并发冲突情况(并行中当然也有冲突了)等，.NET 4为我们带来的Task很好的解决了这个需求。</p><p>先上一个简单的例子：</p><pre><code>Task task1 = new Task(() =&gt; {    Console.WriteLine(&quot;Task1&quot;);});task1.Start();Task task2 = Task.Factory.StartNew(() =&gt; {    Console.WriteLine(&quot;Task2&quot;);});</code></pre><p>这里使用了两种方式来启动一个Task，第一种是普通的做法，先实例化一个Task，再调用Start()方法来启动一个任务。第二种是使用Task的工厂方法来初始化并启动。孰好孰坏就全看个人喜好了。</p><p>当我们的Task执行完毕后会产生一个新结果时，可以在初始化任务时指定返回的类型，然后访问.Result属性来获取任务结束后的值，例如下面：</p><pre><code>Task task1 = Task.Factory.StartNew(() =&gt;{    Thread.Sleep(1000);    return &quot;string1&quot;;});Task task2 = Task.Factory.StartNew(() =&gt;{    Thread.Sleep(1000);    return &quot;string2&quot;;});Task task3 = Task.Factory.StartNew(() =&gt;{    Thread.Sleep(1000);    return &quot;string3&quot;;});Console.WriteLine(task1.Result);Console.WriteLine(task2.Result);Console.WriteLine(task3.Result);</code></pre><p>需要说明的是，当访问Task.Result属性时，如果对应的Task还没有结束，那么在访问线程将会阻塞，直到所对应的Task执行完毕才会继续。</p><p>这种阻塞当然是安全的，然而很多时候，我们需要确保某些任务结束后才可以执行后续的代码，这时候会怎么做呢？</p><pre><code>Task task1 = new Task(() =&gt; { Console.WriteLine(&quot;Task1&quot;); });Task task2 = new Task(() =&gt; { Console.WriteLine(&quot;Task2&quot;); });Task task3 = new Task(() =&gt; { Console.WriteLine(&quot;Task3&quot;); });task3.Start();Task.WaitAll(task3);//params TaskConsole.WriteLine(&quot;Task3 complete&quot;);Task.WaitAny(task3, task2);//task2并没有运行Console.WriteLine(&quot;task2和task3中必然完成了一个&quot;);task1.Start();</code></pre><p>Task.WaitAll()方法会阻塞线程直到指定的Task全部完成后才会向下运行，这相当于设了一道关卡，确保指定任务全部结束。</p><p>而Task.WaitAny()方法会检测指定的全部Task，只要其中的任何一个Task完成，那么就可以继续。</p><p>其实在多线程中也有类似的做法，并不是并行的专利，例如这样：</p><pre><code>CountdownEvent cde = new CountdownEvent(3);ThreadPool.QueueUserWorkItem(_ =&gt;{    Thread.Sleep(2000);    Console.WriteLine(&quot;Work item 1&quot;);    cde.Signal();});ThreadPool.QueueUserWorkItem(_ =&gt;{    Thread.Sleep(4000);    Console.WriteLine(&quot;Work item 2&quot;);    cde.Signal();});ThreadPool.QueueUserWorkItem(_ =&gt;{    Thread.Sleep(6000);    Console.WriteLine(&quot;Work item 3&quot;);    cde.Signal();});cde.Wait();Console.WriteLine(&quot;All complete.&quot;);</code></pre><p>只不过Task的方法更加的直接而已。</p><p>然而任务间有时也有着依赖关系，例如Task1依赖于Task2的执行，Task2又依赖于Task3的执行，这样，完全可以用普通的单线程来替代了，为什么还要使用并行呢？其实就拿上面的例子来说，Task3在一个CPU1上执行完毕了Task2在CPU2上立即启动，这时CPU1完全可以用来做别的并行任务了，不是么？这就是任务链的作用，我们可以用一个Demo来说明：</p><pre><code>Task task1 = new Task(() =&gt;{    Console.WriteLine(&quot;Task1&quot;);    return 1;});Task task2 = task1.ContinueWith(parent =&gt; {    Console.WriteLine(&quot;Task2&quot;);    Console.WriteLine(&quot;Task1&apos;s result:{0}&quot;, parent.Result);    return &quot;Task2&quot;;});Task task3 = task2.ContinueWith(parent =&gt; {    Console.WriteLine(&quot;Task3&quot;);    Console.WriteLine(&quot;Task2&apos;s result:{0}&quot;, parent.Result);    return &quot;Task3&quot;;});task1.Start();</code></pre><p>当调用task1.Start()方法后task1启动，执行完毕后task2启动，再然后task3启动，呈一条链状执行，可以写在一条语句：</p><pre><code>Task task = Task.Factory.StartNew(() =&gt; {    Console.WriteLine(&quot;Task1&quot;);    return 1;}).ContinueWith(parent =&gt; {    Console.WriteLine(&quot;Task2&quot;);    Console.WriteLine(&quot;Task1&apos;s result:{0}&quot;, parent.Result);    return &quot;Task2&quot;;}).ContinueWith(parent =&gt; {    Console.WriteLine(&quot;Task3&quot;);    Console.WriteLine(&quot;Task2&apos;s result:{0}&quot;, parent.Result);    return &quot;Task3&quot;;});</code></pre><p>显然，这些只能在任务的外部进行并行执行阶段的控制，如果想要更加细度的控制并行的执行，例如在并行过程的内部实现阶段的控制，那么就需要引入Barrier结构了。Barrier结构可以为并行过程内部提供“阶段关卡”，让并行也分阶段来协作，一个简单的例子是这样：</p><pre><code>Barrier barrierDemo = new Barrier(3, (barrier) =&gt; {    Console.WriteLine(&quot;Phase {0} has been completed.&quot;, barrier.CurrentPhaseNumber + 1);});Task task1 = Task.Factory.StartNew(() =&gt; {    Console.WriteLine(&quot;Task1,phase 1.&quot;);    barrierDemo.SignalAndWait();// phase 1    Console.WriteLine(&quot;Task1,phase 2.&quot;);    barrierDemo.SignalAndWait();// phase 2    Console.WriteLine(&quot;Task1,phase 3.&quot;);    barrierDemo.SignalAndWait();// phase 3});Task task2 = Task.Factory.StartNew(() =&gt; {    Console.WriteLine(&quot;Task2,phase 1.&quot;);    barrierDemo.SignalAndWait();// phase 1    Console.WriteLine(&quot;Task2,phase 2.&quot;);    barrierDemo.SignalAndWait();// phase 2    Console.WriteLine(&quot;Task2,phase 3.&quot;);    barrierDemo.SignalAndWait();// phase 3});Task task3 = Task.Factory.StartNew(() =&gt; {    Console.WriteLine(&quot;Task3,phase 1.&quot;);    barrierDemo.SignalAndWait();// phase 1    Console.WriteLine(&quot;Task3,phase 2.&quot;);    barrierDemo.SignalAndWait();// phase 2    Console.WriteLine(&quot;Task3,phase 3.&quot;);    barrierDemo.SignalAndWait();// phase 3});Task.WaitAll(task1, task2, task3);Console.WriteLine(&quot;All complete.&quot;);</code></pre><p>三个Task是并行执行的当然没有问题，因而顺序也就不一定，原因再请看上面。我们需要解决的问题是怎样把Task分为3个阶段，让所有的Task在对应的阶段能统一一下步子，然后再往下走，Barrier就是为此而生，先在主线线程内声明一个Barrier实例并指定需要控制的阶段数量，然后在Task内分别来使用SignalAndWait()来设阶段关卡，可以预想执行的结果是：</p><pre><code>Task2,phase 1.    Task1,phase 1.    Task3,phase 1.Phase 1 has been completed. Task1,phase 2. Task2,phase 2. Task3,phase 2. Phase 2 has been completed. Task3,phase 3. Task1,phase 3. Task2,phase 3.  Phase 3 has been completed.All complete.</code></pre><p>当然，每个阶段的完成顺序可以是不一样的。</p><p>下一次将要讨论的是并行编程中的关于异常处理、访问安全问题以及PLINQ，当然了，这些都只是一些开头，当真正要在工程中使用并行，需要考虑的问题还有很多，毕竟，不管是多线程还是并行都提升了代码的复杂度，我们必须要衡量在大的环境下这样做是否值得……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并行是.NET 4中新加入的特性，为了使程序在多核心多CPU环境运行的更好、更快、更强大。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/2010/04/11/dotnet-4-changes-on-clr-and-bcl-1/&quot;&gt;前面&lt;/a&gt;已经说过了，并发和并行是不一样的，并发最多可以算做是多线程，而所谓并行是将任务分散到不同的CPU上同时执行。尤其值得我们关注的是，在Web环境下的先天并行特性，使得并行编程成为解决性能瓶颈的又一武器。&lt;br&gt;
    
    </summary>
    
      <category term="dot-net" scheme="https://lurongkai.github.io/categories/dot-net/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET 4在CLR和BCL的一些变化(3)</title>
    <link href="https://lurongkai.github.io/2010/04/12/dotnet-4-changes-on-clr-and-bcl-3/"/>
    <id>https://lurongkai.github.io/2010/04/12/dotnet-4-changes-on-clr-and-bcl-3/</id>
    <published>2010-04-12T14:25:00.000Z</published>
    <updated>2019-02-14T02:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>VS2010正式版发布了，从<a href="http://www.cnblogs.com/gnielee/archive/2010/04/12/dot-net-framework-4-namespace.html" target="_blank" rel="noopener">海报</a>中我们可以看到.NET 4在BCL上的改进还是很大的，这一次主要讨论比较Core的变化。<br><a id="more"></a></p><p>就照海报的顺序说吧。</p><h2 id="System-Collections-Generic"><a href="#System-Collections-Generic" class="headerlink" title="System.Collections.Generic"></a>System.Collections.Generic</h2><p>.NET 4中新加入了名为<code>SortedSet&lt;T&gt;</code>的结构，这是一个很有用的结构，它在内部维护一个集合，使用Add()向SortedSet中添加已存在的项时会被忽略，并且返回false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortedSet sortedSetDemo = new SortedSet &#123; 8, 2, 1, 5, 10, 5, 10, 8 &#125;;</span><br></pre></td></tr></table></figure><p>SortedSet<t>和HashSet<t>均实现了新引入的ISet<t>接口，其实可以看下ISet<t>的签名：</t></t></t></t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface ISet&lt;T&gt; : ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IEnumerable</span><br></pre></td></tr></table></figure><p>于是可以知道SortedSet<t>是一个集合，同时可遍历，可……</t></p><h2 id="System-IO-MemoryMappedFiles"><a href="#System-IO-MemoryMappedFiles" class="headerlink" title="System.IO.MemoryMappedFiles"></a>System.IO.MemoryMappedFiles</h2><p>这个结构的作用在于将一个文映射到内存中，以达到快速“IO”的目的。其实<code>MemoryMappedFiles</code>的真正作用是用作进程间或应用程序间的通信，在内存映射文件中存储相关的信息然后传递。下面这个例子简单演示了如何使用MemoryMappedFiles：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">using System.IO;</span><br><span class="line">using System.IO.MemoryMappedFiles;</span><br><span class="line"></span><br><span class="line">using (MemoryMappedFile MemoryMappedFile = MemoryMappedFile.CreateNew(&quot;MemoryMappedFileDemo&quot;, 100))&#123;</span><br><span class="line">MemoryMappedViewStream stream = MemoryMappedFile.CreateViewStream();</span><br><span class="line">using (BinaryWriter writer = new BinaryWriter(stream))&#123;</span><br><span class="line">writer.Write(&quot;hello cnblogs&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就将一个名为<code>MemoryMappedFileDemo</code>的“文件”写入到了内存，下面的代码说明怎样将它读出来，要注意的是，两段代码不要写在一个应用程序内，否则会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">using (MemoryMappedFile MemoryMappedFile = MemoryMappedFile.OpenExisting(&quot;MemoryMappedFileDemo&quot;))</span><br><span class="line">&#123;</span><br><span class="line">using (MemoryMappedViewStream Stream = MemoryMappedFile.CreateViewStream())</span><br><span class="line">&#123;</span><br><span class="line">BinaryReader reader = new BinaryReader(Stream);</span><br><span class="line">Console.WriteLine(reader.ReadString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难能可贵的是，VS2010对<code>MemoryMappedFileDemo</code>提供Debug支持。</p><p><img src="/photos/2010-04-11-dotnet-4-changes-on-clr-and-bcl-3/1.jpg" alt="Debug Support"></p><h2 id="System-Numerics"><a href="#System-Numerics" class="headerlink" title="System.Numerics"></a>System.Numerics</h2><p>.NET 4新加入的命名空间，里面包含了两个数据结构：BigInteger和Complex。BigInteger提供了比整型长度更长的数值表示范围，默认值为0，且为不可变类型，如果一些比较特殊的场景整型满足不了需求，可以考虑使用BigInteger，相关的辅助方法也会加快的开发效率。</p><p>需要注意的是，很多情况下需要手动的引用System.Numberics所在的程序集：</p><p><img src="/photos/2010-04-11-dotnet-4-changes-on-clr-and-bcl-3/2.png" alt="Debug Support"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bigIntegerDemo = new BigInteger(9999999999999999);</span><br><span class="line">if (bigIntegerDemo.IsZero) &#123;</span><br><span class="line">Console.WriteLine(&quot;Equal 0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(bigIntegerDemo);</span><br></pre></td></tr></table></figure><p>而Complex则是我们常说的复数类。就像平学数学中的定义一样，一个复数由一个实部与虚部构成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Complex n1 = new Complex(8, 2);</span><br><span class="line">Complex n2 = new Complex(8, 2);</span><br><span class="line">Complex n3 = n1 + n2;</span><br></pre></td></tr></table></figure><h2 id="System-Tuple结构"><a href="#System-Tuple结构" class="headerlink" title="System.Tuple结构"></a>System.Tuple结构</h2><p><code>Tuple</code>(元组)是一个大小固定的集合主要被设计为与F#，IronPython等互操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var primes = Tuple.Create(2, 3, 5, 7, 11, 13, 17, 19);</span><br></pre></td></tr></table></figure><p>这是一个MSDN官方的例子，完整的元组使用应该是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tuple&lt;int, int, int, int, int, int, int, Tuple&lt;int&gt;&gt; primes = Tuple.Create(2, 3, 5, 7, 11, 13, 17, 19);</span><br></pre></td></tr></table></figure><p>因为一个元组最大为6，所以想扩展元组必须在最后一个位置上再加一个元组。有了var关键字，便使整个过程更简单了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var multiTuple = new Tuple&lt;int, int, int, int, int, int, int,Tuple&lt;int,int,int&gt;&gt;(</span><br><span class="line">2, 4, 6, 8, 10, 12, 14,</span><br><span class="line">new Tuple&lt;int,int,int&gt;(3,6,9));</span><br></pre></td></tr></table></figure><p>访问也简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">primes.Item1;//2</span><br><span class="line">primes.Item2;//3</span><br><span class="line">//...</span><br><span class="line">multiTuple.Rest.Item1;//3</span><br></pre></td></tr></table></figure><h2 id="System-Runtiime-InteropServices"><a href="#System-Runtiime-InteropServices" class="headerlink" title="System.Runtiime.InteropServices"></a>System.Runtiime.InteropServices</h2><p>新提供的<code>TypeIdentifierAttribute</code>特性，可以为一些在类型库中没有GUID的类型提供等价类型支持，只需在类型上加<code>[TypeIdentifier]</code>即可。</p><p>关于.NET 4中Parallel的部分在这个系列的第一篇有部分介绍，我打算将详细的部分例如PLINQ，放到后面的系列来具体讨论。</p><h2 id="已有类的改进"><a href="#已有类的改进" class="headerlink" title="已有类的改进"></a>已有类的改进</h2><ul><li><p><code>Stopwatch</code>: Stopwathc中新加入了<code>Restart()</code>方法，方便我们重置计时器。</p></li><li><p><code>Environment</code>： 加入了关于CPU和OS是否为64位的属性：<code>Is64BitProcess</code>，<code>Is64BitOperatingSystem</code>，并且为了便于使用系统文件夹，新增了一个名为<code>SpecialFolder</code>的枚举类型，<code>Environment.SpecialFolder.Desktop</code>则表示桌面，<code>Environment.SpecialFolder.CommonMusic</code>表示公用音乐文件夹。</p></li><li><p><code>Stream</code>：加入<code>CopyTo</code>方法，可以快捷的从一个流拷贝数据到另一个流。</p></li><li><p><code>Enum</code>：过去判断一个<code>[Flag]</code>枚举是否包含某个标志时，通常会使用&amp;运算判断是否为空，.NET 4为Enum提供了一个更为简便的方法：<code>HasFlag()</code>，例如：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Flags]</span><br><span class="line">public enum DataOptions</span><br><span class="line">&#123;</span><br><span class="line">Data1 = 1,</span><br><span class="line">Data2 = 2,</span><br><span class="line">Data3 = 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以使用<code>HasFlag()</code>来判断是否存在某个标志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataOptions data = DataOptions.Data1 | DataOptions.Data2 | DataOptions.Data3;</span><br><span class="line">Console.WriteLine(&quot;Have Data2? &#123;0&#125;&quot;, data.HasFlag(DataOptions.Data2));</span><br></pre></td></tr></table></figure><ul><li><p><code>Guid</code>，<code>Version</code>，<code>Enum</code>: 现在均增加了对应的<code>TryParse</code>方法。</p></li><li><p><code>String</code>: 新增支持IEnumerable的<code>Concat()</code>，<code>Join()</code>方法，使用LINQ更加的方便，<code>IsNullOrWhiteSpace()</code>方法的加入也使对字符串的判断上更加的严谨。</p></li><li><p><code>File</code>：新增支持IEnumerable的<code>ReadLines()</code>方法，<code>WriteAllLines()</code>，<code>AppendAllLines()</code>也做为配合而出现，接受IEnumerable参数。有理由相信Directory是否也有相关的变化，答案是有，具体参见MSDN。</p></li></ul><p>.NET 4的变化很多，一些新特性有待大家一起发掘，更多的内容还是需要在实际的实用中慢慢的体会。下一次如果机会恰当，将研究一些.NET 4特定的技术例如PLINQ等等，不完全局限于CLR和BCL，因为这个话题真正写起来了才发现很空泛，很寂寞……</p><p>相关链接：</p><ol><li><p><a href="/blog/2010/04/12/dotnet-4-changes-on-clr-and-bcl-1/">.NET 4在CLR和BCL的一些变化(1)</a></p></li><li><p><a href="/blog/2010/04/12/dotnet-4-changes-on-clr-and-bcl-2/">.NET 4在CLR和BCL的一些变化(2)</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VS2010正式版发布了，从&lt;a href=&quot;http://www.cnblogs.com/gnielee/archive/2010/04/12/dot-net-framework-4-namespace.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;海报&lt;/a&gt;中我们可以看到.NET 4在BCL上的改进还是很大的，这一次主要讨论比较Core的变化。&lt;br&gt;
    
    </summary>
    
      <category term="dot-net" scheme="https://lurongkai.github.io/categories/dot-net/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET 4在CLR和BCL的一些变化(2)</title>
    <link href="https://lurongkai.github.io/2010/04/12/dotnet-4-changes-on-clr-and-bcl-2/"/>
    <id>https://lurongkai.github.io/2010/04/12/dotnet-4-changes-on-clr-and-bcl-2/</id>
    <published>2010-04-12T04:41:00.000Z</published>
    <updated>2019-02-14T02:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/blog/2010/04/12/dotnet-4-changes-on-clr-and-bcl-1/">上一篇</a>讨论了.NET 4中关于垃圾回收、线程、并行、全球化等方面的内容，这次我们接着上次往下说。<br><a id="more"></a></p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>安全是一个很大的概念。在.NET 4中，主要的改进在于对CAS操作的简化。</p><p>先前的版本中，如果想要控制资源的安全访问，那么就会使用CAS策略，但是操作往往很复杂，4改进了操作，主要体现在这些方面：</p><p>改进的透明模型。透明模型将代码分为了安全、不安全、或许安全，当然，这取决于程序宿主机的设置。于是.NET为不同应用程序设置了不同的安全类型，就像我们平常知道的那样，ASP.NET和SQL, Silverlight可以运行代码的安全级别都不一样，这都是CAS策略所管理的。先前的透明模型主要和一些代码检查工具如FxCop等协同来审核代码。</p><p>透明模型有三种类型：透明代码、关键代码、安全关键代码，分别代表的代码的不同安全等级。当.NET 4的应用程序以部分信任运行时，CLR将确保透明代码可以调用其它的透明和安全的代码。并且，在程序调用安全的同时，CLR要求一定的权限才能执行，这个权限是通过程检查程序宿主机的设置来确认的。</p><p>与过去不同的是，.NET 4将通过Windows Explorer和网络共享运行的代码定义为完全信任，换句话讲，它们的等级是相同的，而先前的版本中，两者的运行等级并不相同。而运行在主机的应用程序，不管是ASP.NET或是Silverlight，将使用主机授权，也就是说我们只需要考虑授权这些应用程序以不同的权限。部分信任的应用程序已经对其有了必要的限制，对于非本机的代码，微软建议我们使用SRPs(Software Restriction Policies软件限制策略)来应用安全策略，这个东东可以在托管代码和非托管代码上应用，具体的大家查查MSDN。</p><p>新的版本中，已经删除了在CLR中有关Deny, RequestMinimum, RequestOptional,RequestRefuse的权限要求，所以说如果要迁移程序到新版本，一定要删除相关的代码才行，不然会报错。</p><p>缝缝补补，.NET 4终于可以不用像以前那样繁琐的来控制应用程序的权限相关的问题了。另外值得注意的是，.NET 4中有了一个<code>PartialTrustVisibilityLevel</code>的特性(Attribute)，使用这个特性，我们可以在部分信任的应用程序中，调用一些需要完全信任权限才能调用的程序集，这对于我们是一个好消息，尤其是ASP.NET应用程序。CAS的使用需要辅以“证据”，我们可以看看下图中CAS的构建模块：</p><p><img src="/photos/2010-04-11-dotnet-4-changes-on-clr-and-bcl-2/1.jpg" alt="CAS"></p><p>.NET 4中的证据类型基类Evidence现在可以确保继承它的证据类型是非空和可序列化的。额外的，新加入了一些方法可以用于查询证据的具体类型，这在先前的版本中是通过遍历来实现的。</p><h2 id="监测与分析"><a href="#监测与分析" class="headerlink" title="监测与分析"></a>监测与分析</h2><p>.NET 4的改进中不得不提的是，我们现在可以获取每个应用程序域关于CPU和内存的使用情况了，这对于ASP.NET应用程序是个不错的功能，很多时候我们需要知道应用程序的状况来做相关的优化时却措手无策，现在好了，新的改进可以使开发人员从容淡定的了解其应用程序的运行状况，然后淡定的修修补补，OK，效率上去了。</p><p>当然了，新的API肯定是有的，新增的API可以用做profiling和debugging，总的原则就是改善程序员的生存状态，不要累死在Debug上，嗯。</p><p>监测程序不正常的传统做法就是异常处理，我们经常这么做：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//Do some thing</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(System.exception e) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法很不推荐，因为所有的异常将被隐藏，然而我们往往希望一些异常不要被捕获，例如一些可以访问冲突或者调用非法指令的异常，这时应该让程序在出现异常时退出来而不是由catch将所有的异常捕获，因为这些异常具有一定潜在的危险性。.NET 4中引入了新的特性，那就是在方法体上标注<code>[HandleProcessCorruptedStateExceptions]</code>，这样，当破坏状态的异常出现时，将不会被catch捕获了。</p><p>那如果想捕获这些破坏状态的异常，比如将它传递到一个异常Logging类，好办，应用程序配置文件里加入这么一行：<code>LegacyCorruptedStateExceptionsPolicy = true</code>，catch就可以捕获到它了。</p><h2 id="Dynamic的引入与DLR"><a href="#Dynamic的引入与DLR" class="headerlink" title="Dynamic的引入与DLR"></a>Dynamic的引入与DLR</h2><p>这个特性绝对是.NET 4的重头戏，将它与Parallel特性封为4上最重要的功能一点也不过分。</p><p>先让我们来看一下先前版本的.NET对加入动态语言到.NET框架时是怎么做的：</p><p><img src="/photos/2010-04-11-dotnet-4-changes-on-clr-and-bcl-2/2.jpg" alt="dynamic before"></p><p>可以看的出，Python和Ruby等这些动态语言是通过直接原生的在CLR上编写而实现移植。我们有理由想像在一个非动态的运行时上实现动态语言的难度是何等之大！</p><p>.NET 4提出的DLR是一个动态语言运行时，也就是说是微软官方提供的在CLR的基础上提供一层动态语言抽象层，来实现“门门语言为我，我为门门语言”的大友好框架主义，在此特性上，要移植一门动态语言到.NET平台上，好，去找DLR，那静态语言呢？直接去搞CLR。举个例子，今天我看上Javascript这姑娘了，想搞出个Javascript.NET，以实现我浏览器大友好.NET主义，理论上可行，可以联系DLR大哥；隔天又看上Java了……算了，我们换个例子，看上Scale了，好，给你张CLR的名片，我等.NET民众合谐友好。</p><p>那么具体的DLR在.NET 4所处的处置就是下面这个样子：</p><p><img src="/photos/2010-04-11-dotnet-4-changes-on-clr-and-bcl-2/3.jpg" alt="dynamic now"></p><p>咦？C#和VB也可以使用DLR？当然了，为了交互的方便么。所以我们可以介绍怎样在C#等静态语言中使用动态语言的功能了。</p><p>于是我们有理由相信，.NET 4上的语言会越来越多，事实从<a href="http://www.dotnetlanguages.net/DNL/Resources.aspx" target="_blank" rel="noopener">一些消息</a>上看，好像已经有二三十种的样子，著名的好像还是一些比较大的语言。当Python和Ruby在DLR上开始构建时，我相信可以实现的灵活度会大大提高。下面是官方的一张PPT：</p><p><img src="/photos/2010-04-11-dotnet-4-changes-on-clr-and-bcl-2/4.jpg" alt="dynamic ppt"></p><p>当然了，这是编程层面的东西，例如C#和VB.NET其实是构建在CLR上的，只不过可以通过DLR来实现一些动态编程的特性。</p><p>.NET 4新加入的动态功能可以使我们方便的在运行时获取一个未知类型的对象并对其进行操作。同样的，构建在DLR基础上的动态语言也可以通过DLR -&gt; CLR的方式来使用.NET类库。所以我们有理由相信，在使用COM方面，也将更加的简化。</p><p>动态语言是指在编译期不进行类型检查，在运行时动态的确定类型，这样的做的好处在于我们不必对未知的类型进行抽象，完全将其放在运行时动态的解析。然而其缺点也显而易见，那就是无法使用智能感知等强类型语言才拥有的特性，因此Debug也相对较困难一些。值得注意的是，动态语言的运行效率<strong>一定不会很高</strong>，因为在运行时进行解析是非常耗费资源的，并且对DLR来说，多一层抽象所带来的性能损失绝不对小视。我们可以想像一下将C#移植到Java平台上或者相反，理论上完全可行，因为.NET平台Java平台具有一定的相似性，对Java Bytecode和MSIL之间转换即可，然而效率问题确值得商榷。多一层抽象就多一层损耗，所以，在静态语言中使用动态特性一定要谨慎，不要滥用。</p><p>但是如果好奇，那么我们可以写个用反射来使用动态特性的Demo：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> UsingReflection = Activator.CreateInstance(Type.GetType(<span class="string">"System.Text.StringBuilder"</span>));</span><br><span class="line">Type ObjectType = UsingReflection.GetType();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Append有很多的重载，所以需要指定反射使用哪个重载</span></span><br><span class="line">Type[] TypeArray = <span class="keyword">new</span> Type[<span class="number">1</span>];</span><br><span class="line">TypeArray.SetValue(<span class="keyword">typeof</span>(<span class="keyword">string</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ObjectMethodInfo = ObjectType.GetMethod(<span class="string">"Append"</span>, TypeArray);</span><br><span class="line">ObjectMethodInfo.Invoke(UsingReflection, <span class="keyword">new</span> <span class="keyword">object</span>[] &#123; <span class="string">"alex"</span> &#125;);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(ObjectType</span><br><span class="line">.GetMethod(<span class="string">"ToString"</span>, <span class="keyword">new</span> Type[<span class="number">0</span>])</span><br><span class="line">.Invoke(UsingReflection, <span class="literal">null</span>));</span><br></pre></td></tr></table></figure><p>上面是使用反射的方式来动态使用StringBuilder的Append和ToString的示例，不知道您看的怎么样，反正弄的我晕晕，不知道是写代码晕还是被凤姐吓的。</p><p><img src="/photos/2010-04-11-dotnet-4-changes-on-clr-and-bcl-2/5.jpg" alt="yufeng luo"></p><p>我们可不可以换个优美的方式，至少，能不能像我们平常使用StringBuilder一样呢？在.NET 4，有了，使用DLR的特性就可以优美和谐一些了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> usingDynamic = Activator .CreateInstance(Type.GetType(<span class="string">"System.Text.StringBuilder"</span>));</span><br><span class="line">usingDynamic.Append(<span class="string">"Hello"</span>);</span><br><span class="line">Console.WriteLine(usingDynamic.ToString());</span><br></pre></td></tr></table></figure><p>很好很强大不是么？但是要再次重申：性能，性能！不到一定的成本和效率的折中点时，不要用！</p><p>也许很大人奇怪var关键字和dynamic关键字的异同，答案是：不同。var其实就是一个编译器魔法，在编译时将其替换成了强类型，所以我们可以使用智能感应来写代码，并提高了书写代码的效率，然而dynamic关键字的声明意味着您的代码将会在运行时进行真正的赋值（？解释有些模糊），所以在写上面代码时，例如<code>usingDynamic.Append(“Hello”)</code>;是完全没有智能感应的。我们可以期待微软在下一个版本将智能感应加进去，然后这将对机器性能是一个极大的考验，因为为了智能感应需要去实时的解析未知类型才能使我们优美的使用“.”来一路点下去……手指可以优美，机器不一定就优美了。</p><p>我们还可以这么做：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Dynamic;</span><br><span class="line"><span class="keyword">dynamic</span> toCreateType = <span class="keyword">new</span> ExpandoObject();</span><br><span class="line"></span><br><span class="line">toCreateType.Name = <span class="string">"LuRongkai"</span>;</span><br><span class="line">toCreateType.Age = <span class="number">21</span>;</span><br><span class="line">toCreateType.ShowInfo = <span class="keyword">new</span> Action(() =&gt; Console.WriteLine(<span class="string">"My age:"</span>, toCreateType.Age));</span><br><span class="line"></span><br><span class="line">Console.WriteLine(toCreateType.Name);</span><br><span class="line">toCreateType.ShowInfo();</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure><p>结果显示：</p><pre><code>LuRongkaiMy age:21</code></pre><p>Cool，不是么？如果想要进一步控制对象在运行时的特性，可以使用<code>System.Dynamic.DynamicObject</code>对象，可以继承它来使用，我写了个例子来说明一下这个对象的使用方式：</p><p>首先，定义一定SimpleXML类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleXML</span> : <span class="title">DynamicObject</span>&#123;</span><br><span class="line"><span class="keyword">private</span> XDocument _xml = <span class="keyword">new</span> XDocument();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleXML</span>(<span class="params"><span class="keyword">string</span> Xml</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>._xml = XDocument.Parse(Xml);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">TryGetMember</span>(<span class="params">GetMemberBinder binder, <span class="keyword">out</span> <span class="keyword">object</span> result</span>)</span>&#123;</span><br><span class="line"><span class="keyword">string</span> nodeName = binder.Name;</span><br><span class="line">result = _xml.Element(<span class="string">"root"</span>).Element(nodeName).Value;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们就可以使用动态的语言的特性来使用了，这里先简单的创建一个了测试的XML文件：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Dynamic;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dynamic</span> simpleXML = <span class="keyword">new</span> SimpleXML(<span class="string">@"LuRongkai21"</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(simpleXML.data1);</span><br><span class="line">Console.WriteLine(simpleXML.data2);</span><br></pre></td></tr></table></figure><p>优美，优美，优美！性能，性能，性能！</p><p>.NET 4中的重头戏就是Parallel和Dynamic，我们有理由相信今天的VS2010的发布将会给世界带来震撼，虽然这几篇文章是要讨论CLR和BLR的，但是没能忍住，好吧，下一次讨论BCL的一些new features。</p><p>相关链接：<a href="/blog/2010/04/12/dotnet-4-changes-on-clr-and-bcl-1/">.NET 4在CLR和BCL的一些变化(1)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/blog/2010/04/12/dotnet-4-changes-on-clr-and-bcl-1/&quot;&gt;上一篇&lt;/a&gt;讨论了.NET 4中关于垃圾回收、线程、并行、全球化等方面的内容，这次我们接着上次往下说。&lt;br&gt;
    
    </summary>
    
      <category term="dot-net" scheme="https://lurongkai.github.io/categories/dot-net/"/>
    
    
  </entry>
  
  <entry>
    <title>.NET 4在CLR和BCL的一些变化(1)</title>
    <link href="https://lurongkai.github.io/2010/04/11/dotnet-4-changes-on-clr-and-bcl-1/"/>
    <id>https://lurongkai.github.io/2010/04/11/dotnet-4-changes-on-clr-and-bcl-1/</id>
    <published>2010-04-11T06:41:00.000Z</published>
    <updated>2019-02-14T02:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>VS2010明天就要发布了，伴随而来的是.NET<br>Framework第四个版本的发布，借这个机会，聊聊相对于3.5，4又多了哪些新的特性。<br><a id="more"></a></p><p>我们知道，.NET<br>Framework是一个渐近发展的框架，自从2.0开始，框架底层本身并没有太大的变化，CLR的版本都是2.0的，4的发布是一个质飞跃，微软直接跳过了CLR 3.0的版本而将.NET Framework的版本更新为4，如此看来，先前3.0，3.5的程序可以在2.0的运行时上运行，想在新的运行时上运行的话必须要重新编译了。</p><p>.Net Framework 3.0加入了一些诸如WPF,WCF,WF,WCS的东西，3.5又更新了一些EF，LINQ的新特性，那么我们有理由相信4也将会带给我们更多的惊喜，这个惊喜便是：Parallel和DLR。</p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>CLR 2.0的运行机制大家一定很熟悉了，CLR为应用程序分配内存并且在适当的时候执行垃圾回收来释放内存。这里所说的适当可以理解为系统内存数量低或者其他对内存需求超过程<strong>合理</strong>范围的时候。</p><p>GC是怎么判断一个对象该执行清理了呢？CLR在内部建立了对象图来确定一个对象是否引用数为0，为0也就是不可达，清理之。CLR将分配内存的对象标记为0代，1代，2代，新分配的对象默认为0代，当CLR执行一次GC操作后没有被清理的对象将上升为1代，再清理，再升为2代，再清理，还是2代……不用多想，在CLR 2.0中最高就是2代。</p><p>GC的工作模式有3种：<code>workstation</code>, <code>concurrent workstation</code>, <code>server</code>，其中workstation是默认模式，而server模式用于多CPU服务器环境。workstation自不必细说，但是concurrent workstation模式下当一个GC正在执行中时，其他的GC是无法同时执行的。换句话讲，在concurrent workstation下GC的执行效率并不高，而server模式会开启一个新线程来进行GC操作，然而单个CPU上执行GC却和concurrent workstation相同。</p><p>那么CLR 4会有什么新的特性呢？一切为了效率，一切为了并行！CLR 4提出了后台GC来替代concurrent<br>workstation模式。后台GC支持与其他的GC同时执行。换句话讲，减少了GC执行的时间，资源可以更早的被释放。</p><p>但是后台GC这种特性在server模式上却不可用，不知道在后续版本中会不会改进。</p><p>先前版本的GC运行机制详情请猛击<a href="http://blog.csdn.net/isline/archive/2010/02/26/5328342.aspx" target="_blank" rel="noopener">PriorGC</a>。</p><p>Cool，与Parallel不谋而合，并行真是大势所趋……</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程上的改进主要在线程池上。</p><p>先前的线程池在获取线程信息上是很困难的，这不利于我们优化程序，于是.NET<br>4新提出了一个新的更加友好的数据结构：Task，较先前的ThreadPool而言效率更高，对GC也更加的友好。</p><p>一个简单的示例：</p><p>在.NET 4以前的版本里，我们可以这样使用线程池：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool.QueueUserWorkItem(_ =&gt; &#123;</span><br><span class="line">Console.WriteLine(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而在.NET 4中我们多了些选择：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task newTask = Task.Factory.StartNew(() =&gt; Console.WriteLine(<span class="string">"Hello world!"</span>));</span><br></pre></td></tr></table></figure><p>但是要注意到的是，现在我们可以通过程newTask.Status来获取一个TaskStatus枚举，这个枚举说明了当前Task的执行状态，当然了，还有很多的属性，总之，可以获取很多的运行时状态，而这一切在ThreadPool是做不到的。</p><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>说到线程上的改进就不能不提.NET 4的并行特性。新加入的支持并行特性的有</p><ul><li><p>TPL(Task Parallel Library并行任务库)和CCR(Concurrency and Coordination Runtime并发与协调运行时)</p></li><li><p>PLINQ(并行LINQ)</p></li><li><p>并发数据结构</p></li><li><p>PPL(Parallel Pattern Library并行模式库)</p></li></ul><p>当然了，还有一些支持并行开发的必要工具。大家知道并发和并行是两个不同的概念，主要体现在对CPU的使用方式上不同。并发多指的是多线程，而并行是多CPU同步执行，一个图示如下：</p><p><img src="/photos/2010-04-11-dotnet-4-changes-on-clr-and-bcl-1/1.png" alt="Parallel"></p><p>但是值得注意的是，并线与多线程会加重程序的复杂度。并行程序可以显著提高程序在多CPU环境下的执行效率，然而同步与死锁的问题仍然没有完美的解决，并且难于调试(虽然VS2010的IDE提供了很大的支持)，与多线程相同，在开发时要注意这一点。</p><p>.NET 4下使用并行来编程，经常用到的是<code>System.Threading.Tasks.Parallel</code>结构，我们可以写个简单的代码来看看。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Parallel.For(<span class="number">0</span>, <span class="number">100</span>, i =&gt; &#123;</span><br><span class="line">Console.WriteLine(<span class="string">"Hello world "</span> + i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第一个参数代表初始循环的值，第二个参数代表循环上限，第三个是Lambda表达式，传入的参数是当前任务的循环号，换种理解方式，我们可以将上述代码意淫为这样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parallel.Run(i =&gt; Console.WriteLine(<span class="string">"Hello world "</span> + i));</span><br></pre></td></tr></table></figure><p>当然了，真正的Parallel数据结构是没有这个方法的。</p><p>让我们猜一下运行结果：<code>Hello world 0,Hello world 1,……</code>？</p><p>答案是，不一定，如果将100改为10的话，或许是这样，但如果是100甚至更高的话，这个结果就不一定了。</p><p>因为是并行的，所以Console.WriteLine的“任务”可能是随机分配到某个CPU上，当任务数量小时，由于CPU速度很快，可能会出现貌似顺序执行的情形，但是当任务不断的复杂，数量不断增多时再测试，结果就不一样了。</p><p><img src="/photos/2010-04-11-dotnet-4-changes-on-clr-and-bcl-1/2.jpg" alt=""></p><p><code>Parallel.For</code>还可以传入一个<code>ParallelOptions</code>结构来指定一些执行选项，例如下面的代码可以指定CPU的数量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ParallelOptions taskOptions = <span class="keyword">new</span> ParallelOptions &#123; MaxDegreeOfParallelism = <span class="number">2</span> &#125;;</span><br><span class="line">Parallel.For(<span class="number">0</span>, <span class="number">100</span>, taskOptions, x =&gt; &#123;</span><br><span class="line"><span class="comment">//并行执行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然了，Parallel也可以指定一个IEnumerable集合，来迭代执行操作集合中的数据，这要使用<code>Parallel.ForEach</code>方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Parallel.ForEach(DataCollection, data =&gt; &#123;</span><br><span class="line">DoSomething(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里不得不提的是，Parallel还是谨慎使用，如果在一些小任务的大量使用Parallel来执行的话，性能上的损失会很大，例如先前<code>Parallel.For</code>的例子，执行时明显感到有一段时间的停滞后程序才开始执行。</p><p>也许有人会奇怪，为什么使用Parallel非得指定循环号呢？其实也不一定了，使用循环主要是考虑到大部分的并行任务都具有连贯性，然而如果我们并行任务不具有相似性，可以这么做：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Parallel.Invoke(</span><br><span class="line">() =&gt; &#123; <span class="comment">/*Task1*/</span> &#125;,</span><br><span class="line">() =&gt; &#123; <span class="comment">/*Task2*/</span> &#125;,</span><br><span class="line">() =&gt; &#123; <span class="comment">/*Task3*/</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个方法的参数是一个params数组，如些我们便可以指定所有的任务了。</p><h2 id="全球化"><a href="#全球化" class="headerlink" title="全球化"></a>全球化</h2><p>为了适应多种语言环境，在开发时往往需要选择适当的资源进行本地化，.NET 4在全球化的改进在于将原先的203种文化支持提升到354种。为什么不只有汉语和英语两种文支持呢？咳咳，其实我也想把小日本和棒子们和谐掉……但是，算了，我们继续往下说。</p><p>这些改进是只为Windows 7用户的，因为文化的支持是要受操作系统的制约。确切的讲，在.NET的全球化特性中，中性文化的属性将返回其对就的最为主流的文化特定语言，使用先前版本创建的全球化资源将不能在新版本.NET中使用。并且，.NET的全球化特性将支持Unicode 5.1的标准。</p><p>在这个版本中，废除了<code>WindowsOnlyCultures</code>和<code>FrameworkCultures</code>两个结构，所以整个框架和操作系统更加的统一、“和谐”……</p><p>与此同时，<code>TimeSpan</code>结构也为新的全球化特性而新加了一些重载，例如<code>Parse()</code>，<code>TryParse()</code>，<code>ParseExact()</code>，<code>TryParseExact()</code>等均支持新的特定文化Format，这是一个好消息！</p><p>下一次将讨论.NET 4中关于安全、监测与分析等方面的内容，真正的BCL上的改进介绍我打算放在第三篇甚至第四篇上来介绍。</p><p>(To be continue….)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VS2010明天就要发布了，伴随而来的是.NET&lt;br&gt;Framework第四个版本的发布，借这个机会，聊聊相对于3.5，4又多了哪些新的特性。&lt;br&gt;
    
    </summary>
    
      <category term="dot-net" scheme="https://lurongkai.github.io/categories/dot-net/"/>
    
    
  </entry>
  
  <entry>
    <title>mht和chm文件打不开的解决方法</title>
    <link href="https://lurongkai.github.io/2010/01/20/issues-of-mht-and-chm/"/>
    <id>https://lurongkai.github.io/2010/01/20/issues-of-mht-and-chm/</id>
    <published>2010-01-19T16:00:00.000Z</published>
    <updated>2019-02-14T02:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>先引入这两种文件：<br><a id="more"></a></p><blockquote><p>mht IE保存的文件格式，也不知道是什么版本开始成为默认的网页保存格式。</p></blockquote><blockquote><p>chm 不用解释了吧。</p></blockquote><p>情况是这样：双击mth文件打不开，双击chm文件打开后无法显示。</p><p>怎么办呢？</p><p>仔细检查了一下，发现了一些问题：文件名中是包含了一些特殊的字符，例如文件名为“C#测试.mht”，这样的话就会出现上述的问题。</p><p>为了进一步研究，尝试用正常的文件名，但是将路径中的目录名改为包含特殊的字符，也出现了上述的问题。</p><p>看来在文件名和路径中不能出现特殊的字符，那么在IE中将这些特殊的字符进行转义（或者称之为Encode更为合适）行不行呢？答案是：不行。</p><p>接下来有理由怀疑所谓的“特殊字符”绝不止”#”这一个字符，如果大家遇到类似的问题可以尝试检查文件名或者路径，估计这样可以解决99%的所谓mht文件打不开的故障吧。</p><p>（上述问题已经反馈到微软，暂时没有一个完整解决方案，例如补丁什么的）</p><p>说完.mht，回过头来说.chm。</p><p>我的解决方案就一条：参照上述解决方法，原因是我已经用这种方法解决了，如果不行，请Google之。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先引入这两种文件：&lt;br&gt;
    
    </summary>
    
      <category term="tips" scheme="https://lurongkai.github.io/categories/tips/"/>
    
    
  </entry>
  
</feed>
